<net.rptools.maptool.model.Token>
  <id>
    <baGUID>wKgBWgHyji52AgAAAIgAAA==</baGUID>
  </id>
  <beingImpersonated>false</beingImpersonated>
  <imageAssetMap>
    <entry>
      <null/>
      <net.rptools.lib.MD5Key>
        <id>f443ceb79f9f31a3ea57c6058b772c70</id>
      </net.rptools.lib.MD5Key>
    </entry>
  </imageAssetMap>
  <x>800</x>
  <y>100</y>
  <z>55</z>
  <anchorX>0</anchorX>
  <anchorY>0</anchorY>
  <sizeScale>1.0</sizeScale>
  <lastX>0</lastX>
  <lastY>0</lastY>
  <snapToScale>true</snapToScale>
  <width>256</width>
  <height>256</height>
  <scaleX>1.0</scaleX>
  <scaleY>1.0</scaleY>
  <sizeMap>
    <entry>
      <java-class>net.rptools.maptool.model.SquareGrid</java-class>
      <net.rptools.maptool.model.GUID>
        <baGUID>fwABAc9lFSoFAAAAKgABAQ==</baGUID>
      </net.rptools.maptool.model.GUID>
    </entry>
  </sizeMap>
  <snapToGrid>true</snapToGrid>
  <isVisible>true</isVisible>
  <name>Lib:4e</name>
  <ownerType>0</ownerType>
  <tokenShape>CIRCLE</tokenShape>
  <tokenType>NPC</tokenType>
  <layer>TOKEN</layer>
  <propertyType>Library</propertyType>
  <isFlippedX>false</isFlippedX>
  <isFlippedY>false</isFlippedY>
  <sightType>Normal</sightType>
  <hasSight>false</hasSight>
  <label>Version 4.1.2</label>
  <state>
    <entry>
      <string>Immed_Reaction_Used</string>
      <boolean>false</boolean>
    </entry>
    <entry>
      <string>Curse</string>
      <boolean>false</boolean>
    </entry>
    <entry>
      <string>Vlnrbl_Untyped</string>
      <boolean>false</boolean>
    </entry>
    <entry>
      <string>AttackBonus</string>
      <boolean>false</boolean>
    </entry>
    <entry>
      <string>Vlnrbl_Fire</string>
      <boolean>false</boolean>
    </entry>
    <entry>
      <string>Other2</string>
      <boolean>false</boolean>
    </entry>
    <entry>
      <string>Other3</string>
      <boolean>false</boolean>
    </entry>
    <entry>
      <string>Dying</string>
      <boolean>false</boolean>
    </entry>
    <entry>
      <string>Other4</string>
      <boolean>false</boolean>
    </entry>
    <entry>
      <string>Invisible</string>
      <boolean>false</boolean>
    </entry>
    <entry>
      <string>OngoingForce</string>
      <boolean>false</boolean>
    </entry>
    <entry>
      <string>Vlnrbl_Radiant</string>
      <boolean>false</boolean>
    </entry>
    <entry>
      <string>Surprised</string>
      <boolean>false</boolean>
    </entry>
    <entry>
      <string>MinusThree</string>
      <boolean>false</boolean>
    </entry>
    <entry>
      <string>Disabled</string>
      <boolean>false</boolean>
    </entry>
    <entry>
      <string>OngoingLightning</string>
      <boolean>false</boolean>
    </entry>
    <entry>
      <string>OngoingUntyped</string>
      <boolean>false</boolean>
    </entry>
    <entry>
      <string>MinusFour</string>
      <boolean>false</boolean>
    </entry>
    <entry>
      <string>Resist_Cold</string>
      <boolean>false</boolean>
    </entry>
    <entry>
      <string>Sneak_Attack_Used</string>
      <boolean>false</boolean>
    </entry>
    <entry>
      <string>Stunned</string>
      <boolean>false</boolean>
    </entry>
    <entry>
      <string>Dazed</string>
      <boolean>false</boolean>
    </entry>
    <entry>
      <string>Other</string>
      <boolean>false</boolean>
    </entry>
    <entry>
      <string>Unconscious</string>
      <boolean>false</boolean>
    </entry>
    <entry>
      <string>Hidden</string>
      <boolean>false</boolean>
    </entry>
    <entry>
      <string>Prone</string>
      <boolean>false</boolean>
    </entry>
    <entry>
      <string>OngoingNecrotic</string>
      <boolean>false</boolean>
    </entry>
    <entry>
      <string>Vlnrbl_Thunder</string>
      <boolean>false</boolean>
    </entry>
    <entry>
      <string>Slowed</string>
      <boolean>false</boolean>
    </entry>
    <entry>
      <string>Resist_Acid</string>
      <boolean>false</boolean>
    </entry>
    <entry>
      <string>Resist_All</string>
      <boolean>false</boolean>
    </entry>
    <entry>
      <string>Concealed</string>
      <boolean>false</boolean>
    </entry>
    <entry>
      <string>CombatChallenge</string>
      <boolean>false</boolean>
    </entry>
    <entry>
      <string>Regeneration</string>
      <boolean>false</boolean>
    </entry>
    <entry>
      <string>SecondWindBonus</string>
      <boolean>false</boolean>
    </entry>
    <entry>
      <string>Resist_Necrotic</string>
      <boolean>false</boolean>
    </entry>
    <entry>
      <string>Natures_Wrath</string>
      <boolean>false</boolean>
    </entry>
    <entry>
      <string>Resist_Radiant</string>
      <boolean>false</boolean>
    </entry>
    <entry>
      <string>DivineChallenge</string>
      <boolean>false</boolean>
    </entry>
    <entry>
      <string>OngoingCold</string>
      <boolean>false</boolean>
    </entry>
    <entry>
      <string>Bloodied</string>
      <boolean>false</boolean>
    </entry>
    <entry>
      <string>Immobilized</string>
      <boolean>false</boolean>
    </entry>
    <entry>
      <string>Vlnrbl_Cold</string>
      <boolean>false</boolean>
    </entry>
    <entry>
      <string>TotalConcealment</string>
      <boolean>false</boolean>
    </entry>
    <entry>
      <string>CombatAdvantage_All</string>
      <boolean>false</boolean>
    </entry>
    <entry>
      <string>OngoingPoison</string>
      <boolean>false</boolean>
    </entry>
    <entry>
      <string>PlusFive</string>
      <boolean>false</boolean>
    </entry>
    <entry>
      <string>OngoingFire</string>
      <boolean>false</boolean>
    </entry>
    <entry>
      <string>Resist_Poison</string>
      <boolean>false</boolean>
    </entry>
    <entry>
      <string>OngoingThunder</string>
      <boolean>false</boolean>
    </entry>
    <entry>
      <string>Vlnrbl_Necrotic</string>
      <boolean>false</boolean>
    </entry>
    <entry>
      <string>DefensePenalty</string>
      <boolean>false</boolean>
    </entry>
    <entry>
      <string>Dead</string>
      <boolean>false</boolean>
    </entry>
    <entry>
      <string>Aegis</string>
      <boolean>false</boolean>
    </entry>
    <entry>
      <string>Vlnrbl_Lightning</string>
      <boolean>false</boolean>
    </entry>
    <entry>
      <string>Incapacitated</string>
      <boolean>false</boolean>
    </entry>
    <entry>
      <string>AP_Used</string>
      <boolean>false</boolean>
    </entry>
    <entry>
      <string>MinusTwo</string>
      <boolean>false</boolean>
    </entry>
    <entry>
      <string>MinusFive</string>
      <boolean>false</boolean>
    </entry>
    <entry>
      <string>MinusOne</string>
      <boolean>false</boolean>
    </entry>
    <entry>
      <string>Weakened</string>
      <boolean>false</boolean>
    </entry>
    <entry>
      <string>Resist_Psychic</string>
      <boolean>false</boolean>
    </entry>
    <entry>
      <string>Quarry</string>
      <boolean>false</boolean>
    </entry>
    <entry>
      <string>Vlnrbl_Acid</string>
      <boolean>false</boolean>
    </entry>
    <entry>
      <string>Vlnrbl_Poison</string>
      <boolean>false</boolean>
    </entry>
    <entry>
      <string>OngoingAcid</string>
      <boolean>false</boolean>
    </entry>
    <entry>
      <string>Deafened</string>
      <boolean>false</boolean>
    </entry>
    <entry>
      <string>BasicMark</string>
      <boolean>false</boolean>
    </entry>
    <entry>
      <string>Resist_Untyped</string>
      <boolean>false</boolean>
    </entry>
    <entry>
      <string>OngoingPsychic</string>
      <boolean>false</boolean>
    </entry>
    <entry>
      <string>PlusTwo</string>
      <boolean>false</boolean>
    </entry>
    <entry>
      <string>Vlnrbl_Psychic</string>
      <boolean>false</boolean>
    </entry>
    <entry>
      <string>Blinded</string>
      <boolean>false</boolean>
    </entry>
    <entry>
      <string>Petrified</string>
      <boolean>false</boolean>
    </entry>
    <entry>
      <string>Oath</string>
      <boolean>false</boolean>
    </entry>
    <entry>
      <string>Resist_Force</string>
      <boolean>false</boolean>
    </entry>
    <entry>
      <string>Resist_Lightning</string>
      <boolean>false</boolean>
    </entry>
    <entry>
      <string>Dominated</string>
      <boolean>false</boolean>
    </entry>
    <entry>
      <string>Curse_Damage_Used</string>
      <boolean>false</boolean>
    </entry>
    <entry>
      <string>Vlnrbl_All</string>
      <boolean>false</boolean>
    </entry>
    <entry>
      <string>Resist_Thunder</string>
      <boolean>false</boolean>
    </entry>
    <entry>
      <string>PlusThree</string>
      <boolean>false</boolean>
    </entry>
    <entry>
      <string>PlusOne</string>
      <boolean>false</boolean>
    </entry>
    <entry>
      <string>AttackPenalty</string>
      <boolean>false</boolean>
    </entry>
    <entry>
      <string>Quarry_Damage_Used</string>
      <boolean>false</boolean>
    </entry>
    <entry>
      <string>Reticle</string>
      <boolean>false</boolean>
    </entry>
    <entry>
      <string>PlusFour</string>
      <boolean>false</boolean>
    </entry>
    <entry>
      <string>Resist_Fire</string>
      <boolean>false</boolean>
    </entry>
    <entry>
      <string>DefenseBonus</string>
      <boolean>false</boolean>
    </entry>
    <entry>
      <string>Restrained</string>
      <boolean>false</boolean>
    </entry>
    <entry>
      <string>Vlnrbl_Force</string>
      <boolean>false</boolean>
    </entry>
  </state>
  <propertyMap class="net.rptools.CaseInsensitiveHashMap">
    <store>
      <entry>
        <string>skills</string>
        <net.rptools.CaseInsensitiveHashMap_-KeyValue>
          <key>Skills</key>
          <outer-class reference="../../../.."/>
        </net.rptools.CaseInsensitiveHashMap_-KeyValue>
      </entry>
      <entry>
        <string>lastattacker</string>
        <net.rptools.CaseInsensitiveHashMap_-KeyValue>
          <key>LastAttacker</key>
          <value class="string"></value>
          <outer-class reference="../../../.."/>
        </net.rptools.CaseInsensitiveHashMap_-KeyValue>
      </entry>
      <entry>
        <string>xp</string>
        <net.rptools.CaseInsensitiveHashMap_-KeyValue>
          <key>XP</key>
          <outer-class reference="../../../.."/>
        </net.rptools.CaseInsensitiveHashMap_-KeyValue>
      </entry>
      <entry>
        <string>-------------data storage-----------</string>
        <net.rptools.CaseInsensitiveHashMap_-KeyValue>
          <key>-------------DATA STORAGE-----------</key>
          <outer-class reference="../../../.."/>
        </net.rptools.CaseInsensitiveHashMap_-KeyValue>
      </entry>
      <entry>
        <string>currhp</string>
        <net.rptools.CaseInsensitiveHashMap_-KeyValue>
          <key>CurrHP</key>
          <outer-class reference="../../../.."/>
        </net.rptools.CaseInsensitiveHashMap_-KeyValue>
      </entry>
      <entry>
        <string>intbonus</string>
        <net.rptools.CaseInsensitiveHashMap_-KeyValue>
          <key>IntBonus</key>
          <outer-class reference="../../../.."/>
        </net.rptools.CaseInsensitiveHashMap_-KeyValue>
      </entry>
      <entry>
        <string>movement</string>
        <net.rptools.CaseInsensitiveHashMap_-KeyValue>
          <key>Movement</key>
          <outer-class reference="../../../.."/>
        </net.rptools.CaseInsensitiveHashMap_-KeyValue>
      </entry>
      <entry>
        <string>vadjusts</string>
        <net.rptools.CaseInsensitiveHashMap_-KeyValue>
          <key>VAdjusts</key>
          <value class="string">Vlnrbl_All,Vlnrbl_Acid,Vlnrbl_Cold,Vlnrbl_Fire,Vlnrbl_Force,Vlnrbl_Lightning,Vlnrbl_Necrotic,Vlnrbl_Poison,Vlnrbl_Psychic,Vlnrbl_Radiant,Vlnrbl_Thunder,Vlnrbl_Untyped</value>
          <outer-class reference="../../../.."/>
        </net.rptools.CaseInsensitiveHashMap_-KeyValue>
      </entry>
      <entry>
        <string>defadjustments</string>
        <net.rptools.CaseInsensitiveHashMap_-KeyValue>
          <key>DefAdjustments</key>
          <value class="string">DefenseBonus,DefensePenalty</value>
          <outer-class reference="../../../.."/>
        </net.rptools.CaseInsensitiveHashMap_-KeyValue>
      </entry>
      <entry>
        <string>intelligence</string>
        <net.rptools.CaseInsensitiveHashMap_-KeyValue>
          <key>Intelligence</key>
          <outer-class reference="../../../.."/>
        </net.rptools.CaseInsensitiveHashMap_-KeyValue>
      </entry>
      <entry>
        <string>secondwind</string>
        <net.rptools.CaseInsensitiveHashMap_-KeyValue>
          <key>SecondWind</key>
          <outer-class reference="../../../.."/>
        </net.rptools.CaseInsensitiveHashMap_-KeyValue>
      </entry>
      <entry>
        <string>holding1</string>
        <net.rptools.CaseInsensitiveHashMap_-KeyValue>
          <key>Holding1</key>
          <outer-class reference="../../../.."/>
        </net.rptools.CaseInsensitiveHashMap_-KeyValue>
      </entry>
      <entry>
        <string>holding2</string>
        <net.rptools.CaseInsensitiveHashMap_-KeyValue>
          <key>Holding2</key>
          <outer-class reference="../../../.."/>
        </net.rptools.CaseInsensitiveHashMap_-KeyValue>
      </entry>
      <entry>
        <string>surgevalue</string>
        <net.rptools.CaseInsensitiveHashMap_-KeyValue>
          <key>SurgeValue</key>
          <outer-class reference="../../../.."/>
        </net.rptools.CaseInsensitiveHashMap_-KeyValue>
      </entry>
      <entry>
        <string>vulnerable</string>
        <net.rptools.CaseInsensitiveHashMap_-KeyValue>
          <key>Vulnerable</key>
          <outer-class reference="../../../.."/>
        </net.rptools.CaseInsensitiveHashMap_-KeyValue>
      </entry>
      <entry>
        <string>rumble.deletemacroundo</string>
        <net.rptools.CaseInsensitiveHashMap_-KeyValue>
          <key>Rumble.DeleteMacroUndo</key>
          <value class="string">{&quot;Edit Damage Multipliers&quot;:{&quot;fontColor&quot;:&quot;black&quot;,&quot;index&quot;:23,&quot;maxWith&quot;:&quot;&quot;,&quot;minWidth&quot;:&quot;&quot;,&quot;compare&quot;:[&quot;group&quot;,&quot;sortPrefix&quot;,&quot;command&quot;,&quot;includeLabel&quot;,&quot;autoExecute&quot;,&quot;applyToSelected&quot;],&quot;label&quot;:&quot;Edit Damage Multipliers&quot;,&quot;autoExecute&quot;:true,&quot;fontSize&quot;:&quot;1.00em&quot;,&quot;sortBy&quot;:&quot;&quot;,&quot;color&quot;:&quot;default&quot;,&quot;includeLabel&quot;:false,&quot;playerEditable&quot;:true,&quot;command&quot;:&quot;[h:mults=json.toStrProp(DamMultiplier)]\n\n[mults]\n\n[h:status=input(\n   \&quot;junk|Enter multiplier (0.5 for half damage, 1 for full damage, etc.)|Damage Multipliers|LABEL\&quot;,\n   \&quot;newDamMult|\&quot;+mults+\&quot;|Multipliers|PROPS\&quot;\n)]\n[h:abort(status)]\n\n[h:DamMultiplier=json.fromStrProp(newDamMult)]\n\n[h:input(\&quot;.|Damage Multipliers Updated||LABEL|SPAN=TRUE\&quot;)]&quot;,&quot;applyToSelected&quot;:false,&quot;group&quot;:&quot;Character Management&quot;,&quot;tooltip&quot;:&quot;&quot;},&quot;Resistance and Vulnerability&quot;:{&quot;fontColor&quot;:&quot;black&quot;,&quot;index&quot;:20,&quot;maxWith&quot;:&quot;&quot;,&quot;minWidth&quot;:&quot;&quot;,&quot;compare&quot;:[&quot;group&quot;,&quot;sortPrefix&quot;,&quot;command&quot;,&quot;includeLabel&quot;,&quot;autoExecute&quot;,&quot;applyToSelected&quot;],&quot;label&quot;:&quot;Resistance and Vulnerability&quot;,&quot;autoExecute&quot;:true,&quot;fontSize&quot;:&quot;1.00em&quot;,&quot;sortBy&quot;:&quot;&quot;,&quot;color&quot;:&quot;default&quot;,&quot;includeLabel&quot;:false,&quot;playerEditable&quot;:true,&quot;command&quot;:&quot;[h:resistance=json.toStrProp(Resist)]\n[h:vulnerability=json.toStrProp(Vulnerable)]\n\n[H: status=input(\n   \&quot;newResValues|\&quot;+resistance+\&quot;|Resist|PROPS\&quot;,\n   \&quot;newVulnValues|\&quot;+vulnerability+\&quot;|Vulnerable| PROPS\&quot;\n)]\n\n[H: abort(status)]\n\n[h:Resist=json.fromStrProp(newResValues)]\n[h:Vulnerable=json.fromStrProp(newVulnValues)]\n\n\n[h:input(\&quot;.|Resistance and Vulnerability Updated||LABEL|SPAN=TRUE\&quot;)]&quot;,&quot;applyToSelected&quot;:false,&quot;group&quot;:&quot;Character Management&quot;,&quot;tooltip&quot;:&quot;&quot;},&quot;Edit Character Skills&quot;:{&quot;fontColor&quot;:&quot;black&quot;,&quot;index&quot;:21,&quot;maxWith&quot;:&quot;&quot;,&quot;minWidth&quot;:&quot;&quot;,&quot;compare&quot;:[&quot;group&quot;,&quot;sortPrefix&quot;,&quot;command&quot;,&quot;includeLabel&quot;,&quot;autoExecute&quot;,&quot;applyToSelected&quot;],&quot;label&quot;:&quot;Edit Character Skills&quot;,&quot;autoExecute&quot;:true,&quot;fontSize&quot;:&quot;1.00em&quot;,&quot;sortBy&quot;:&quot;&quot;,&quot;color&quot;:&quot;default&quot;,&quot;includeLabel&quot;:false,&quot;playerEditable&quot;:true,&quot;command&quot;:&quot;[H: status=input(\n\&quot;newAcrobatics|\&quot;+json.get(Skills, \&quot;Acrobatics\&quot;)+\&quot;|Acrobatics\&quot;,\n\&quot;newArcana|\&quot;+json.get(Skills,\&quot;Arcana\&quot;)+\&quot;|Arcana\&quot;,\n\&quot;newAthletics|\&quot;+json.get(Skills,\&quot;Athletics\&quot;)+\&quot;|Athletics\&quot;,\n\&quot;newBluff|\&quot;+json.get(Skills,\&quot;Bluff\&quot;)+\&quot;|Bluff\&quot;,\n\&quot;newDiplomacy|\&quot;+json.get(Skills,\&quot;Diplomacy\&quot;)+\&quot;|Diplomacy\&quot;,\n\&quot;newDungeon|\&quot;+json.get(Skills,\&quot;Dungeoneering\&quot;)+\&quot;|Dungeoneering\&quot;,\n\&quot;newEndurance|\&quot;+json.get(Skills,\&quot;Endurance\&quot;)+\&quot;|Endurance\&quot;,\n\&quot;newHeal|\&quot;+json.get(Skills,\&quot;Heal\&quot;)+\&quot;|Heal\&quot;,\n\&quot;newHistory|\&quot;+json.get(Skills,\&quot;History\&quot;)+\&quot;|History\&quot;,\n\&quot;newInsight|\&quot;+json.get(Skills,\&quot;Insight\&quot;)+\&quot;|Insight\&quot;,\n\&quot;newIntim|\&quot;+json.get(Skills,\&quot;Intimidate\&quot;)+\&quot;|Intimidate\&quot;,\n\&quot;newNature|\&quot;+json.get(Skills,\&quot;Nature\&quot;)+\&quot;|Nature\&quot;,\n\&quot;newPercep|\&quot;+json.get(Skills,\&quot;Perception\&quot;)+\&quot;|Perception\&quot;,\n\&quot;newReligion|\&quot;+json.get(Skills,\&quot;Religion\&quot;)+\&quot;|Religion\&quot;,\n\&quot;newStealth|\&quot;+json.get(Skills,\&quot;Stealth\&quot;)+\&quot;|Stealth\&quot;,\n\&quot;newStreetwise|\&quot;+json.get(Skills,\&quot;Streetwise\&quot;)+\&quot;|Streetwise\&quot;,\n\&quot;newThievery|\&quot;+json.get(Skills,\&quot;Thievery\&quot;)+\&quot;|Thievery\&quot;\n)]\n\n[H: abort(status)]\n\n[h:modifiedSkills=json.set(\&quot;{}\&quot;, \&quot;Acrobatics\&quot;, newAcrobatics, \&quot;Arcana\&quot;, newArcana, \&quot;Athletics\&quot;, newAthletics, \&quot;Bluff\&quot;, newBluff, \&quot;Diplomacy\&quot;, newDiplomacy, \&quot;Dungeoneering\&quot;, newDungeon, \&quot;Endurance\&quot;, newEndurance, \&quot;Heal\&quot;, newHeal, \&quot;History\&quot;, newHistory, \&quot;Insight\&quot;, newInsight, \&quot;Intimidate\&quot;, newIntim, \&quot;Nature\&quot;, newNature, \&quot;Perception\&quot;, newPercep, \&quot;Religion\&quot;, newReligion, \&quot;Stealth\&quot;, newStealth, \&quot;Streetwise\&quot;, newStreetwise, \&quot;Thievery\&quot;, newThievery)]\n\n[h:Skills=modifiedSkills]\n\n\n[h:input(\&quot;.|Character Skills Updated||LABEL|SPAN=TRUE\&quot;)]&quot;,&quot;applyToSelected&quot;:false,&quot;group&quot;:&quot;Character Management&quot;,&quot;tooltip&quot;:&quot;&quot;}}</value>
          <outer-class reference="../../../.."/>
        </net.rptools.CaseInsensitiveHashMap_-KeyValue>
      </entry>
      <entry>
        <string>genwillmod</string>
        <net.rptools.CaseInsensitiveHashMap_-KeyValue>
          <key>GenWillMod</key>
          <outer-class reference="../../../.."/>
        </net.rptools.CaseInsensitiveHashMap_-KeyValue>
      </entry>
      <entry>
        <string>will</string>
        <net.rptools.CaseInsensitiveHashMap_-KeyValue>
          <key>Will</key>
          <outer-class reference="../../../.."/>
        </net.rptools.CaseInsensitiveHashMap_-KeyValue>
      </entry>
      <entry>
        <string>holding3</string>
        <net.rptools.CaseInsensitiveHashMap_-KeyValue>
          <key>Holding3</key>
          <outer-class reference="../../../.."/>
        </net.rptools.CaseInsensitiveHashMap_-KeyValue>
      </entry>
      <entry>
        <string>apspent</string>
        <net.rptools.CaseInsensitiveHashMap_-KeyValue>
          <key>APSpent</key>
          <outer-class reference="../../../.."/>
        </net.rptools.CaseInsensitiveHashMap_-KeyValue>
      </entry>
      <entry>
        <string>currenthitinfo</string>
        <net.rptools.CaseInsensitiveHashMap_-KeyValue>
          <key>currentHitInfo</key>
          <outer-class reference="../../../.."/>
        </net.rptools.CaseInsensitiveHashMap_-KeyValue>
      </entry>
      <entry>
        <string>attadjustments</string>
        <net.rptools.CaseInsensitiveHashMap_-KeyValue>
          <key>AttAdjustments</key>
          <value class="string">AttackBonus,AttackPenalty</value>
          <outer-class reference="../../../.."/>
        </net.rptools.CaseInsensitiveHashMap_-KeyValue>
      </entry>
      <entry>
        <string>genfortmod</string>
        <net.rptools.CaseInsensitiveHashMap_-KeyValue>
          <key>GenFortMod</key>
          <outer-class reference="../../../.."/>
        </net.rptools.CaseInsensitiveHashMap_-KeyValue>
      </entry>
      <entry>
        <string>dexterity</string>
        <net.rptools.CaseInsensitiveHashMap_-KeyValue>
          <key>Dexterity</key>
          <outer-class reference="../../../.."/>
        </net.rptools.CaseInsensitiveHashMap_-KeyValue>
      </entry>
      <entry>
        <string>rvadjustments</string>
        <net.rptools.CaseInsensitiveHashMap_-KeyValue>
          <key>RVAdjustments</key>
          <value class="string">&quot;Resist_All,Resist_Acid,Resist_Cold,Resist_Fire,Resist_Force,Resist_Lightning,Resist_Necrotic,Resist_Poison,Resist_Psychic,Resist_Radiant,Resist_Thunder,Resist_Untyped,Vlnrbl_All,Vlnrbl_Acid,Vlnrbl_Cold,Vlnrbl_Fire,Vlnrbl_Force,Vlnrbl_Lightning,Vlnrbl_Necrotic,Vlnrbl_Poison,Vlnrbl_Psychic,Vlnrbl_Radiant,Vlnrbl_Thunder,Vlnrbl_Untyped&quot;</value>
          <outer-class reference="../../../.."/>
        </net.rptools.CaseInsensitiveHashMap_-KeyValue>
      </entry>
      <entry>
        <string>currentattackinfo</string>
        <net.rptools.CaseInsensitiveHashMap_-KeyValue>
          <key>currentAttackInfo</key>
          <outer-class reference="../../../.."/>
        </net.rptools.CaseInsensitiveHashMap_-KeyValue>
      </entry>
      <entry>
        <string>--------------misc-----------------</string>
        <net.rptools.CaseInsensitiveHashMap_-KeyValue>
          <key>--------------MISC-----------------</key>
          <outer-class reference="../../../.."/>
        </net.rptools.CaseInsensitiveHashMap_-KeyValue>
      </entry>
      <entry>
        <string>edcharskshowonce</string>
        <net.rptools.CaseInsensitiveHashMap_-KeyValue>
          <key>edCharSkShowOnce</key>
          <value class="string">1</value>
          <outer-class reference="../../../.."/>
        </net.rptools.CaseInsensitiveHashMap_-KeyValue>
      </entry>
      <entry>
        <string>externaltiming</string>
        <net.rptools.CaseInsensitiveHashMap_-KeyValue>
          <key>ExternalTiming</key>
          <outer-class reference="../../../.."/>
        </net.rptools.CaseInsensitiveHashMap_-KeyValue>
      </entry>
      <entry>
        <string>markedby</string>
        <net.rptools.CaseInsensitiveHashMap_-KeyValue>
          <key>MarkedBy</key>
          <outer-class reference="../../../.."/>
        </net.rptools.CaseInsensitiveHashMap_-KeyValue>
      </entry>
      <entry>
        <string>dexbonus</string>
        <net.rptools.CaseInsensitiveHashMap_-KeyValue>
          <key>DexBonus</key>
          <outer-class reference="../../../.."/>
        </net.rptools.CaseInsensitiveHashMap_-KeyValue>
      </entry>
      <entry>
        <string>currentattackoptions</string>
        <net.rptools.CaseInsensitiveHashMap_-KeyValue>
          <key>currentAttackOptions</key>
          <outer-class reference="../../../.."/>
        </net.rptools.CaseInsensitiveHashMap_-KeyValue>
      </entry>
      <entry>
        <string>initbonus</string>
        <net.rptools.CaseInsensitiveHashMap_-KeyValue>
          <key>InitBonus</key>
          <outer-class reference="../../../.."/>
        </net.rptools.CaseInsensitiveHashMap_-KeyValue>
      </entry>
      <entry>
        <string>elevation</string>
        <net.rptools.CaseInsensitiveHashMap_-KeyValue>
          <key>Elevation</key>
          <outer-class reference="../../../.."/>
        </net.rptools.CaseInsensitiveHashMap_-KeyValue>
      </entry>
      <entry>
        <string>rvadjusts</string>
        <net.rptools.CaseInsensitiveHashMap_-KeyValue>
          <key>RVAdjusts</key>
          <value class="string">Resist_All,Resist_Acid,Resist_Cold,Resist_Fire,Resist_Force,Resist_Lightning,Resist_Necrotic,Resist_Poison,Resist_Psychic,Resist_Radiant,Resist_Thunder,Resist_Untyped,Vlnrbl_All,Vlnrbl_Acid,Vlnrbl_Cold,Vlnrbl_Fire,Vlnrbl_Force,Vlnrbl_Lightning,Vlnrbl_Necrotic,Vlnrbl_Poison,Vlnrbl_Psychic,Vlnrbl_Radiant,Vlnrbl_Thunder,Vlnrbl_Untyped</value>
          <outer-class reference="../../../.."/>
        </net.rptools.CaseInsensitiveHashMap_-KeyValue>
      </entry>
      <entry>
        <string>------------------|bonus|-------------------</string>
        <net.rptools.CaseInsensitiveHashMap_-KeyValue>
          <key>------------------|BONUS|-------------------</key>
          <outer-class reference="../../../.."/>
        </net.rptools.CaseInsensitiveHashMap_-KeyValue>
      </entry>
      <entry>
        <string>--------------skills-----------------</string>
        <net.rptools.CaseInsensitiveHashMap_-KeyValue>
          <key>--------------SKILLS-----------------</key>
          <outer-class reference="../../../.."/>
        </net.rptools.CaseInsensitiveHashMap_-KeyValue>
      </entry>
      <entry>
        <string>utility</string>
        <net.rptools.CaseInsensitiveHashMap_-KeyValue>
          <key>Utility</key>
          <outer-class reference="../../../.."/>
        </net.rptools.CaseInsensitiveHashMap_-KeyValue>
      </entry>
      <entry>
        <string>lasthit</string>
        <net.rptools.CaseInsensitiveHashMap_-KeyValue>
          <key>LastHit</key>
          <outer-class reference="../../../.."/>
        </net.rptools.CaseInsensitiveHashMap_-KeyValue>
      </entry>
      <entry>
        <string>dammultiplier</string>
        <net.rptools.CaseInsensitiveHashMap_-KeyValue>
          <key>DamMultiplier</key>
          <outer-class reference="../../../.."/>
        </net.rptools.CaseInsensitiveHashMap_-KeyValue>
      </entry>
      <entry>
        <string>whoseturnisit</string>
        <net.rptools.CaseInsensitiveHashMap_-KeyValue>
          <key>WhoseTurnIsIt</key>
          <value class="string">Example PC Token 35</value>
          <outer-class reference="../../../.."/>
        </net.rptools.CaseInsensitiveHashMap_-KeyValue>
      </entry>
      <entry>
        <string>maxhp</string>
        <net.rptools.CaseInsensitiveHashMap_-KeyValue>
          <key>MaxHP</key>
          <outer-class reference="../../../.."/>
        </net.rptools.CaseInsensitiveHashMap_-KeyValue>
      </entry>
      <entry>
        <string>edpowershowonce</string>
        <net.rptools.CaseInsensitiveHashMap_-KeyValue>
          <key>edPowerShowOnce</key>
          <value class="string">1</value>
          <outer-class reference="../../../.."/>
        </net.rptools.CaseInsensitiveHashMap_-KeyValue>
      </entry>
      <entry>
        <string>reflex</string>
        <net.rptools.CaseInsensitiveHashMap_-KeyValue>
          <key>Reflex</key>
          <outer-class reference="../../../.."/>
        </net.rptools.CaseInsensitiveHashMap_-KeyValue>
      </entry>
      <entry>
        <string>actionpoints</string>
        <net.rptools.CaseInsensitiveHashMap_-KeyValue>
          <key>ActionPoints</key>
          <outer-class reference="../../../.."/>
        </net.rptools.CaseInsensitiveHashMap_-KeyValue>
      </entry>
      <entry>
        <string>marks</string>
        <net.rptools.CaseInsensitiveHashMap_-KeyValue>
          <key>Marks</key>
          <value class="string">{&quot;Aegis&quot;:{&quot;range&quot;:2,&quot;duration&quot;:&quot;Special&quot;,&quot;friendlyName&quot;:&quot;Swordmage Aegis&quot;,&quot;verb&quot;:&quot;marked by&quot;},&quot;BasicMark&quot;:{&quot;range&quot;:&quot;LOS&quot;,&quot;duration&quot;:&quot;End of Your Next Turn&quot;,&quot;friendlyName&quot;:&quot;Basic Mark&quot;,&quot;verb&quot;:&quot;marked by&quot;},&quot;CombatChallenge&quot;:{&quot;range&quot;:1,&quot;duration&quot;:&quot;End of Your Next Turn&quot;,&quot;friendlyName&quot;:&quot;Combat Challenge&quot;,&quot;verb&quot;:&quot;marked by&quot;},&quot;Curse&quot;:{&quot;range&quot;:&quot;nearest&quot;,&quot;duration&quot;:&quot;Special&quot;,&quot;friendlyName&quot;:&quot;Warlock&apos;s Curse&quot;,&quot;verb&quot;:&quot;cursed by&quot;},&quot;DivineChallenge&quot;:{&quot;range&quot;:5,&quot;duration&quot;:&quot;Special&quot;,&quot;friendlyName&quot;:&quot;Divine Challenge&quot;,&quot;verb&quot;:&quot;challenged by&quot;},&quot;Natures_Wrath&quot;:{&quot;range&quot;:1,&quot;duration&quot;:&quot;End of Your Next Turn&quot;,&quot;friendlyName&quot;:&quot;Nature&apos;s Wrath&quot;,&quot;verb&quot;:&quot;marked by&quot;},&quot;Oath&quot;:{&quot;range&quot;:10,&quot;duration&quot;:&quot;Special&quot;,&quot;friendlyName&quot;:&quot;Oath of Enmity&quot;,&quot;verb&quot;:&quot;the sworn enemy of&quot;},&quot;Quarry&quot;:{&quot;range&quot;:&quot;nearest&quot;,&quot;duration&quot;:&quot;Special&quot;,&quot;friendlyName&quot;:&quot;Hunter&apos;s Quarry&quot;,&quot;verb&quot;:&quot;quarried by&quot;}}</value>
          <outer-class reference="../../../.."/>
        </net.rptools.CaseInsensitiveHashMap_-KeyValue>
      </entry>
      <entry>
        <string>ongoingdamage</string>
        <net.rptools.CaseInsensitiveHashMap_-KeyValue>
          <key>OngoingDamage</key>
          <outer-class reference="../../../.."/>
        </net.rptools.CaseInsensitiveHashMap_-KeyValue>
      </entry>
      <entry>
        <string>wisdom</string>
        <net.rptools.CaseInsensitiveHashMap_-KeyValue>
          <key>Wisdom</key>
          <outer-class reference="../../../.."/>
        </net.rptools.CaseInsensitiveHashMap_-KeyValue>
      </entry>
      <entry>
        <string>strbonus</string>
        <net.rptools.CaseInsensitiveHashMap_-KeyValue>
          <key>StrBonus</key>
          <outer-class reference="../../../.."/>
        </net.rptools.CaseInsensitiveHashMap_-KeyValue>
      </entry>
      <entry>
        <string>gensavemod</string>
        <net.rptools.CaseInsensitiveHashMap_-KeyValue>
          <key>GenSaveMod</key>
          <outer-class reference="../../../.."/>
        </net.rptools.CaseInsensitiveHashMap_-KeyValue>
      </entry>
      <entry>
        <string>currentdamageinfo</string>
        <net.rptools.CaseInsensitiveHashMap_-KeyValue>
          <key>currentDamageInfo</key>
          <outer-class reference="../../../.."/>
        </net.rptools.CaseInsensitiveHashMap_-KeyValue>
      </entry>
      <entry>
        <string>race</string>
        <net.rptools.CaseInsensitiveHashMap_-KeyValue>
          <key>Race</key>
          <outer-class reference="../../../.."/>
        </net.rptools.CaseInsensitiveHashMap_-KeyValue>
      </entry>
      <entry>
        <string>level</string>
        <net.rptools.CaseInsensitiveHashMap_-KeyValue>
          <key>Level</key>
          <outer-class reference="../../../.."/>
        </net.rptools.CaseInsensitiveHashMap_-KeyValue>
      </entry>
      <entry>
        <string>-------------------|pc core|-------------------</string>
        <net.rptools.CaseInsensitiveHashMap_-KeyValue>
          <key>-------------------|PC CORE|-------------------</key>
          <outer-class reference="../../../.."/>
        </net.rptools.CaseInsensitiveHashMap_-KeyValue>
      </entry>
      <entry>
        <string>description</string>
        <net.rptools.CaseInsensitiveHashMap_-KeyValue>
          <key>Description</key>
          <outer-class reference="../../../.."/>
        </net.rptools.CaseInsensitiveHashMap_-KeyValue>
      </entry>
      <entry>
        <string>bloodied</string>
        <net.rptools.CaseInsensitiveHashMap_-KeyValue>
          <key>Bloodied</key>
          <outer-class reference="../../../.."/>
        </net.rptools.CaseInsensitiveHashMap_-KeyValue>
      </entry>
      <entry>
        <string>passivepercep</string>
        <net.rptools.CaseInsensitiveHashMap_-KeyValue>
          <key>PassivePercep</key>
          <outer-class reference="../../../.."/>
        </net.rptools.CaseInsensitiveHashMap_-KeyValue>
      </entry>
      <entry>
        <string>wisbonus</string>
        <net.rptools.CaseInsensitiveHashMap_-KeyValue>
          <key>WisBonus</key>
          <outer-class reference="../../../.."/>
        </net.rptools.CaseInsensitiveHashMap_-KeyValue>
      </entry>
      <entry>
        <string>class</string>
        <net.rptools.CaseInsensitiveHashMap_-KeyValue>
          <key>Class</key>
          <outer-class reference="../../../.."/>
        </net.rptools.CaseInsensitiveHashMap_-KeyValue>
      </entry>
      <entry>
        <string>resist</string>
        <net.rptools.CaseInsensitiveHashMap_-KeyValue>
          <key>Resist</key>
          <outer-class reference="../../../.."/>
        </net.rptools.CaseInsensitiveHashMap_-KeyValue>
      </entry>
      <entry>
        <string>possibletargets</string>
        <net.rptools.CaseInsensitiveHashMap_-KeyValue>
          <key>possibleTargets</key>
          <value class="string">Orc1, Orc 5, Orc 9, Wolf 2, Mork, Groop, Ogre</value>
          <outer-class reference="../../../.."/>
        </net.rptools.CaseInsensitiveHashMap_-KeyValue>
      </entry>
      <entry>
        <string>deletemacroundo</string>
        <net.rptools.CaseInsensitiveHashMap_-KeyValue>
          <key>DeleteMacroUndo</key>
          <value class="string"></value>
          <outer-class reference="../../../.."/>
        </net.rptools.CaseInsensitiveHashMap_-KeyValue>
      </entry>
      <entry>
        <string>passiveinsight</string>
        <net.rptools.CaseInsensitiveHashMap_-KeyValue>
          <key>PassiveInsight</key>
          <outer-class reference="../../../.."/>
        </net.rptools.CaseInsensitiveHashMap_-KeyValue>
      </entry>
      <entry>
        <string>conbonus</string>
        <net.rptools.CaseInsensitiveHashMap_-KeyValue>
          <key>ConBonus</key>
          <outer-class reference="../../../.."/>
        </net.rptools.CaseInsensitiveHashMap_-KeyValue>
      </entry>
      <entry>
        <string>truemarks</string>
        <net.rptools.CaseInsensitiveHashMap_-KeyValue>
          <key>TrueMarks</key>
          <value class="string">Aegis,BasicMark,CombatChallenge,DivineChallenge,DivineSanction,Natures_Wrath</value>
          <outer-class reference="../../../.."/>
        </net.rptools.CaseInsensitiveHashMap_-KeyValue>
      </entry>
      <entry>
        <string>-------------resist and vulnerability-------------</string>
        <net.rptools.CaseInsensitiveHashMap_-KeyValue>
          <key>-------------RESIST AND VULNERABILITY-------------</key>
          <outer-class reference="../../../.."/>
        </net.rptools.CaseInsensitiveHashMap_-KeyValue>
      </entry>
      <entry>
        <string>constitution</string>
        <net.rptools.CaseInsensitiveHashMap_-KeyValue>
          <key>Constitution</key>
          <outer-class reference="../../../.."/>
        </net.rptools.CaseInsensitiveHashMap_-KeyValue>
      </entry>
      <entry>
        <string>genacmod</string>
        <net.rptools.CaseInsensitiveHashMap_-KeyValue>
          <key>GenACMod</key>
          <outer-class reference="../../../.."/>
        </net.rptools.CaseInsensitiveHashMap_-KeyValue>
      </entry>
      <entry>
        <string>powers</string>
        <net.rptools.CaseInsensitiveHashMap_-KeyValue>
          <key>Powers</key>
          <outer-class reference="../../../.."/>
        </net.rptools.CaseInsensitiveHashMap_-KeyValue>
      </entry>
      <entry>
        <string>hp</string>
        <net.rptools.CaseInsensitiveHashMap_-KeyValue>
          <key>HP</key>
          <outer-class reference="../../../.."/>
        </net.rptools.CaseInsensitiveHashMap_-KeyValue>
      </entry>
      <entry>
        <string>fortitude</string>
        <net.rptools.CaseInsensitiveHashMap_-KeyValue>
          <key>Fortitude</key>
          <outer-class reference="../../../.."/>
        </net.rptools.CaseInsensitiveHashMap_-KeyValue>
      </entry>
      <entry>
        <string>genattmod</string>
        <net.rptools.CaseInsensitiveHashMap_-KeyValue>
          <key>GenAttMod</key>
          <outer-class reference="../../../.."/>
        </net.rptools.CaseInsensitiveHashMap_-KeyValue>
      </entry>
      <entry>
        <string>classfeatures</string>
        <net.rptools.CaseInsensitiveHashMap_-KeyValue>
          <key>ClassFeatures</key>
          <value class="string">{&quot;Aegis&quot;:{&quot;range&quot;:2,&quot;duration&quot;:&quot;Special&quot;,&quot;friendlyName&quot;:&quot;Swordmage Aegis&quot;,&quot;verb&quot;:&quot;marked by&quot;},&quot;BasicMark&quot;:{&quot;range&quot;:&quot;LOS&quot;,&quot;duration&quot;:&quot;End of Your Next Turn&quot;,&quot;friendlyName&quot;:&quot;Basic Mark&quot;,&quot;verb&quot;:&quot;marked by&quot;},&quot;CombatChallenge&quot;:{&quot;range&quot;:1,&quot;duration&quot;:&quot;End of Your Next Turn&quot;,&quot;friendlyName&quot;:&quot;Combat Challenge&quot;,&quot;verb&quot;:&quot;marked by&quot;},&quot;Curse&quot;:{&quot;range&quot;:&quot;nearest&quot;,&quot;duration&quot;:&quot;Special&quot;,&quot;friendlyName&quot;:&quot;Warlock&apos;s Curse&quot;,&quot;verb&quot;:&quot;cursed by&quot;},&quot;DivineChallenge&quot;:{&quot;range&quot;:5,&quot;duration&quot;:&quot;Special&quot;,&quot;friendlyName&quot;:&quot;Divine Challenge&quot;,&quot;verb&quot;:&quot;challenged by&quot;},&quot;Natures_Wrath&quot;:{&quot;range&quot;:1,&quot;duration&quot;:&quot;End of Your Next Turn&quot;,&quot;friendlyName&quot;:&quot;Nature&apos;s Wrath&quot;,&quot;verb&quot;:&quot;marked by&quot;},&quot;Oath&quot;:{&quot;range&quot;:10,&quot;duration&quot;:&quot;Special&quot;,&quot;friendlyName&quot;:&quot;Oath of Enmity&quot;,&quot;verb&quot;:&quot;the sworn enemy of&quot;},&quot;Quarry&quot;:{&quot;range&quot;:&quot;nearest&quot;,&quot;duration&quot;:&quot;Special&quot;,&quot;friendlyName&quot;:&quot;Hunter&apos;s Quarry&quot;,&quot;verb&quot;:&quot;quarried by&quot;}}</value>
          <outer-class reference="../../../.."/>
        </net.rptools.CaseInsensitiveHashMap_-KeyValue>
      </entry>
      <entry>
        <string>surgeperday</string>
        <net.rptools.CaseInsensitiveHashMap_-KeyValue>
          <key>SurgePerDay</key>
          <outer-class reference="../../../.."/>
        </net.rptools.CaseInsensitiveHashMap_-KeyValue>
      </entry>
      <entry>
        <string>miscnotes</string>
        <net.rptools.CaseInsensitiveHashMap_-KeyValue>
          <key>MiscNotes</key>
          <outer-class reference="../../../.."/>
        </net.rptools.CaseInsensitiveHashMap_-KeyValue>
      </entry>
      <entry>
        <string>surgeremaining</string>
        <net.rptools.CaseInsensitiveHashMap_-KeyValue>
          <key>SurgeRemaining</key>
          <outer-class reference="../../../.."/>
        </net.rptools.CaseInsensitiveHashMap_-KeyValue>
      </entry>
      <entry>
        <string>chabonus</string>
        <net.rptools.CaseInsensitiveHashMap_-KeyValue>
          <key>ChaBonus</key>
          <outer-class reference="../../../.."/>
        </net.rptools.CaseInsensitiveHashMap_-KeyValue>
      </entry>
      <entry>
        <string>radjusts</string>
        <net.rptools.CaseInsensitiveHashMap_-KeyValue>
          <key>RAdjusts</key>
          <value class="string">Resist_All,Resist_Acid,Resist_Cold,Resist_Fire,Resist_Force,Resist_Lightning,Resist_Necrotic,Resist_Poison,Resist_Psychic,Resist_Radiant,Resist_Thunder,Resist_Untyped</value>
          <outer-class reference="../../../.."/>
        </net.rptools.CaseInsensitiveHashMap_-KeyValue>
      </entry>
      <entry>
        <string>temphp</string>
        <net.rptools.CaseInsensitiveHashMap_-KeyValue>
          <key>TempHP</key>
          <outer-class reference="../../../.."/>
        </net.rptools.CaseInsensitiveHashMap_-KeyValue>
      </entry>
      <entry>
        <string>pronoun3</string>
        <net.rptools.CaseInsensitiveHashMap_-KeyValue>
          <key>Pronoun3</key>
          <outer-class reference="../../../.."/>
        </net.rptools.CaseInsensitiveHashMap_-KeyValue>
      </entry>
      <entry>
        <string>genothermod</string>
        <net.rptools.CaseInsensitiveHashMap_-KeyValue>
          <key>GenOtherMod</key>
          <outer-class reference="../../../.."/>
        </net.rptools.CaseInsensitiveHashMap_-KeyValue>
      </entry>
      <entry>
        <string>pronoun1</string>
        <net.rptools.CaseInsensitiveHashMap_-KeyValue>
          <key>Pronoun1</key>
          <outer-class reference="../../../.."/>
        </net.rptools.CaseInsensitiveHashMap_-KeyValue>
      </entry>
      <entry>
        <string>pronoun2</string>
        <net.rptools.CaseInsensitiveHashMap_-KeyValue>
          <key>Pronoun2</key>
          <outer-class reference="../../../.."/>
        </net.rptools.CaseInsensitiveHashMap_-KeyValue>
      </entry>
      <entry>
        <string>currentpowerinfo</string>
        <net.rptools.CaseInsensitiveHashMap_-KeyValue>
          <key>currentPowerInfo</key>
          <outer-class reference="../../../.."/>
        </net.rptools.CaseInsensitiveHashMap_-KeyValue>
      </entry>
      <entry>
        <string>defense</string>
        <net.rptools.CaseInsensitiveHashMap_-KeyValue>
          <key>Defense</key>
          <outer-class reference="../../../.."/>
        </net.rptools.CaseInsensitiveHashMap_-KeyValue>
      </entry>
      <entry>
        <string>edcharbshowonce</string>
        <net.rptools.CaseInsensitiveHashMap_-KeyValue>
          <key>edCharBShowOnce</key>
          <value class="string">1</value>
          <outer-class reference="../../../.."/>
        </net.rptools.CaseInsensitiveHashMap_-KeyValue>
      </entry>
      <entry>
        <string>isminion</string>
        <net.rptools.CaseInsensitiveHashMap_-KeyValue>
          <key>IsMinion</key>
          <value class="string">0</value>
          <outer-class reference="../../../.."/>
        </net.rptools.CaseInsensitiveHashMap_-KeyValue>
      </entry>
      <entry>
        <string>speed</string>
        <net.rptools.CaseInsensitiveHashMap_-KeyValue>
          <key>Speed</key>
          <outer-class reference="../../../.."/>
        </net.rptools.CaseInsensitiveHashMap_-KeyValue>
      </entry>
      <entry>
        <string>lasttarget</string>
        <net.rptools.CaseInsensitiveHashMap_-KeyValue>
          <key>LastTarget</key>
          <value class="string"></value>
          <outer-class reference="../../../.."/>
        </net.rptools.CaseInsensitiveHashMap_-KeyValue>
      </entry>
      <entry>
        <string>strength</string>
        <net.rptools.CaseInsensitiveHashMap_-KeyValue>
          <key>Strength</key>
          <outer-class reference="../../../.."/>
        </net.rptools.CaseInsensitiveHashMap_-KeyValue>
      </entry>
      <entry>
        <string>------------------|powers|-------------------</string>
        <net.rptools.CaseInsensitiveHashMap_-KeyValue>
          <key>------------------|Powers|-------------------</key>
          <outer-class reference="../../../.."/>
        </net.rptools.CaseInsensitiveHashMap_-KeyValue>
      </entry>
      <entry>
        <string>displaydefs</string>
        <net.rptools.CaseInsensitiveHashMap_-KeyValue>
          <key>DisplayDefs</key>
          <outer-class reference="../../../.."/>
        </net.rptools.CaseInsensitiveHashMap_-KeyValue>
      </entry>
      <entry>
        <string>gendammod</string>
        <net.rptools.CaseInsensitiveHashMap_-KeyValue>
          <key>GenDamMod</key>
          <outer-class reference="../../../.."/>
        </net.rptools.CaseInsensitiveHashMap_-KeyValue>
      </entry>
      <entry>
        <string>charisma</string>
        <net.rptools.CaseInsensitiveHashMap_-KeyValue>
          <key>Charisma</key>
          <outer-class reference="../../../.."/>
        </net.rptools.CaseInsensitiveHashMap_-KeyValue>
      </entry>
      <entry>
        <string>ac</string>
        <net.rptools.CaseInsensitiveHashMap_-KeyValue>
          <key>AC</key>
          <outer-class reference="../../../.."/>
        </net.rptools.CaseInsensitiveHashMap_-KeyValue>
      </entry>
      <entry>
        <string>showonce</string>
        <net.rptools.CaseInsensitiveHashMap_-KeyValue>
          <key>showOnce</key>
          <value class="string">1</value>
          <outer-class reference="../../../.."/>
        </net.rptools.CaseInsensitiveHashMap_-KeyValue>
      </entry>
      <entry>
        <string>leaderhealing</string>
        <net.rptools.CaseInsensitiveHashMap_-KeyValue>
          <key>LeaderHealing</key>
          <outer-class reference="../../../.."/>
        </net.rptools.CaseInsensitiveHashMap_-KeyValue>
      </entry>
      <entry>
        <string>debugmode</string>
        <net.rptools.CaseInsensitiveHashMap_-KeyValue>
          <key>DEBUGMODE</key>
          <value class="string">0</value>
          <outer-class reference="../../../.."/>
        </net.rptools.CaseInsensitiveHashMap_-KeyValue>
      </entry>
      <entry>
        <string>genrefmod</string>
        <net.rptools.CaseInsensitiveHashMap_-KeyValue>
          <key>GenRefMod</key>
          <outer-class reference="../../../.."/>
        </net.rptools.CaseInsensitiveHashMap_-KeyValue>
      </entry>
    </store>
  </propertyMap>
  <macroPropertiesMap>
    <entry>
      <int>136</int>
      <net.rptools.maptool.model.MacroButtonProperties>
        <saveLocation>Token</saveLocation>
        <index>136</index>
        <colorKey>default</colorKey>
        <hotKey>None</hotKey>
        <command>[h:debugmode=getLibProperty(&quot;DEBUGMODE&quot;)]
[h:debugmacro = getMacroName()]
[h:SelectedEnemy = arg(0)]
[h:FinalDamage = arg(1)]
[h:FinalDamageBreakdown = arg(2)]
[h:FinalCritDamage = arg(3)]
[h:FinalCritDamageBreakdown = arg(4)]
[h:aoe=arg(5)]
[h,if(!json.isEmpty(LastAttackAdjustment)): lastAttMod = json.get(LastAttackAdjustment, &quot;adjustment&quot;); lastAttMod = &quot;null&quot;]

&lt;!--Create Local Variables from Attack Info--&gt;
[h:targList=json.get(currentAttackOptions, &quot;targets&quot;)]
[h:coverInfo=json.get(currentAttackOptions, &quot;coverInfo&quot;)]
[h:caInfo=json.get(currentAttackOptions, &quot;caInfo&quot;)]
[h:miscBonus=json.get(currentAttackOptions, &quot;miscBonus&quot;)]
[h:markPen=json.get(currentAttackOptions, &quot;markPen&quot;)]
[h:miscPen=json.get(currentAttackOptions, &quot;miscPen&quot;)]
[h,if(json.get(currentAttackOptions,&quot;mdb&quot;)==0):mdb = 0; mdb=eval(json.get(currentAttackOptions, &quot;mdb&quot;))]
[h:oath = json.get(currentAttackOptions, &quot;oath&quot;)]
[h:rollTwice = json.get(currentAttackOptions, &quot;rollTwice&quot;)]
[h:tempExpandCrit = json.get(currentAttackOptions, &quot;expandCrit&quot;)]
&lt;!--Get information from the power--&gt;
[h:attackType=json.get(currentPowerInfo, &quot;attackType&quot;)]
[h:indAttack=if(attackType==&quot;melee&quot; || attackType==&quot;ranged&quot;, 1, 0)]
[h:hitEff=json.get(currentPowerInfo, &quot;hitEffect&quot;)]
[h:missEff=json.get(currentPowerInfo, &quot;missEffect&quot;)]
[h:alwaysEff=json.get(currentPowerInfo, &quot;alwaysEffect&quot;)]
[h:powDmg = json.get(currentPowerInfo, &quot;damage&quot;)]
[h:powCritDmg = json.get(currentPowerInfo, &quot;critdamage&quot;)]
[h:against = json.get(currentPowerInfo,&quot;against&quot;)]
[h:pt = json.get(currentPowerInfo, &quot;targets&quot;)]

[h,if(lastAttMod != &quot;null&quot;),CODE:
{
    [if(lastAttMod &gt; 0): miscBonus = miscBonus+lastAttMod; miscBonus=miscBonus]
    [if(lastAttMod &lt; 0): miscPen = miscPen + abs(lastAttMod); miscPen = miscPen]
};{};]

&lt;!--Best of Two Handler--&gt;
[h,if(oath == 1 &amp;&amp; attackType == &quot;melee&quot;):twoRolls=max(1d20,1d20);twoRolls=0]
[h,switch(rollTwice):
case 0:  twoRolls = 0;
case 1:  twoRolls = max(1d20,1d20);
case 2:  twoRolls = min(1d20,1d20);]

[h:rangePen=0]
[h,if(attackType != &quot;area&quot;): rangeFrom = token.name; rangeFrom = token.name+&quot;BurstCenter&quot;]
[h,if(MarkedBy!=&quot;&quot; &amp;&amp; SelectedEnemy != MarkedBy): markPen=2; markPen=0]
[h:targetRange=getDistance(SelectedEnemy,0,rangeFrom,&quot;ONE_ONE_ONE&quot;)]
[h,if(targetRange &gt; json.get(currentPowerInfo, &quot;nominalRange&quot;) &amp;&amp; attackType == &quot;ranged&quot;):rangePen=rangePen+2; rangePen = rangePen]
[h,token(SelectedEnemy): targetDef=getProperty(string(against))]
[h,token(SelectedEnemy): concPen=if(aoe==0 &amp;&amp; state.Concealed==1, 2, 0)]
[h,token(SelectedEnemy): invisPen = if(aoe==0 &amp;&amp; state.Invisible==1, 5, 0)]
[h,token(SelectedEnemy): hiddenPen = if(aoe==0 &amp;&amp; state.TotalConcealment==1,5,0)]
[h,if(twoRolls &gt; 0): d20roll = twoRolls; d20roll = 1d20]
[h,if(json.get(currentPowerInfo,&quot;attack&quot;) == 0):totalAttackBonus = 0; totalAttackBonus = eval(string(json.get(currentPowerInfo, &quot;attack&quot;)))]

[h,if(debugmode):debug(&quot;debugmacro&quot;,&quot;totalAttackBonus&quot;)]
[h:caBonus = if(json.contains(caInfo, SelectedEnemy), json.get(caInfo, SelectedEnemy), 0)]    
[h:attroll=d20roll+totalAttackBonus+caBonus+miscBonus-concPen-invisPen-hiddenPen-markPen-miscPen-rangePen-if(json.contains(coverInfo, SelectedEnemy), json.get(coverInfo, SelectedEnemy), 0)]

[h,if(debugmode):debug(&quot;debugmacro&quot;,&quot;coverInfo&quot;)]
[h,if((attroll &gt;= targetDef || d20roll == 20) &amp;&amp; d20roll != 1): hit=1; hit=0]
[h:AttackBreakdown=d20roll+&quot; (d20)&quot;+ &quot;+ &quot; 
	                     + totalAttackBonus +&quot; (att bonus) &quot; + &quot;+ &quot;
		+ caBonus + &quot; (Combat Advantage) &quot; + &quot;+ &quot;
		+ miscBonus + &quot; (misc bonus) &quot; + &quot;- &quot;
		+ concPen + &quot; (concealment)&quot; + &quot;- &quot;
		+ invisPen + &quot; (invisible)&quot; + &quot;- &quot;
		+ hiddenPen + &quot; (hidden)&quot; + &quot;- &quot;
		+ rangePen + &quot; (range) &quot; + &quot; - &quot;
		+ markPen + &quot; (marked penalty) &quot; + &quot;- &quot;
		+ miscPen + &quot; (misc penalties) &quot; + &quot;- &quot;
		+ if(json.contains(coverInfo, SelectedEnemy), json.get(coverInfo,SelectedEnemy), 0) + &quot; (cover)&quot;]


&lt;!--Power Details--&gt;

[h:powerData=currentPowerInfo]
[h:hitStateList = json.get(powerData, &quot;appStateHit&quot;)]
[h:missStateList = json.get(powerData, &quot;appStateMiss&quot;)]
[h:effStateList = json.get(powerData, &quot;appStateAlways&quot;)]
[h:powerName = json.get(powerData, &quot;powername&quot;)]

   [h:against=json.get(powerData, &quot;against&quot;)]
   [h:damtype=json.get(powerData, &quot;damageType&quot;)]
   [h:damtypeDisplay = &quot;&quot;]
   [h,foreach(dt, damtype),code:
   {
         [if(dt == &quot;untyped&quot;): damtypeDisplay = damtypeDisplay; damtypeDisplay = listAppend(damtypeDisplay, dt)]
   }]
   [h:atktype=json.get(powerData, &quot;attackType&quot;)]
   [h:doesHalfDmg = json.get(powerData, &quot;halfDmgOnMiss&quot;)]
   [h:hitEff=json.get(powerData, &quot;hitEffect&quot;)]
   [h:missEff=json.get(powerData, &quot;missEffect&quot;)]
   [h:alwaysEff=json.get(powerData, &quot;alwaysEffect&quot;)]
   [h:powerExpandedCrit = if(json.contains(powerData, &quot;critLower&quot;), json.get(powerData, &quot;critLower&quot;), 20)]

[h:critRange = min(tempExpandCrit, powerExpandedCrit)]


[IF(hit),CODE:
{
   [h:currentHitInfo = json.set(currentHitInfo, &quot;hit&quot;, &quot;hit&quot;)]
   [h,if(!json.isEmpty(hitStateList)): procStateData = json.set(procStateData, SelectedEnemy, json.set(&quot;{}&quot;, &quot;StateList&quot;, hitStateList, &quot;tokenName&quot;, token.name, &quot;hit&quot;, &quot;hit&quot;));&quot;&quot;]
   [h,if(d20roll&gt;=critRange &amp;&amp; attRoll &gt;= targetDef): crit=&quot;critical!&quot;; crit=&quot;&quot;)]
   [h,if(crit == &quot;critical!&quot;): critcount = 1; critcount = 0]
   [h:weak=state.Weakened+1]
   [h:totalDam=if(crit==&quot;critical!&quot;,FinalCritDamage+mdb,FinalDamage+mdb)/weak]
   [h:dmgBreakdown = if(crit==&quot;critical!&quot;, FinalCritDamageBreakdown+&quot; + &quot;+mdb+&quot; (misc)&quot;, FinalDamageBreakdown+&quot; + &quot;+mdb+&quot; (misc)&quot;)]
  &lt;b&gt;&lt;i&gt;[r:SelectedEnemy]&lt;/i&gt;&lt;/b&gt;
   [if(json.get(powerData, &quot;targets&quot;)!=&quot;targets allies&quot; &amp;&amp; json.get(powerData,&quot;targets&quot;)!= &quot;personal&quot;),CODE:
   {
      ([t(attRoll):AttackBreakdown] vs. [r:against]), [t(totalDam):dmgBreakdown] [r:damtypeDisplay] damage &lt;b&gt;[r:crit]&lt;/b&gt; [r:if(state.Weakened,&quot;(weakened)&quot;,&quot;&quot;)]
      [h:damageInfo=json.set(&quot;{}&quot;, &quot;target&quot;, SelectedEnemy, &quot;damage&quot;, totalDam, &quot;damtype&quot;, damtype, &quot;atktype&quot;, atktype, &quot;doesHalfDmg&quot;, doesHalfDmg, &quot;hit&quot;, &quot;hit&quot;)]
   [h:currentDamageInfo = json.set(currentDamageInfo, SelectedEnemy, damageInfo)]
   [h:procDamage(SelectedEnemy)]
   [h:statsLine = json.append(&quot;[]&quot;,1,1,critcount,1,totaldam,powerName)]
   };
   {};]
   
};
{
   [h,if(json.get(CurrentHitInfo,&quot;hit&quot;) == &quot;hit&quot;): &quot;&quot;; currentHitInfo = json.set(currentHitInfo, &quot;hit&quot;, &quot;miss&quot;)]
   [if(json.get(powerData,&quot;targets&quot;)!=&quot;targets allies&quot; &amp;&amp; json.get(powerData, &quot;targets&quot;) != &quot;personal&quot;),CODE:
   {
   [h,token(SelectedEnemy): targetIsMinion = if(IsMinion, 1, 0)]
    &lt;b&gt;&lt;i&gt;[r:SelectedEnemy]&lt;/i&gt;&lt;/b&gt; :
    &lt;/b&gt;([t(attRoll):AttackBreakdown] vs. [r:against]), [r:if(doesHalfDmg == 1 &amp;&amp; targetIsMinion == 0, &quot;half damage&quot;, &quot;miss&quot;)]
    [h,if(!json.isEmpty(missStateList)): procStateData = json.set(procStateData, SelectedEnemy, json.set(&quot;{}&quot;,&quot;StateList&quot;, missStateList, &quot;tokenName&quot;, token.name, &quot;hit&quot;, &quot;miss&quot;));&quot;&quot;]
    [h:weak = state.Weakened+1]
    [h:totalDam = (FinalDamage + mdb)/weak]
    [h,if(doesHalfDmg==1): damageInfo = json.set(&quot;{}&quot;, &quot;target&quot;, SelectedEnemy, &quot;damage&quot;, totalDam, &quot;damtype&quot;, damtype, &quot;atktype&quot;, atktype, &quot;doesHalfDmg&quot;, doesHalfDmg, &quot;hit&quot;, &quot;miss&quot;)]
    [h,if(doesHalfDmg == 1): currentDamageInfo = json.set(currentDamageInfo, SelectedEnemy, damageInfo)]
    [h,if(doesHalfDmg == 1): tmpDmgAmt = totalDam; tmpDmgAmt = 0]
    [h,if(doesHalfDmg == 1): procDamage(SelectedEnemy)]
    [h:statsLine = json.append(&quot;[]&quot;, 1,0,0,0,tmpDmgAmt,powerName)]
   };
   {
   &lt;b&gt;Target [r:SelectedEnemy]&lt;/b&gt;: &lt;i&gt;[r:SelectedEnemy]&lt;/i&gt;&lt;br&gt;
    };]
};]

[h,if(!json.isEmpty(effStateList)):procStateData = json.set(procStateData, SelectedEnemy, json.set(&quot;{}&quot;,&quot;StateList&quot;, effStateList, &quot;tokenName&quot;, token.name, &quot;hit&quot;, &quot;hit&quot;));&quot;&quot;]

&lt;!-- Stats Processing - how many hits, crits, and damage --&gt;

[h,if(getProperty(&quot;rfw.statCollection&quot;)==1 &amp;&amp; pt != &quot;personal&quot; &amp;&amp; pt != &quot;targets allies&quot;),CODE:
{
[h:attRollIncrement = json.get(statsLine, 0)]
[h:hitIncrement = json.get(statsLine, 1)]
[h:critcount = json.get(statsLine, 2)]
[h:damRollIncrement = json.get(statsLine,3)]
[h:totalDam = json.get(statsLine, 4)]
[h:powername = json.get(statsLine, 5)]

[h,if(json.contains(attStats, powerName)==0 &amp;&amp; pt != &quot;personal&quot; &amp;&amp; pt != &quot;targets allies&quot;), CODE:
	{
	   [h:tmpD20Stats = &quot;{}&quot;]
	   [h:tmpStatsRolls = 0]
	   [h:tmpStatsHits = 0]
	   [h:tmpStatsCrits = 0]
	};
	{
	   [h:tmpD20Stats = json.get(attStats, powerName)]
	   [h:tmpStatsRolls = json.get(tmpD20Stats, &quot;rolls&quot;)]
	   [h:tmpStatsHits = json.get(tmpD20Stats, &quot;hits&quot;)]
	   [h:tmpStatsCrits = json.get(tmpD20Stats,&quot;crits&quot;)]
	};]
	[h:tmpD20Stats = json.set(tmpD20Stats, &quot;rolls&quot;, tmpStatsRolls+attRollIncrement, &quot;hits&quot;, tmpStatsHits+hitIncrement, &quot;crits&quot;, tmpStatsCrits+critcount)]
	[h:attStats = json.set(attStats, powerName, tmpD20Stats))]

	[h,if(json.contains(dmgStats, powername)==0),CODE:
	{
	   [tmpDmgStats = &quot;{}&quot;]
	   [tmpDmgRolls = 0]
	   [tmpDmgTotal = 0]
	};
	{
	[h:tmpDmgStats = json.get(dmgStats, powerName)]
	[h:tmpDmgRolls = json.get(tmpDmgStats, &quot;rolls&quot;)]
	[h:tmpDmgTotal = json.get(tmpDmgStats, &quot;total&quot;)]
	};]
	[h:tmpDmgStats = json.set(tmpDmgStats, &quot;rolls&quot;, tmpDmgRolls+damRollIncrement, &quot;total&quot;, tmpDmgTotal+totalDam)]
	[h:dmgStats = json.set(dmgStats, powerName, tmpDmgStats))]
};{};]

</command>
        <label>Process Attack</label>
        <group>Combat</group>
        <sortby></sortby>
        <autoExecute>true</autoExecute>
        <includeLabel>false</includeLabel>
        <applyToTokens>false</applyToTokens>
        <fontColorKey>black</fontColorKey>
        <fontSize>1.00em</fontSize>
        <minWidth></minWidth>
        <maxWidth></maxWidth>
        <allowPlayerEdits>true</allowPlayerEdits>
        <toolTip></toolTip>
        <commonMacro>false</commonMacro>
        <compareGroup>true</compareGroup>
        <compareSortPrefix>true</compareSortPrefix>
        <compareCommand>true</compareCommand>
        <compareIncludeLabel>true</compareIncludeLabel>
        <compareAutoExecute>true</compareAutoExecute>
        <compareApplyToSelectedTokens>true</compareApplyToSelectedTokens>
      </net.rptools.maptool.model.MacroButtonProperties>
    </entry>
    <entry>
      <int>139</int>
      <net.rptools.maptool.model.MacroButtonProperties>
        <saveLocation>Token</saveLocation>
        <index>139</index>
        <colorKey>default</colorKey>
        <hotKey>None</hotKey>
        <command>[h:powList=json.fields(Powers)]
[h:tokenList = getTokenNames()]
[h:tokenList = listDelete(tokenList, listFind(tokenList, getName()))]

[h: status=input(
   &quot;dest|&quot;+tokenList+&quot;|Destination Token|LIST|SELECT=0 VALUE=STRING&quot;,
   &quot;pname|&quot;+listSort(powList, &quot;a&quot;)+&quot;|Choose Power to Copy to Destination Token|LIST|SELECT=0 VALUE=STRING&quot;,
   &quot;newName|--Name--|Name for the duplicate power?&quot;)]
[h:abort(status)]

[h,if(newName == &quot;--Name--&quot;): newName = pname]

[h:dupePowerInfo = json.get(Powers, pname)]
[h:dupePowerInfo = json.set(dupePowerInfo, &quot;powername&quot;, newName)]

[h:switchToken(dest)]

[h:Powers = json.set(Powers, newName, dupePowerInfo)]
[h:keywords = json.get(dupePowerInfo, &quot;keywords&quot;)]
[h:itemSubString=substring(keywords,0,4)]
[h:pwrLvl = json.get(dupePowerInfo, &quot;pwrLvl&quot;)]


[h,if(itemSubString==&quot;item&quot;),CODE:
{
  [propstring=&quot;color=orange; fontColor=black; group=5. Item; autoExec=true;&quot;]
};
{
[h,switch(json.get(dupePowerInfo,&quot;usage&quot;)):
case &quot;at-will&quot;: propstring=&quot;color=green; fontColor=black; group=1. At-Will; autoExec=true; sortBy=&quot;+pwrLvl; 
case &quot;encounter&quot;:propstring=&quot;color=red; fontColor=white; group=2. Encounter; autoExec=true; sortBy=&quot;+pwrLvl; 
case &quot;daily&quot;: propstring=&quot;color=black; fontColor=white; group=3. Daily; autoExec=true; sortBy=&quot;+pwrLvl; 
case &quot;recharge&quot;: propstring=&quot;color=blue; fontColor=white; group=4. Recharging; autoExec=true; sortBy=&quot;+pwrLvl;
default: propstring=&quot;color=green; fontColor=black; group=1. At-Will; autoExec=true; sortBy=&quot;+pwrLvl;]}]

[h:createMacro(newName, &quot;[macro(&apos;AttackMain@Lib:4e&apos;):&apos;&quot;+newName+&quot;&apos;]&quot;, propstring)]
[h:input(&quot;junk|&quot;+newName+&quot; successfully copied to &quot;+dest+&quot;|-|LABEL|SPAN=TRUE&quot;)]</command>
        <label>CopyPowerToOtherToken</label>
        <group>Power Management</group>
        <sortby></sortby>
        <autoExecute>true</autoExecute>
        <includeLabel>false</includeLabel>
        <applyToTokens>false</applyToTokens>
        <fontColorKey>black</fontColorKey>
        <fontSize>1.00em</fontSize>
        <minWidth></minWidth>
        <maxWidth></maxWidth>
        <allowPlayerEdits>false</allowPlayerEdits>
        <toolTip></toolTip>
        <commonMacro>false</commonMacro>
        <compareGroup>true</compareGroup>
        <compareSortPrefix>true</compareSortPrefix>
        <compareCommand>true</compareCommand>
        <compareIncludeLabel>true</compareIncludeLabel>
        <compareAutoExecute>true</compareAutoExecute>
        <compareApplyToSelectedTokens>true</compareApplyToSelectedTokens>
      </net.rptools.maptool.model.MacroButtonProperties>
    </entry>
    <entry>
      <int>143</int>
      <net.rptools.maptool.model.MacroButtonProperties>
        <saveLocation>Token</saveLocation>
        <index>143</index>
        <colorKey>default</colorKey>
        <hotKey>None</hotKey>
        <command>[h:setInitiativeHold(1)]
[token.name] is delaying their turn. Make sure to end any beneficial effects and sustained powers at this time. Any harmful effects are ended after you &lt;i&gt;act&lt;/i&gt;, and all saving throws are made after you act.
[h:nextInitiative()]</command>
        <label>Delay Turn</label>
        <group>Turns</group>
        <sortby></sortby>
        <autoExecute>true</autoExecute>
        <includeLabel>false</includeLabel>
        <applyToTokens>false</applyToTokens>
        <fontColorKey>black</fontColorKey>
        <fontSize>1.00em</fontSize>
        <minWidth></minWidth>
        <maxWidth></maxWidth>
        <allowPlayerEdits>false</allowPlayerEdits>
        <toolTip></toolTip>
        <commonMacro>false</commonMacro>
        <compareGroup>true</compareGroup>
        <compareSortPrefix>true</compareSortPrefix>
        <compareCommand>true</compareCommand>
        <compareIncludeLabel>true</compareIncludeLabel>
        <compareAutoExecute>true</compareAutoExecute>
        <compareApplyToSelectedTokens>true</compareApplyToSelectedTokens>
      </net.rptools.maptool.model.MacroButtonProperties>
    </entry>
    <entry>
      <int>142</int>
      <net.rptools.maptool.model.MacroButtonProperties>
        <saveLocation>Token</saveLocation>
        <index>142</index>
        <colorKey>default</colorKey>
        <hotKey>None</hotKey>
        <command>
[h:weaponTemplate=json.set(&quot;{}&quot;, &quot;type&quot;, &quot;melee&quot;, &quot;category&quot;, &quot;simple&quot;, &quot;hands&quot;, 1, &quot;proficiency&quot;, 2, &quot;damageDice&quot;, &quot;1d6&quot;, &quot;load&quot;, &quot;n/a&quot;, &quot;level&quot;, 0, &quot;enhancement&quot;, 0, &quot;magicCrit&quot;, &quot;0d6&quot;, &quot;nominalRange&quot;, 1, &quot;maximumRange&quot;, 1, &quot;ammunition&quot;, 0, &quot;groups&quot;, &quot;&quot;, &quot;properties&quot;, &quot;&quot;, &quot;brutal&quot;, &quot;no&quot;, &quot;brutalNum&quot;, 0, &quot;reach&quot;, &quot;no&quot;, &quot;reachDist&quot;, 0)]

[h,if(isPropertyEmpty(&quot;Weapons&quot;) == 1 || json.isEmpty(Weapons)==1),CODE:
{
  [weaponList = &quot;Add New&quot;]
};
{
  [weaponList = listSort(json.fields(Weapons),&quot;A+&quot;)]
  [weaponList = listAppend(weaponList, &quot;Add new&quot;)]
};]

&lt;!--Present an input to select a Weapon to edit--&gt;
[h:status=input(
&quot;whichWeapon|&quot;+weaponList+&quot;|Choose a Weapon to Edit|LIST|SELECT=0 VALUE=STRING&quot;,
&quot;delete|0|Delete this Weapon|CHECK&quot;)]
[h:abort(status)]


&lt;!--Delete the Weapon if the user checks the delete box--&gt;
[h,if(delete == 1),CODE:
{
    [Weapons = json.remove(Weapons, whichWeapon)]
	[if(EquippedMainHand == whichWeapon): EquippedMainHand = &quot;&quot;]
	[if(EquippedOffHand == whichWeapon): EquippedOffHand = &quot;&quot;]
	[assert(0, whichWeapon+&quot; has been deleted.&quot;, 0)]
}]

&lt;!--Generate the variables for the Weapon to auto-populate the Weapon Editing input--&gt;
[h,if(whichWeapon==&quot;Add New&quot;),CODE:
{  
   [selectedWeapon = WeaponTemplate]
   [varsFromJSON(WeaponTemplate)]
};
{
   [selectedWeapon = json.get(Weapons, whichWeapon)]
   [varsFromJSON(selectedWeapon)]
};]

[h:wTypeList = &quot;melee,ranged,both&quot;]
[h:wCatList = &quot;simple,military,superior&quot;]
[h:handList = &quot;one,two,double&quot;]
[h:loadPropList = &quot;n/a,free,minor,move,standard&quot;]
[h:wpnGrpList = &quot;Axe,Bow,Crossbow,Flail,Hammer,HeavyBlade,LightBlade,Mace,Pick,Polearm,Sling,Spear,Staff,Unarmed&quot;]
[h:wpnPropList = &quot;Brutal,Defensive,HeavyThrown,HighCrit,LightThrown,OffHand,Reach,Small,Versatile&quot;]
[h,switch(load):
case &quot;n/a&quot;: loadProp = 0;
case &quot;free&quot;: loadProp = 1;
case &quot;minor&quot;: loadProp = 2;
case &quot;move&quot;: loadProp = 3;
case &quot;standard&quot;: loadProp = 4;]

[h:status=input(
&quot;WeaponBasics|Basic Weapon Info||TAB|SELECT=1&quot;,
&quot;.|&lt;html&gt;Edit &quot;+whichWeapon+&quot;&lt;/b&gt;&lt;/html&gt;||LABEL|SPAN=TRUE&quot;,
&quot;wName|N/A|New weapon name (leave &apos;N/A&apos; to leave it unchanged)&quot;,
&quot;wType|&quot;+wTypeList+&quot;|Weapon Type|LIST|SELECT = &quot;+listFind(wTypeList, type)+&quot; VALUE=STRING&quot;,
&quot;wCat|&quot;+wCatList+&quot;|Weapon Category|LIST|SELECT=&quot;+listFind(wCatList, category)+&quot; VALUE=STRING&quot;,
&quot;wHands|&quot;+handList+&quot;|Handedness|RADIO|SELECT=&quot;+listFind(handList, hands)+&quot; VALUE=STRING&quot;,
&quot;wProf|&quot;+proficiency+&quot;|Weapon Proficiency Bonus&quot;,
&quot;wDamDice|&quot;+damageDice+&quot;|Weapon Damage Dice&quot;,
&quot;wNomRange|&quot;+nominalRange+&quot;|Weapon Nominal Range (leave as 1 for melee)&quot;,
&quot;wMaxRange|&quot;+maximumRange+&quot;|Weapon Maximum Range (leave as 1 for melee)&quot;,
&quot;WeaponGroups|Weapon Groups||TAB&quot;,
&quot;grpAxe|&quot;+if(listFind(groups, &quot;Axe&quot;)!=-1, 1, 0)+&quot;|Axe|CHECK&quot;,
&quot;grpBow|&quot;+if(listFind(groups, &quot;Bow&quot;)!=-1, 1, 0)+&quot;|Bow|CHECK&quot;,
&quot;grpCrossbow|&quot;+if(listFind(groups,&quot;Crossbow&quot;)!=-1,1,0)+&quot;|Crossbow|CHECK&quot;,
&quot;grpFlail|&quot;+if(listFind(groups,&quot;Flail&quot;)!=-1,1,0)+&quot;|Flail|CHECK&quot;,
&quot;grpHammer|&quot;+if(listFind(groups,&quot;Hammer&quot;)!=-1,1,0)+&quot;|Hammer|CHECK&quot;,
&quot;grpHeavyBlade|&quot;+if(listFind(groups,&quot;Heavy Blade&quot;)!=-1,1,0)+&quot;|Heavy Blade|CHECK&quot;,
&quot;grpLightBlade|&quot;+if(listFind(groups,&quot;Light Blade&quot;)!=-1,1,0)+&quot;|Light Blade|CHECK&quot;,
&quot;grpMace|&quot;+if(listFind(groups,&quot;Mace&quot;)!=-1,1,0)+&quot;|Mace|CHECK&quot;,
&quot;grpPick|&quot;+if(listFind(groups,&quot;Pick&quot;)!=-1,1,0)+&quot;|Pick|CHECK&quot;,
&quot;grpPolearm|&quot;+if(listFind(groups,&quot;Polearm&quot;)!=-1,1,0)+&quot;|Polearm|CHECK&quot;,
&quot;grpSpear|&quot;+if(listFind(groups,&quot;Spears&quot;)!=-1,1,0)+&quot;|Spear|CHECK&quot;,
&quot;grpSling|&quot;+if(listFind(groups,&quot;Sling&quot;)!=-1,1,0)+&quot;|Sling|CHECK&quot;,
&quot;grpStaff|&quot;+if(listFind(groups,&quot;Staff&quot;)!=-1,1,0)+&quot;|Staff|CHECK&quot;,
&quot;grpUnarmed|&quot;+if(listFind(groups,&quot;Unarmed&quot;)!=-1,1,0)+&quot;|Unarmed|CHECK&quot;,
&quot;WeaponProps|Weapon Properties||TAB&quot;,
&quot;propBrutal|&quot;+if(listFind(properties,&quot;Brutal&quot;)!=-1,1,0)+&quot;|Brutal|CHECK&quot;,
&quot;brutalLevel|0|If brutal, what is the reroll number?&quot;,
&quot;propDefensive|&quot;+if(listFind(properties,&quot;Defensive&quot;)!=-1,1,0)+&quot;|Defensive|CHECK&quot;,
&quot;propHeavyThrown|&quot;+if(listFind(properties, &quot;Heavy Thrown&quot;)!=-1,1,0)+&quot;|Heavy Thrown|CHECK&quot;,
&quot;propHighCrit|&quot;+if(listFind(properties, &quot;High Crit&quot;)!=-1,1,0)+&quot;|High Crit|CHECK&quot;,
&quot;propLightThrown|&quot;+if(listFind(properties, &quot;Light Thrown&quot;)!=-1,1,0)+&quot;|Light Thrown|CHECK&quot;,
&quot;propLoad|&quot;+loadPropList+&quot;|Load|LIST|SELECT=&quot;+loadProp+&quot; VALUE=STRING&quot;,
&quot;propOffHand|&quot;+if(listFind(properties,&quot;Off-Hand&quot;)!=-1,1,0)+&quot;|Off-hand|CHECK&quot;,
&quot;propReach|&quot;+if(listFind(properties,&quot;Reach&quot;)!=-1,1,0)+&quot;|Reach|CHECK&quot;,
&quot;reachDistance|&quot;+reachDist+&quot;|Reach Distance for reach weapons&quot;,
&quot;propSmall|&quot;+if(listFind(properties,&quot;Small&quot;)!=-1,1,0)+&quot;|Small|CHECK&quot;,
&quot;propVersatile|&quot;+if(listFind(properties,&quot;Versatile&quot;)!=-1,1,0)+&quot;|Versatile|CHECK&quot;,
&quot;MagicStuff|Magical Weapon Info||TAB&quot;,
&quot;wLevel|0|Weapon Level&quot;,
&quot;wEnh|&quot;+enhancement+&quot;|Enhancement Bonus&quot;,
&quot;wMagicCrit|&quot;+magicCrit+&quot;|Magical Critical Damage Bonus&quot;)]

[h:abort(status)]

[h:newPropList = &quot;&quot;]
[h:newGrpList = &quot;&quot;]
[h,foreach(grp, wpnGrpList),CODE:
{
  [if(eval(&quot;grp&quot;+grp) == 1): newGrpList = listAppend(newGrpList,grp)]
  }]

[h,foreach(prop, wpnPropList),CODE:
{
   [if(eval(&quot;prop&quot;+prop) == 1): newPropList = listAppend(newPropList,prop)]
   }]
   
[h:tmpWpn = json.set(&quot;{}&quot;, &quot;type&quot;, wType, &quot;category&quot;, wCat, &quot;hands&quot;, wHands, &quot;proficiency&quot;, wProf, &quot;damageDice&quot;, wDamDice, &quot;nominalRange&quot;, wNomRange, &quot;maximumRange&quot;, wMaxRange, &quot;groups&quot;, newGrpList, &quot;properties&quot;, newPropList, &quot;brutal&quot;, if(propBrutal, &quot;yes&quot;, &quot;no&quot;), &quot;brutalNum&quot;, brutalLevel, &quot;reach&quot;, if(propReach, &quot;yes&quot;, &quot;no&quot;), &quot;reachDist&quot;, reachDistance, &quot;level&quot;, wLevel, &quot;enhancement&quot;, wEnh, &quot;magicCrit&quot;, wMagicCrit)]

[h,if(wName == &quot;N/A&quot;): newName = whichWeapon; newName = wName]

[h:Weapons = json.set(Weapons, newName, tmpWpn)]</command>
        <label>Edit Weapons</label>
        <group>Power Management</group>
        <sortby></sortby>
        <autoExecute>true</autoExecute>
        <includeLabel>false</includeLabel>
        <applyToTokens>false</applyToTokens>
        <fontColorKey>black</fontColorKey>
        <fontSize>1.00em</fontSize>
        <minWidth></minWidth>
        <maxWidth></maxWidth>
        <allowPlayerEdits>false</allowPlayerEdits>
        <toolTip></toolTip>
        <commonMacro>false</commonMacro>
        <compareGroup>true</compareGroup>
        <compareSortPrefix>true</compareSortPrefix>
        <compareCommand>true</compareCommand>
        <compareIncludeLabel>true</compareIncludeLabel>
        <compareAutoExecute>true</compareAutoExecute>
        <compareApplyToSelectedTokens>true</compareApplyToSelectedTokens>
      </net.rptools.maptool.model.MacroButtonProperties>
    </entry>
    <entry>
      <int>129</int>
      <net.rptools.maptool.model.MacroButtonProperties>
        <saveLocation>Token</saveLocation>
        <index>129</index>
        <colorKey>default</colorKey>
        <hotKey>None</hotKey>
        <command>[h:assert(argCount() &gt;= 1, &quot;hasP() requires 1 or 2 arguments&quot;, 0)]
[h:prop = arg(0)]
[h,if(argCount() == 2),CODE:
{
   [id = arg(1)]
   [h:return = hasProperty(prop, id)]
};
{
   [return = hasProperty(prop)]
};]

[r:return]</command>
        <label>hasp</label>
        <group>User-Defined Functions</group>
        <sortby></sortby>
        <autoExecute>true</autoExecute>
        <includeLabel>false</includeLabel>
        <applyToTokens>false</applyToTokens>
        <fontColorKey>black</fontColorKey>
        <fontSize>1.00em</fontSize>
        <minWidth></minWidth>
        <maxWidth></maxWidth>
        <allowPlayerEdits>true</allowPlayerEdits>
        <toolTip></toolTip>
        <commonMacro>false</commonMacro>
        <compareGroup>true</compareGroup>
        <compareSortPrefix>true</compareSortPrefix>
        <compareCommand>true</compareCommand>
        <compareIncludeLabel>true</compareIncludeLabel>
        <compareAutoExecute>true</compareAutoExecute>
        <compareApplyToSelectedTokens>true</compareApplyToSelectedTokens>
      </net.rptools.maptool.model.MacroButtonProperties>
    </entry>
    <entry>
      <int>8</int>
      <net.rptools.maptool.model.MacroButtonProperties>
        <saveLocation>Token</saveLocation>
        <index>8</index>
        <colorKey>default</colorKey>
        <hotKey>None</hotKey>
        <command>[h:debugmode=getLibProperty(&quot;DEBUGMODE&quot;)]
[h:debugmacro = getMacroName()]
[h:power=currentPowerInfo]
[h:pname=json.get(power, &quot;powername&quot;)]
[h:hit=json.get(currentHitInfo, &quot;hit&quot;)]
[h:reliable=json.get(power, &quot;reliable&quot;)]
[h,if(debugmode):debug(&quot;debugmacro&quot;,&quot;pname&quot;,&quot;hit&quot;)]

[h,IF(reliable==1), CODE:
	{
	[h:expendDaily=if(hit==&quot;hit&quot;,&quot;Expended&quot;,&quot;Available&quot;)]
	};
	{
	[h:expendDaily=&quot;Expended&quot;]
	};
]

[h, SWITCH(json.get(power,&quot;usage&quot;)), CODE:
case &quot;daily&quot;:	{
	[h:power=json.set(power,&quot;expended&quot;,expendDaily)]
	[h:Powers=json.set(Powers, pname, power)]
	[h:macProps=if(expendDaily==&quot;Expended&quot;, &quot;color=gray;&quot;, &quot;color=black;&quot;)]
	[h:setMacroProps(pname, macProps)]
	};
		
case &quot;encounter&quot;:{
	[h:power=json.set(power,&quot;expended&quot;, &quot;Expended&quot;)]
	[h:Powers=json.set(Powers, pname, power)]
	[h:setMacroProps(pname, &quot;color=gray;&quot;)]
	};

case &quot;at-will&quot;: {};

case &quot;recharge&quot;:{
    	[h:power=json.set(power, &quot;expended&quot;, &quot;Must recharge&quot;)]
	    [h:Powers=json.set(Powers,pname, power)]
	    [h:setMacroProps(pname, &quot;color=gray;&quot;)]
    	};
]


[h,SWITCH(json.get(power, &quot;action&quot;)):
case &quot;immediate reaction&quot;: state.Immed_Reaction_Used=1;
case &quot;immediate interrupt&quot;: state.Immed_Reaction_Used=2;
default: state.Immed_Reaction_Used=0;]</command>
        <label>Tracker</label>
        <group>Combat</group>
        <sortby></sortby>
        <autoExecute>true</autoExecute>
        <includeLabel>false</includeLabel>
        <applyToTokens>false</applyToTokens>
        <fontColorKey>black</fontColorKey>
        <fontSize>1.00em</fontSize>
        <minWidth></minWidth>
        <maxWidth></maxWidth>
        <allowPlayerEdits>true</allowPlayerEdits>
        <toolTip></toolTip>
        <commonMacro>false</commonMacro>
        <compareGroup>true</compareGroup>
        <compareSortPrefix>true</compareSortPrefix>
        <compareCommand>true</compareCommand>
        <compareIncludeLabel>true</compareIncludeLabel>
        <compareAutoExecute>true</compareAutoExecute>
        <compareApplyToSelectedTokens>true</compareApplyToSelectedTokens>
      </net.rptools.maptool.model.MacroButtonProperties>
    </entry>
    <entry>
      <int>128</int>
      <net.rptools.maptool.model.MacroButtonProperties>
        <saveLocation>Token</saveLocation>
        <index>128</index>
        <colorKey>default</colorKey>
        <hotKey>None</hotKey>
        <command>[h:assert(argCount() &gt;= 1, &quot;getp() requires 1 or 2 arguments&quot;, 0)]
[h:prop = arg(0)]
[h,if(argCount() == 2),CODE:
{
   [id = arg(1)]
   [h:return = getProperty(prop, id)]
};
{
   [return = getProperty(prop)]
};]

[r:return]</command>
        <label>getp</label>
        <group>User-Defined Functions</group>
        <sortby></sortby>
        <autoExecute>true</autoExecute>
        <includeLabel>false</includeLabel>
        <applyToTokens>false</applyToTokens>
        <fontColorKey>black</fontColorKey>
        <fontSize>1.00em</fontSize>
        <minWidth></minWidth>
        <maxWidth></maxWidth>
        <allowPlayerEdits>true</allowPlayerEdits>
        <toolTip></toolTip>
        <commonMacro>false</commonMacro>
        <compareGroup>true</compareGroup>
        <compareSortPrefix>true</compareSortPrefix>
        <compareCommand>true</compareCommand>
        <compareIncludeLabel>true</compareIncludeLabel>
        <compareAutoExecute>true</compareAutoExecute>
        <compareApplyToSelectedTokens>true</compareApplyToSelectedTokens>
      </net.rptools.maptool.model.MacroButtonProperties>
    </entry>
    <entry>
      <int>130</int>
      <net.rptools.maptool.model.MacroButtonProperties>
        <saveLocation>Token</saveLocation>
        <index>130</index>
        <colorKey>default</colorKey>
        <hotKey>None</hotKey>
        <command>[h:assert(argCount() &gt;= 2, &quot;setP() requires 2 or 3 arguments&quot;, 0)]
[h:prop = arg(0)]
[h:val = arg(1)]
[h,if(argCount() == 3),CODE:
{
   [id = arg(2)]
   [h:setProperty(prop, val, id)]
};
{
   [setProperty(prop,val)]
};]</command>
        <label>setp</label>
        <group>User-Defined Functions</group>
        <sortby></sortby>
        <autoExecute>true</autoExecute>
        <includeLabel>false</includeLabel>
        <applyToTokens>false</applyToTokens>
        <fontColorKey>black</fontColorKey>
        <fontSize>1.00em</fontSize>
        <minWidth></minWidth>
        <maxWidth></maxWidth>
        <allowPlayerEdits>true</allowPlayerEdits>
        <toolTip></toolTip>
        <commonMacro>false</commonMacro>
        <compareGroup>true</compareGroup>
        <compareSortPrefix>true</compareSortPrefix>
        <compareCommand>true</compareCommand>
        <compareIncludeLabel>true</compareIncludeLabel>
        <compareAutoExecute>true</compareAutoExecute>
        <compareApplyToSelectedTokens>true</compareApplyToSelectedTokens>
      </net.rptools.maptool.model.MacroButtonProperties>
    </entry>
    <entry>
      <int>12</int>
      <net.rptools.maptool.model.MacroButtonProperties>
        <saveLocation>Token</saveLocation>
        <index>12</index>
        <colorKey>default</colorKey>
        <hotKey>None</hotKey>
        <command>[h:debugmode=getLibProperty(&quot;DEBUGMODE&quot;)]
[h:debugMacro = getMacroName()]
[h:amtHealed = arg(0)]
[h:verb = arg(1)]
[h:source = arg(2)]
[h:bonusHP = arg(3)]
[h,if(debugmode): debug(&quot;verb&quot;, &quot;source&quot;, &quot;bonusHP&quot;)]
[h,if(argCount() &gt; 4),CODE:
{
	[power = arg(4)]
	[target = arg(5)]
};
{
	[power = &quot;&quot;]
	[target = getName()]
};]

[h,switch(source),code:
case &quot;General&quot;:
{
	[h:hptot=min(MaxHP,CurrHP+amtHealed+bonusHP)]
	[output = token.name+&quot; &quot;+verb+&quot; &quot;+amtHealed+&quot; hit points&quot;]
	[h,if(debugmode): debug(&quot;hptot&quot;, &quot;amtHealed&quot;, &quot;target&quot;)]
};
case &quot;Healing Surge&quot;:
{
	&lt;!-- Abort if no healing surges left --&gt;
	[h,IF(SurgeRemaining &lt; 1),CODE:
	{
		[h:input(&quot;.|You are out of Healing Surges.||LABEL|SPAN=TRUE&quot;)]
		[h:abort(0)]
	};{};]
	[h:status0=input(
	&quot;HealBonus|0|Enter any bonus HP to your healing surge&quot;
	)]
	[h:abort(status0)]
	[h,if(CurrHP &lt; 0): CurrHP = 0]
	[h:hptot=min(MaxHP, CurrHP+max(SurgeValue, 0)+HealBonus))]
	[h:SurgeRemaining=SurgeRemaining-1]
	[h:hsBreakdown = SurgeValue + &quot;+&quot; + HealBonus]
	[output = token.name+&quot; spends a Healing Surge and &quot;+verb+&quot; &lt;span bgcolor=&apos;#dcdcdc&apos; title=&apos;&quot;+hsBreakdown+&quot;&apos;&gt;&quot;+(SurgeValue+HealBonus)+&quot;&lt;/span&gt; hit points.&quot;]
};
case &quot;Second Wind&quot;:
{
	[h:hptot=min(MaxHP, CurrHP+max(SurgeValue, 0))]
	[h:SurgeRemaining=SurgeRemaining-1]
	[h:output = token.name+&quot; calls on &lt;i&gt;Second Wind&lt;/i&gt; to &quot;+verb+&quot; &quot;+SurgeValue+&quot; hit points.&quot;]
};
case &quot;Leader&quot;:
{
	[h:hptot=min(MaxHP,(CurrHP+amtHealed+bonusHP))]
	[output = token.name+&quot; &quot;+verb+&quot; &quot;+amtHealed+&quot; hit points from &lt;i&gt;&quot;+power+&quot;&lt;/i&gt;&quot;]
	[if(debugmode): debug(&quot;hptot&quot;, &quot;output&quot;, &quot;target&quot;)]
}; ]


&lt;!--Handle States, Bar, and Miscellany--&gt;

[if(isPC()),CODE:
{
	[h:switchToken(target)]
	[h:CurrHP = hptot]
	[h:bar.Health=CurrHP/MaxHP]
	[h,if(CurrHP &gt; 0),code:
	{
	       [state.Dying = 0]
 	       [ExternalTiming = json.remove(ExternalTiming, &quot;Dying&quot;)]
	};{};]
	[h,if(CurrHP &gt; Bloodied),code:
	{
	       [state.Bloodied = 0]
	       [ExternalTiming = json.remove(ExternalTiming, &quot;Bloodied&quot;)]
	};{};]
	[r:outputTo(&quot;self&quot;, output)]
};
{
	[h:switchToken(target)]
	[h:CurrHP = hptot]
	[h:bar.Health=CurrHP/MaxHP]
	[h,if(CurrHP &gt; 0),code:
	{
	       [state.Dying = 0]
 	       [ExternalTiming = json.remove(ExternalTiming, &quot;Dying&quot;)]
                            [setLayer(&quot;TOKEN&quot;)]
	};{};]
	[h,if(CurrHP &gt; Bloodied),code:
	{
	       [state.Bloodied = 0]
	       [ExternalTiming = json.remove(ExternalTiming, &quot;Bloodied&quot;)]
	};{};]
	[h:outputTo(&quot;gm&quot;, output)]
};]
</command>
        <label>Healing</label>
        <group>Combat - Healing</group>
        <sortby>1</sortby>
        <autoExecute>true</autoExecute>
        <includeLabel>false</includeLabel>
        <applyToTokens>false</applyToTokens>
        <fontColorKey>black</fontColorKey>
        <fontSize>1.00em</fontSize>
        <minWidth></minWidth>
        <maxWidth></maxWidth>
        <allowPlayerEdits>true</allowPlayerEdits>
        <toolTip></toolTip>
        <commonMacro>false</commonMacro>
        <compareGroup>true</compareGroup>
        <compareSortPrefix>true</compareSortPrefix>
        <compareCommand>true</compareCommand>
        <compareIncludeLabel>true</compareIncludeLabel>
        <compareAutoExecute>true</compareAutoExecute>
        <compareApplyToSelectedTokens>true</compareApplyToSelectedTokens>
      </net.rptools.maptool.model.MacroButtonProperties>
    </entry>
    <entry>
      <int>14</int>
      <net.rptools.maptool.model.MacroButtonProperties>
        <saveLocation>Token</saveLocation>
        <index>14</index>
        <colorKey>default</colorKey>
        <hotKey>None</hotKey>
        <command>[h:AC=AC-2]
[h:Fortitude=Fortitude-2]
[h:Reflex=Reflex-2]
[h:Will=Will-2]
[h:state.SecondWindBonus=0]</command>
        <label>Reset Second Wind</label>
        <group>Combat - Healing</group>
        <sortby>6</sortby>
        <autoExecute>true</autoExecute>
        <includeLabel>false</includeLabel>
        <applyToTokens>false</applyToTokens>
        <fontColorKey>black</fontColorKey>
        <fontSize>1.00em</fontSize>
        <minWidth></minWidth>
        <maxWidth></maxWidth>
        <allowPlayerEdits>true</allowPlayerEdits>
        <toolTip></toolTip>
        <commonMacro>false</commonMacro>
        <compareGroup>true</compareGroup>
        <compareSortPrefix>true</compareSortPrefix>
        <compareCommand>true</compareCommand>
        <compareIncludeLabel>true</compareIncludeLabel>
        <compareAutoExecute>true</compareAutoExecute>
        <compareApplyToSelectedTokens>true</compareApplyToSelectedTokens>
      </net.rptools.maptool.model.MacroButtonProperties>
    </entry>
    <entry>
      <int>15</int>
      <net.rptools.maptool.model.MacroButtonProperties>
        <saveLocation>Token</saveLocation>
        <index>15</index>
        <colorKey>default</colorKey>
        <hotKey>None</hotKey>
        <command>[h:debugmode=getLibProperty(&quot;DEBUGMODE&quot;)]
[h:debugmacro=getMacroName()]
[h,if(debugmode): debug(&quot;debugmacro&quot;,&quot;SecondWind&quot;)]
[h,if(json.get(SecondWind,&quot;expended&quot;)==&quot;Expended&quot; || SurgeRemaining&lt;1),CODE:
{
   [h:input(&quot;.|&lt;html&gt;You have already used &lt;i&gt;Second Wind&lt;/i&gt; during this encounter,&lt;/html&gt;||LABEL|SPAN=TRUE&quot;,
                 &quot;.|or you have no healing surges left!||LABEL|SPAN=TRUE&quot;)]
   [h:abort(0)]
};{};]

[h:AC=AC+2]
[h:Fortitude=Fortitude+2]
[h:Reflex=Reflex+2]
[h:Will=Will+2]

&lt;!--Set up the &quot;stateInfo&quot; argument to be passed to procStates(), so we can automatically switch off the Second Wind Bonus when appropriate--&gt;
[h:swStateInfo = json.set(&quot;{}&quot;,&quot;SecondWindBonus&quot;, json.set(&quot;{}&quot;,&quot;imposedBy&quot;, getName(), &quot;expires&quot;, &quot;Beginning of Your Next Turn&quot;))]
[h:swNextLevel = json.set(&quot;{}&quot;, &quot;StateList&quot;, swStateInfo, &quot;tokenName&quot;, getName(), &quot;hit&quot;, &quot;hit&quot;)]
[h:procStateData = json.set(procStateData,getName(),swNextLevel)]
[h:procStates(getName())]

[r:procHealing(0,&quot;regain&quot;,&quot;Second Wind&quot;,0)]



&lt;!--Set &quot;expended&quot; flag on the Second Wind power--&gt;
[h:SecondWind=json.set(SecondWind, &quot;expended&quot;, &quot;Expended&quot;)]</command>
        <label>Second Wind</label>
        <group>Combat - Healing</group>
        <sortby>5</sortby>
        <autoExecute>true</autoExecute>
        <includeLabel>false</includeLabel>
        <applyToTokens>false</applyToTokens>
        <fontColorKey>black</fontColorKey>
        <fontSize>1.00em</fontSize>
        <minWidth></minWidth>
        <maxWidth></maxWidth>
        <allowPlayerEdits>true</allowPlayerEdits>
        <toolTip></toolTip>
        <commonMacro>false</commonMacro>
        <compareGroup>true</compareGroup>
        <compareSortPrefix>true</compareSortPrefix>
        <compareCommand>true</compareCommand>
        <compareIncludeLabel>true</compareIncludeLabel>
        <compareAutoExecute>true</compareAutoExecute>
        <compareApplyToSelectedTokens>true</compareApplyToSelectedTokens>
      </net.rptools.maptool.model.MacroButtonProperties>
    </entry>
    <entry>
      <int>134</int>
      <net.rptools.maptool.model.MacroButtonProperties>
        <saveLocation>Token</saveLocation>
        <index>134</index>
        <colorKey>default</colorKey>
        <hotKey>None</hotKey>
        <command>[h,if(argCount() &gt; 0): who = arg(0); who = getName()]
[h:debugMode = getLibProperty(&quot;DEBUGMODE&quot;)]
[h:debugMacro = getMacroName()]
[h:damageInfo = json.get(currentDamageInfo, who)]
[h:damTypeList=&quot;acid,cold,fire,force,lightning,necrotic,poison,psychic,radiant,thunder,untyped&quot;]
[h:rawDamage=json.get(damageInfo, &quot;damage&quot;)]
[h:damageType=json.get(damageInfo, &quot;damtype&quot;)]
[h:attackType=json.get(damageInfo,&quot;atktype&quot;)]
[h:target=json.get(damageInfo, &quot;target&quot;)]
[h:doesHalfDmg = json.get(damageInfo, &quot;doesHalfDmg&quot;)]
[h:hit = json.get(damageInfo, &quot;hit&quot;)]
[h:tmpCondition = json.set(&quot;{}&quot;, &quot;expires&quot;, &quot;Special&quot;, &quot;imposedBy&quot;,&quot;Special&quot;)]
[h:dtMultArray = &quot;[]&quot;]
[h:switchToken(target)]

[h,if(debugmode):debug(&quot;damageType&quot;,&quot;rawDamage&quot;,&quot;damageInfo&quot;)]

[h:damageType = if(damageType == &quot;&quot;, &quot;untyped&quot;, damageType)]
[h:atkMultiplier=json.get(DamMultiplier,attackType)]
[h,foreach(dt,damageType),CODE:
{
   [thisDtMult = json.get(DamMultiplier, dt)]
   [dtMultArray = json.append(dtMultArray, thisDtMult)]
   [dtMultArray = json.sort(dtMultArray, &quot;d&quot;)]
}]
[h:maxDtMult = number(json.get(dtMultArray, 0))]
[h,if(debugmode):debug(&quot;debugMacro&quot;,&quot;maxDtMult&quot;)]
[h:resistAll=json.get(Resist,&quot;all&quot;)]
[h:canResist = &quot;&quot;]

[h,foreach(dt, damTypeList),CODE:
{
   [if(json.get(Resist, dt) &gt; 0): canResist = listAppend(canResist, dt); canResist=canResist]
}]

[h:dam0 = listGet(damageType,0)]
[h:dam1 = listGet(damageType,1)]
[h:dam2 = listGet(damageType,2)]

[h,if(listContains(canResist,dam0) != -1): resDam0 = 1; resDam0 = 0]
[h,if(listContains(canResist, dam1) != -1): resDam1 = 1; resDam1 = 0]
[h,if(listContains(canResist, dam2) != -1): resDam2 = 1; resDam2 = 0]


[h,if(debugmode):debug(&quot;debugMacro&quot;,&quot;canResist&quot;,&quot;listCount(canResist)&quot;,&quot;listCount(damageType)&quot;)]

[h,if(resDam0 &amp;&amp; resDam1 &amp;&amp; resDam2),CODE:
{
    [resist0 = json.get(Resist, listGet(damageType, 0))]
    [resist1 = json.get(Resist, listGet(damageType, 1))]
    [resist2 = json.get(Resist, listGet(damageType, 2))]    
    [h,if(debugmode):debug(&quot;debugMacro&quot;,&quot;resist0&quot;,&quot;resist1&quot;,&quot;resist2&quot;)]
    [resistType = if(listCount(canResist) &gt; 1, min(resist0, resist1, resist2), max(resist0,resist1,resist2))]
};
{
    [resistType = 0]
};]

[h,if(debugmode):debug(&quot;resistType&quot;)]

[h:vulnAll=json.get(Vulnerable,&quot;all&quot;)]

[h:isVulnerable = &quot;&quot;]

[h,foreach(dt, damTypeList),CODE:
{
   [if(json.get(Vulnerable, dt) &gt; 0): isVulnerable = listAppend(isVulnerable, dt); isVulnerable=isVulnerable]
}]

[h,if(listCount(isVulnerable) &gt; 0),CODE:
{
    [vuln0 = if(listGet(damageType,0) != &quot;&quot;, json.get(Vulnerable, listGet(damageType, 0)), 0)]
    [vuln1 = if(listGet(damageType,1) != &quot;&quot;, json.get(Vulnerable, listGet(damageType, 1)), 0)]
    [vuln2 = if(listGet(damageType,2) != &quot;&quot;, json.get(Vulnerable, listGet(damageType, 2)), 0)]    
    [vulnType = max(vuln0, vuln1, vuln2)]
};
{
    [vulnType = 0]
};]


[h:totalResistance=max(resistAll,resistType)]
[h:totalVulnerability=max(vulnAll,vulnType)]

&lt;!--Take Full Damage and apply resistances, vulnerabilities, and insubstantial--&gt;
[h:dmgCalc1=floor((rawDamage - totalResistance + totalVulnerability) * atkMultiplier * maxDtMult)]

&lt;!--Apply Half Damage on Miss, except to Minions--&gt;
[h,if(doesHalfDmg == 1 &amp;&amp; hit != &quot;nit&quot;):dmgCalc1=floor(dmgCalc1/2); dmgCalc1 = dmgCalc1]
[h,if(doesHalfDmg == 1 &amp;&amp; hit != &quot;hit&quot; &amp;&amp; isMinion): dmgCalc1 = 0]


[h:baseDamage = dmgCalc1]



[if(debugmode):debug(&quot;dmgCalc1&quot;, &quot;isMinion&quot;, &quot;doesHalfDmg&quot;, &quot;hit&quot;)]



[h:dmgValue = max(0, baseDamage)]

[h: DmgToTempHP = if(DmgValue &gt; 0, min(DmgValue, TempHP), 0)]
      [h: DmgToRealHP = DmgValue - DmgToTempHP]
       [h: TempHP = TempHP - DmgToTempHP] 
[h:CurrHP=CurrHP-DmgToRealHP]

[h:targPC=if(isPC(target),1,0)]

[h, IF(targPC), CODE:
	{
	[H: state.Dying = 1 - max(0,min(1,CurrHP))] 
	[H: state.Bloodied = 1 - max(state.Dying, min(1,CurrHP - Bloodied))] 
	[h,if(state.Bloodied == 1): ExternalTiming = json.set(ExternalTiming, &quot;Bloodied&quot;,tmpCondition)]
	[h,if(state.Dying == 1),CODE:
	{
	   [ExternalTiming = json.remove(ExternalTiming, &quot;Bloodied&quot;)]
	   [ExternalTiming = json.set(ExternalTiming, &quot;Dying&quot;, tmpCondition)]
	};{}]
	[h:bar.Health=CurrHP/MaxHP]
	};
	{
	[H: state.Dead = 1 - max(0,min(1,CurrHP))] 
	[H: state.Bloodied = 1 - max(state.Dead, min(1,CurrHP - Bloodied))]
	[h,if(state.Bloodied == 1): ExternalTiming = json.set(ExternalTiming, &quot;Bloodied&quot;,tmpCondition)]
	[h,if(state.Dead == 1),CODE:
	{
	   [ExternalTiming = json.remove(ExternalTiming, &quot;Bloodied&quot;)]
	   [ExternalTiming = json.set(ExternalTiming, &quot;Dead&quot;,tmpCondition)]
	   [setLayer(&quot;BACKGROUND&quot;)]
	   [removeFromInitiative()]
	};{}]
	[h:bar.Health=CurrHP/MaxHP]
	}]


 
 </command>
        <label>Damage</label>
        <group>Combat - Damage</group>
        <sortby></sortby>
        <autoExecute>true</autoExecute>
        <includeLabel>false</includeLabel>
        <applyToTokens>false</applyToTokens>
        <fontColorKey>black</fontColorKey>
        <fontSize>1.00em</fontSize>
        <minWidth></minWidth>
        <maxWidth></maxWidth>
        <allowPlayerEdits>true</allowPlayerEdits>
        <toolTip></toolTip>
        <commonMacro>false</commonMacro>
        <compareGroup>true</compareGroup>
        <compareSortPrefix>true</compareSortPrefix>
        <compareCommand>true</compareCommand>
        <compareIncludeLabel>true</compareIncludeLabel>
        <compareAutoExecute>true</compareAutoExecute>
        <compareApplyToSelectedTokens>true</compareApplyToSelectedTokens>
      </net.rptools.maptool.model.MacroButtonProperties>
    </entry>
    <entry>
      <int>17</int>
      <net.rptools.maptool.model.MacroButtonProperties>
        <saveLocation>Token</saveLocation>
        <index>17</index>
        <colorKey>default</colorKey>
        <hotKey>None</hotKey>
        <command>[h:status=input(
	&quot;newTempHP|0|New Temporary HP Gained&quot;)]
[h:abort(status)]

[h:TempHP=max(TempHP,newTempHP)]
	
[r:getName()] gains [r:newTempHP] temporary hit points.</command>
        <label>Temp HP</label>
        <group>Combat - Healing</group>
        <sortby></sortby>
        <autoExecute>true</autoExecute>
        <includeLabel>false</includeLabel>
        <applyToTokens>false</applyToTokens>
        <fontColorKey>black</fontColorKey>
        <fontSize>1.00em</fontSize>
        <minWidth></minWidth>
        <maxWidth></maxWidth>
        <allowPlayerEdits>true</allowPlayerEdits>
        <toolTip></toolTip>
        <commonMacro>false</commonMacro>
        <compareGroup>true</compareGroup>
        <compareSortPrefix>true</compareSortPrefix>
        <compareCommand>true</compareCommand>
        <compareIncludeLabel>true</compareIncludeLabel>
        <compareAutoExecute>true</compareAutoExecute>
        <compareApplyToSelectedTokens>true</compareApplyToSelectedTokens>
      </net.rptools.maptool.model.MacroButtonProperties>
    </entry>
    <entry>
      <int>18</int>
      <net.rptools.maptool.model.MacroButtonProperties>
        <saveLocation>Token</saveLocation>
        <index>18</index>
        <colorKey>default</colorKey>
        <hotKey>None</hotKey>
        <command>[h:damTypeList=&quot;,acid,cold,fire,force,lightning,necrotic,poison,psychic,radiant,thunder&quot;]

[h,if(hasProperty(&quot;IsMinion&quot;)):&quot;&quot;; setProperty(&quot;IsMinion&quot;, 0)]
[h:saveBonuses = getProperty(&quot;SaveBonusReminders&quot;)]
[h:status=input(
&quot;basicTab|Basic Information||TAB|SELECT=1&quot;,
&quot;.|------------------------------------------------------------------------------------------------------------------------------------------------||LABEL|SPAN=TRUE&quot;,
&quot;.|&lt;html&gt;&lt;b&gt;&lt;u&gt;Basic Info&lt;/u&gt;&lt;/b&gt;&lt;/html&gt;||LABEL|SPAN=TRUE&quot;,
	&quot;token.name|&quot;+token.name+&quot;|&lt;html&gt; &amp;nbsp; Character Name&lt;/html&gt;&quot;,
	&quot;Pronoun1|&quot;+Pronoun1+&quot;|&lt;html&gt; &amp;nbsp; &amp;nbsp; Pronoun 1 (he/she/it)&lt;/html&gt;&quot;,
	&quot;Pronoun2|&quot;+Pronoun2+&quot;|&lt;html&gt; &amp;nbsp; &amp;nbsp; Pronoun 2 (his/her/its)&lt;/html&gt;&quot;,
	&quot;Pronoun3|&quot;+Pronoun3+&quot;|&lt;html&gt; &amp;nbsp; &amp;nbsp; Pronoun 3 (him/her/it)&lt;/html&gt;&quot;,
	&quot;Race|&quot;+Race+&quot;|&lt;html&gt; &amp;nbsp; Character Race&lt;/html&gt;&quot;,	
	&quot;Class|&quot;+Class+&quot;|&lt;html&gt; &amp;nbsp; Character Class&lt;/html&gt;&quot;,
	&quot;IsMinion|&quot;+IsMinion+&quot;|&lt;html&gt;&lt;i&gt; &amp;nbsp; Character is a Minion&lt;/i&gt;&lt;/html&gt;|CHECK&quot;,
	&quot;CharLevel|&quot;+CharLevel+&quot;|&lt;html&gt; &amp;nbsp; Level&lt;/html&gt;&quot;,
	&quot;XP|&quot;+XP+&quot;|&lt;html&gt; &amp;nbsp; XP&lt;/html&gt;&quot;,
	&quot;Speed|&quot;+Speed+&quot;|&lt;html&gt; &amp;nbsp; Character Speed&lt;/html&gt;&quot;,
	&quot;InitBonus|&quot;+InitBonus+&quot;|&lt;html&gt; &amp;nbsp; Initiative Bonus  (Bonus Only, Dex and Half Level are autocalc)&lt;/html&gt;&quot;,
&quot;.|&lt;html&gt;&lt;b&gt;&lt;u&gt;Miscellaneous&lt;/u&gt;&lt;/b&gt;&lt;/html&gt;||LABEL|SPAN=TRUE&quot;,
	&quot;ActionPoints|&quot;+ActionPoints+&quot;|&lt;html&gt; &amp;nbsp; Action Points&lt;/html&gt;&quot;,
	&quot;PassivePercep|&quot;+PassivePercep+&quot;|&lt;html&gt; &amp;nbsp; Passive Perception Score&lt;/html&gt;&quot;,
	&quot;PassiveInsight|&quot;+PassiveInsight+&quot;|&lt;html&gt; &amp;nbsp; Passive Insight Score&lt;/html&gt;&quot;,
	&quot;MiscNotes|--|&lt;html&gt; &amp;nbsp; Miscellaneous notes&lt;/html&gt;&quot;,
&quot;.|&lt;html&gt;&lt;b&gt;&lt;u&gt;Abilities &amp; Stats&lt;/u&gt;&lt;/b&gt;&lt;/html&gt;||LABEL|SPAN=TRUE&quot;,	
	&quot;Strength|&quot;+Strength+&quot;|&lt;html&gt; &amp;nbsp; Strength&lt;/html&gt;&quot;,
	&quot;Constitution|&quot;+Constitution+&quot;|&lt;html&gt; &amp;nbsp; Constitution&lt;/html&gt;&quot;,
	&quot;Dexterity|&quot;+Dexterity+&quot;|&lt;html&gt; &amp;nbsp; Dexterity&lt;/html&gt;&quot;,
	&quot;Intelligence|&quot;+Intelligence+&quot;|&lt;html&gt; &amp;nbsp; Intelligence&lt;/html&gt;&quot;,
	&quot;Wisdom|&quot;+Wisdom+&quot;|&lt;html&gt; &amp;nbsp; Wisdom&lt;/html&gt;&quot;,
	&quot;Charisma|&quot;+Charisma+&quot;|&lt;html&gt; &amp;nbsp; Charisma&lt;/html&gt;&quot;,
&quot;defsTab|Defenses &amp; Healing||TAB&quot;,
&quot;.|------------------------------------------------------------------------------------------------------------------------------------------------||LABEL|SPAN=TRUE&quot;,
&quot;.|&lt;html&gt;&lt;b&gt;&lt;u&gt;HP &amp; Healing&lt;/u&gt;&lt;/b&gt;&lt;/html&gt;||LABEL|SPAN=TRUE&quot;,
	&quot;CurrHP|&quot;+CurrHP+&quot;|&lt;html&gt; &amp;nbsp; Current Hit Points&lt;/html&gt;&quot;,
	&quot;MaxHP|&quot;+MaxHP+&quot;|&lt;html&gt; &amp;nbsp; Maximum Hit Points&lt;/html&gt;&quot;,
	&quot;SurgeValue|&quot;+SurgeValue+&quot;|&lt;html&gt; &amp;nbsp; Healing Surge Value&lt;/html&gt;&quot;,
	&quot;SurgePerDay|&quot;+SurgePerDay+&quot;|&lt;html&gt; &amp;nbsp; Surges Per Day&lt;/html&gt;&quot;,
	&quot;SurgeRemaining|&quot;+SurgeRemaining+&quot;|&lt;html&gt; &amp;nbsp; Surges Remaining&lt;/html&gt;&quot;,
&quot;.|&lt;html&gt;&lt;b&gt;&lt;u&gt;Defenses&lt;/u&gt;&lt;/b&gt;&lt;/html&gt;||LABEL|SPAN=TRUE&quot;,
	&quot;AC|&quot;+AC+&quot;|&lt;html&gt; &amp;nbsp; Armor Class&lt;/html&gt;&quot;,
	&quot;Fortitude|&quot;+Fortitude+&quot;|&lt;html&gt; &amp;nbsp; Fortitude&lt;/html&gt;&quot;,
	&quot;Reflex|&quot;+Reflex+&quot;|&lt;html&gt; &amp;nbsp; Reflex&lt;/html&gt;&quot;,
	&quot;Will|&quot;+Will+&quot;|&lt;html&gt; &amp;nbsp; Will&lt;/html&gt;&quot;,
&quot;.|&lt;html&gt;&lt;b&gt;&lt;u&gt;Saves&lt;/u&gt;&lt;/b&gt;&lt;/html&gt;||LABEL|SPAN=TRUE&quot;,
&quot;.|Enter text description of any save bonuses, e.g. &apos;+5 against Poison&apos; or &apos;+5 vs. Fear effects&apos;||LABEL|SPAN=TRUE&quot;,
&quot;saveMod1|&quot;+json.get(saveBonuses, &quot;mod1&quot;)+&quot;|&lt;html&gt; &amp;nbsp; Save Bonus 1&lt;/html&gt;&quot;,
&quot;saveMod2|&quot;+json.get(saveBonuses, &quot;mod2&quot;)+&quot;|&lt;html&gt; &amp;nbsp; Save Bonus 2&lt;/html&gt;&quot;,
&quot;saveMod3|&quot;+json.get(saveBonuses, &quot;mod3&quot;)+&quot;|&lt;html&gt; &amp;nbsp; Save Bonus 3&lt;/html&gt;&quot;,
&quot;saveMod4|&quot;+json.get(saveBonuses, &quot;mod4&quot;)+&quot;|&lt;html&gt; &amp;nbsp; Save Bonus 4&lt;/html&gt;&quot;,
&quot;saveMod5|&quot;+json.get(saveBonuses, &quot;mod5&quot;)+&quot;|&lt;html&gt; &amp;nbsp; Save Bonus 5&lt;/html&gt;&quot;,
&quot;skillTab|Skills||TAB&quot;,
&quot;.|------------------------------------------------------------------------------------------------------------------------------------------------||LABEL|SPAN=TRUE&quot;,
&quot;.|&lt;html&gt;Enter the &lt;u&gt;total&lt;/u&gt; skill bonus for each skill here.&lt;/html&gt;||LABEL|SPAN=TRUE&quot;,
&quot;newAcrobatics|&quot;+json.get(Skills, &quot;Acrobatics&quot;)+&quot;|Acrobatics&quot;,
&quot;newArcana|&quot;+json.get(Skills,&quot;Arcana&quot;)+&quot;|Arcana&quot;,
&quot;newAthletics|&quot;+json.get(Skills,&quot;Athletics&quot;)+&quot;|Athletics&quot;,
&quot;newBluff|&quot;+json.get(Skills,&quot;Bluff&quot;)+&quot;|Bluff&quot;,
&quot;newDiplomacy|&quot;+json.get(Skills,&quot;Diplomacy&quot;)+&quot;|Diplomacy&quot;,
&quot;newDungeon|&quot;+json.get(Skills,&quot;Dungeoneering&quot;)+&quot;|Dungeoneering&quot;,
&quot;newEndurance|&quot;+json.get(Skills,&quot;Endurance&quot;)+&quot;|Endurance&quot;,
&quot;newHeal|&quot;+json.get(Skills,&quot;Heal&quot;)+&quot;|Heal&quot;,
&quot;newHistory|&quot;+json.get(Skills,&quot;History&quot;)+&quot;|History&quot;,
&quot;newInsight|&quot;+json.get(Skills,&quot;Insight&quot;)+&quot;|Insight&quot;,
&quot;newIntim|&quot;+json.get(Skills,&quot;Intimidate&quot;)+&quot;|Intimidate&quot;,
&quot;newNature|&quot;+json.get(Skills,&quot;Nature&quot;)+&quot;|Nature&quot;,
&quot;newPercep|&quot;+json.get(Skills,&quot;Perception&quot;)+&quot;|Perception&quot;,
&quot;newReligion|&quot;+json.get(Skills,&quot;Religion&quot;)+&quot;|Religion&quot;,
&quot;newStealth|&quot;+json.get(Skills,&quot;Stealth&quot;)+&quot;|Stealth&quot;,
&quot;newStreetwise|&quot;+json.get(Skills,&quot;Streetwise&quot;)+&quot;|Streetwise&quot;,
&quot;newThievery|&quot;+json.get(Skills,&quot;Thievery&quot;)+&quot;|Thievery&quot;,
&quot;resVulTab|Resistance and Vulnerability||TAB&quot;,
&quot;.|&lt;html&gt;&lt;b&gt;Resistance&lt;/b&gt;&lt;/html&gt;||LABEL|SPAN=TRUE&quot;,
&quot;newResAll|&quot;+json.get(Resist, &quot;all&quot;)+&quot;|&lt;html&gt; &amp;nbsp; All Damage&lt;/html&gt;&quot;,
&quot;newResAcid|&quot;+json.get(Resist,&quot;acid&quot;)+&quot;|&lt;html&gt; &amp;nbsp; Acid Damage&lt;/html&gt;&quot;,
&quot;newResCold|&quot;+json.get(Resist,&quot;cold&quot;)+&quot;|&lt;html&gt; &amp;nbsp; Cold Damage&lt;/html&gt;&quot;,
&quot;newResFire|&quot;+json.get(Resist,&quot;fire&quot;)+&quot;|&lt;html&gt; &amp;nbsp; Fire Damage&lt;/html&gt;&quot;,
&quot;newResForce|&quot;+json.get(Resist,&quot;force&quot;)+&quot;|&lt;html&gt; &amp;nbsp; Force Damage&lt;/html&gt;&quot;,
&quot;newResLightning|&quot;+json.get(Resist,&quot;lightning&quot;)+&quot;|&lt;html&gt; &amp;nbsp; Lightning Damage&lt;/html&gt;&quot;,
&quot;newResNecrotic|&quot;+json.get(Resist,&quot;necrotic&quot;)+&quot;|&lt;html&gt; &amp;nbsp; Necrotic Damage&lt;/html&gt;&quot;,
&quot;newResPoison|&quot;+json.get(Resist, &quot;poison&quot;)+&quot;|&lt;html&gt; &amp;nbsp; Poison Damage&lt;/html&gt;&quot;,
&quot;newResPsychic|&quot;+json.get(Resist, &quot;psychic&quot;)+&quot;|&lt;html&gt; &amp;nbsp; Psychic Damage&lt;/html&gt;&quot;,
&quot;newResRadiant|&quot;+json.get(Resist, &quot;radiant&quot;)+&quot;|&lt;html&gt; &amp;nbsp; Radiant Damage&lt;/html&gt;&quot;,
&quot;newResThunder|&quot;+json.get(Resist, &quot;thunder&quot;)+&quot;|&lt;html&gt; &amp;nbsp; Thunder Damage&lt;/html&gt;&quot;,
&quot;newResUntyped|&quot;+if(json.contains(Resist, &quot;untyped&quot;), json.get(Resist, &quot;untyped&quot;), 0)+&quot;|&lt;html&gt; &amp;nbsp; Untyped Damage&lt;/html&gt;&quot;,
&quot;.|&lt;html&gt;&lt;b&gt;Vulnerability&lt;/b&gt;&lt;/html&gt;||LABEL|SPAN=TRUE&quot;,
&quot;newVulnAll|&quot;+json.get(Vulnerable, &quot;all&quot;)+&quot;|&lt;html&gt; &amp;nbsp; All Damage&lt;/html&gt;&quot;,
&quot;newVulnAcid|&quot;+json.get(Vulnerable,&quot;acid&quot;)+&quot;|&lt;html&gt; &amp;nbsp; Acid Damage&lt;/html&gt;&quot;,
&quot;newVulnCold|&quot;+json.get(Vulnerable,&quot;cold&quot;)+&quot;|&lt;html&gt; &amp;nbsp; Cold Damage&lt;/html&gt;&quot;,
&quot;newVulnFire|&quot;+json.get(Vulnerable,&quot;fire&quot;)+&quot;|&lt;html&gt; &amp;nbsp; Fire Damage&lt;/html&gt;&quot;,
&quot;newVulnForce|&quot;+json.get(Vulnerable,&quot;force&quot;)+&quot;|&lt;html&gt; &amp;nbsp; Force Damage&lt;/html&gt;&quot;,
&quot;newVulnLightning|&quot;+json.get(Vulnerable,&quot;lightning&quot;)+&quot;|&lt;html&gt; &amp;nbsp; Lightning Damage&lt;/html&gt;&quot;,
&quot;newVulnNecrotic|&quot;+json.get(Vulnerable,&quot;necrotic&quot;)+&quot;|&lt;html&gt; &amp;nbsp; Necrotic Damage&lt;/html&gt;&quot;,
&quot;newVulnPoison|&quot;+json.get(Vulnerable, &quot;poison&quot;)+&quot;|&lt;html&gt; &amp;nbsp; Poison Damage&lt;/html&gt;&quot;,
&quot;newVulnPsychic|&quot;+json.get(Vulnerable, &quot;psychic&quot;)+&quot;|&lt;html&gt; &amp;nbsp; Psychic Damage&lt;/html&gt;&quot;,
&quot;newVulnRadiant|&quot;+json.get(Vulnerable, &quot;radiant&quot;)+&quot;|&lt;html&gt; &amp;nbsp; Radiant Damage&lt;/html&gt;&quot;,
&quot;newVulnThunder|&quot;+json.get(Vulnerable, &quot;thunder&quot;)+&quot;|&lt;html&gt; &amp;nbsp; Thunder Damage&lt;/html&gt;&quot;,
&quot;newVulnUntyped|&quot;+if(json.contains(Vulnerable, &quot;untyped&quot;), json.get(Vulnerable, &quot;untyped&quot;), 0)+&quot;|&lt;html&gt; &amp;nbsp; Untyped Damage&lt;/html&gt;&quot;,
&quot;multTab|Damage Multipliers||TAB&quot;,
&quot;.|------------------------------------------------------------------------------------------------------------------------------------------------||LABEL|SPAN=TRUE&quot;,
&quot;.|&lt;html&gt;&lt;b&gt;Damage multipliers are used to represent Insubstantiality, Immunity, Swarm resistances, etc.&lt;/b&gt;&lt;/html&gt;||LABEL|SPAN=TRUE&quot;,
&quot;.|For immunity, enter 0. For half damage, enter 0.5. For full damage, enter 1 (the default).||LABEL|SPAN=TRUE&quot;,
&quot;.|&lt;html&gt;&lt;b&gt;Attack Types&lt;/b&gt;&lt;/html&gt;||LABEL|SPAN=TRUE&quot;,
&quot;newMultMelee|&quot;+json.get(DamMultiplier, &quot;melee&quot;)+&quot;|&lt;html&gt; &amp;nbsp; Melee Attacks&lt;/html&gt;&quot;,
&quot;newMultRanged|&quot;+json.get(DamMultiplier, &quot;ranged&quot;)+&quot;|&lt;html&gt; &amp;nbsp; Ranged Attacks&lt;/html&gt;&quot;,
&quot;newMultArea|&quot;+json.get(DamMultiplier, &quot;area&quot;)+&quot;|&lt;html&gt; &amp;nbsp; Area Attacks&lt;/html&gt;&quot;,
&quot;newMultClose|&quot;+json.get(DamMultiplier, &quot;close&quot;)+&quot;|&lt;html&gt; &amp;nbsp; Close Attacks&lt;/html&gt;&quot;,
&quot;.|&lt;html&gt;&lt;b&gt;Damage Types&lt;/b&gt;&lt;/html&gt;||LABEL|SPAN=TRUE&quot;,
&quot;newMultAll|&quot;+json.get(DamMultiplier, &quot;all&quot;)+&quot;|&lt;html&gt; &amp;nbsp; All Damage&lt;/html&gt;&quot;,
&quot;newMultAcid|&quot;+json.get(DamMultiplier,&quot;acid&quot;)+&quot;|&lt;html&gt; &amp;nbsp; Acid Damage&lt;/html&gt;&quot;,
&quot;newMultCold|&quot;+json.get(DamMultiplier,&quot;cold&quot;)+&quot;|&lt;html&gt; &amp;nbsp; Cold Damage&lt;/html&gt;&quot;,
&quot;newMultFire|&quot;+json.get(DamMultiplier,&quot;fire&quot;)+&quot;|&lt;html&gt; &amp;nbsp; Fire Damage&lt;/html&gt;&quot;,
&quot;newMultForce|&quot;+json.get(DamMultiplier,&quot;force&quot;)+&quot;|&lt;html&gt; &amp;nbsp; Force Damage&lt;/html&gt;&quot;,
&quot;newMultLightning|&quot;+json.get(DamMultiplier,&quot;lightning&quot;)+&quot;|&lt;html&gt; &amp;nbsp; Lightning Damage&lt;/html&gt;&quot;,
&quot;newMultNecrotic|&quot;+json.get(DamMultiplier,&quot;necrotic&quot;)+&quot;|&lt;html&gt; &amp;nbsp; Necrotic Damage&lt;/html&gt;&quot;,
&quot;newMultPoison|&quot;+json.get(DamMultiplier, &quot;poison&quot;)+&quot;|&lt;html&gt; &amp;nbsp; Poison Damage&lt;/html&gt;&quot;,
&quot;newMultPsychic|&quot;+json.get(DamMultiplier, &quot;psychic&quot;)+&quot;|&lt;html&gt; &amp;nbsp; Psychic Damage&lt;/html&gt;&quot;,
&quot;newMultRadiant|&quot;+json.get(DamMultiplier, &quot;radiant&quot;)+&quot;|&lt;html&gt; &amp;nbsp; Radiant Damage&lt;/html&gt;&quot;,
&quot;newMultThunder|&quot;+json.get(DamMultiplier, &quot;thunder&quot;)+&quot;|&lt;html&gt; &amp;nbsp; Thunder Damage&lt;/html&gt;&quot;,
&quot;newMultUntyped|&quot;+if(json.contains(DamMultiplier, &quot;untyped&quot;), json.get(DamMultiplier, &quot;untyped&quot;), 1)+&quot;|&lt;html&gt; &amp;nbsp; Untyped Damage&lt;/html&gt;&quot;)]

[h:abort(status)]

[h:modifiedResist = json.set(&quot;{}&quot;, &quot;all&quot;, newResAll, &quot;acid&quot;, newResAcid, &quot;cold&quot;, newResCold, &quot;fire&quot;, newResFire, &quot;force&quot;, newResForce, &quot;lightning&quot;, newResLightning, &quot;necrotic&quot;, newResNecrotic, &quot;poison&quot;, newResPoison, &quot;psychic&quot;, newResPsychic, &quot;radiant&quot;, newResRadiant, &quot;thunder&quot;, newResthunder, &quot;untyped&quot;, newResUntyped)]
[h:Resist = modifiedResist]

[h:modifiedVulnerable = json.set(&quot;{}&quot;, &quot;all&quot;, newVulnAll, &quot;acid&quot;, newVulnAcid, &quot;cold&quot;, newVulnCold, &quot;fire&quot;, newVulnFire, &quot;force&quot;, newVulnForce, &quot;lightning&quot;, newVulnLightning, &quot;necrotic&quot;, newVulnNecrotic, &quot;poison&quot;, newVulnPoison, &quot;psychic&quot;, newVulnPsychic, &quot;radiant&quot;, newVulnRadiant, &quot;thunder&quot;, newVulnthunder, &quot;untyped&quot;, newVulnUntyped)]
[h:Vulnerable = modifiedVulnerable]

[h:modifiedMult = json.set(&quot;{}&quot;, &quot;melee&quot;, newMultMelee, &quot;ranged&quot;, newMultRanged, &quot;area&quot;, newMultArea, &quot;close&quot;, newMultClose, &quot;all&quot;, newMultAll, &quot;acid&quot;, newMultAcid, &quot;cold&quot;, newMultCold, &quot;fire&quot;, newMultFire, &quot;force&quot;, newMultForce, &quot;lightning&quot;, newMultLightning, &quot;necrotic&quot;, newMultNecrotic, &quot;poison&quot;, newMultPoison, &quot;psychic&quot;, newMultPsychic, &quot;radiant&quot;, newMultRadiant, &quot;thunder&quot;, newMultthunder, &quot;untyped&quot;, newMultUntyped)]
[h:DamMultiplier=modifiedMult]

[h:modifiedSkills=json.set(&quot;{}&quot;, &quot;Acrobatics&quot;, newAcrobatics, &quot;Arcana&quot;, newArcana, &quot;Athletics&quot;, newAthletics, &quot;Bluff&quot;, newBluff, &quot;Diplomacy&quot;, newDiplomacy, &quot;Dungeoneering&quot;, newDungeon, &quot;Endurance&quot;, newEndurance, &quot;Heal&quot;, newHeal, &quot;History&quot;, newHistory, &quot;Insight&quot;, newInsight, &quot;Intimidate&quot;, newIntim, &quot;Nature&quot;, newNature, &quot;Perception&quot;, newPercep, &quot;Religion&quot;, newReligion, &quot;Stealth&quot;, newStealth, &quot;Streetwise&quot;, newStreetwise, &quot;Thievery&quot;, newThievery)]
[h:Skills=modifiedSkills]

[h:newSaveMods = json.set(&quot;{}&quot;, &quot;mod1&quot;, saveMod1, &quot;mod2&quot;, saveMod2, &quot;mod3&quot;, saveMod3, &quot;mod4&quot;, saveMod4, &quot;mod5&quot;, saveMod5)]
[h:SaveBonusReminders=newSaveMods]

[h:input(&quot;.|&lt;html&gt;&lt;b&gt;Character Updated&lt;/b&gt;&lt;/html&gt;||LABEL|SPAN=TRUE&quot;)]</command>
        <label>Edit Character</label>
        <group>Character Management</group>
        <sortby></sortby>
        <autoExecute>true</autoExecute>
        <includeLabel>false</includeLabel>
        <applyToTokens>false</applyToTokens>
        <fontColorKey>black</fontColorKey>
        <fontSize>1.00em</fontSize>
        <minWidth></minWidth>
        <maxWidth></maxWidth>
        <allowPlayerEdits>true</allowPlayerEdits>
        <toolTip></toolTip>
        <commonMacro>false</commonMacro>
        <compareGroup>true</compareGroup>
        <compareSortPrefix>true</compareSortPrefix>
        <compareCommand>true</compareCommand>
        <compareIncludeLabel>true</compareIncludeLabel>
        <compareAutoExecute>true</compareAutoExecute>
        <compareApplyToSelectedTokens>true</compareApplyToSelectedTokens>
      </net.rptools.maptool.model.MacroButtonProperties>
    </entry>
    <entry>
      <int>22</int>
      <net.rptools.maptool.model.MacroButtonProperties>
        <saveLocation>Token</saveLocation>
        <index>22</index>
        <colorKey>default</colorKey>
        <hotKey>None</hotKey>
        <command>[dialog(&quot;Power Usage&quot;):
{
   [macro(&quot;Power Use Tracker@this&quot;):&quot;&quot;]
}]
[h:abort(0)]</command>
        <label>Display Power Usage</label>
        <group>Power Management</group>
        <sortby></sortby>
        <autoExecute>true</autoExecute>
        <includeLabel>false</includeLabel>
        <applyToTokens>false</applyToTokens>
        <fontColorKey>black</fontColorKey>
        <fontSize>1.00em</fontSize>
        <minWidth></minWidth>
        <maxWidth></maxWidth>
        <allowPlayerEdits>true</allowPlayerEdits>
        <toolTip></toolTip>
        <commonMacro>false</commonMacro>
        <compareGroup>true</compareGroup>
        <compareSortPrefix>true</compareSortPrefix>
        <compareCommand>true</compareCommand>
        <compareIncludeLabel>true</compareIncludeLabel>
        <compareAutoExecute>true</compareAutoExecute>
        <compareApplyToSelectedTokens>true</compareApplyToSelectedTokens>
      </net.rptools.maptool.model.MacroButtonProperties>
    </entry>
    <entry>
      <int>144</int>
      <net.rptools.maptool.model.MacroButtonProperties>
        <saveLocation>Token</saveLocation>
        <index>144</index>
        <colorKey>default</colorKey>
        <hotKey>None</hotKey>
        <command>[h:powerName=arg(0)]
[h:powerDetail=json.get(Powers,powerName)]

[h,if(json.get(powerDetail,&quot;requirements&quot;) != &quot;&quot; &amp;&amp; json.get(powerDetail,&quot;requirements&quot;) != &quot;--none--&quot;): hasReqs = 1; hasReqs = 0]
[h,if(json.get(powerDetail,&quot;hitEffect&quot;) != &quot;&quot; &amp;&amp; json.get(powerDetail, &quot;hitEffect&quot;) != &quot;--none--&quot;): hasHitEff = 1; hasHitEff=0]
[h,if(json.get(powerDetail,&quot;missEffect&quot;) != &quot;&quot; &amp;&amp; json.get(powerDetail, &quot;missEffect&quot;) != &quot;--none--&quot;): hasMissEff = 1; hasMissEff = 0]
[h,if(json.get(powerDetail,&quot;alwaysEffect&quot;) != &quot;&quot; &amp;&amp; json.get(powerDetail, &quot;alwaysEffect&quot;) != &quot;--none--&quot;): hasAlwaysEff=1; hasAlwaysEff=0]

[h,switch(json.get(powerDetail, &quot;usage&quot;)):
case &quot;at-will&quot;: bgcolor=&quot;#006600&quot;;
case &quot;encounter&quot;: bgcolor=&quot;#990000&quot;;
case &quot;daily&quot;: bgcolor=&quot;#000000&quot;;
case &quot;recharge&quot;:bgcolor=&quot;blue&quot;;]

&lt;html&gt;
&lt;body&gt;
&lt;table bgcolor=&quot;white&quot; width=&quot;100%&quot;&gt;
&lt;tr bgcolor=[r:bgcolor]&gt;
&lt;td color=&quot;white&quot;&gt;&lt;b&gt;[r:json.get(powerDetail, &quot;powername&quot;)]&lt;/b&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;b&gt;Usage&lt;/b&gt;: [r:json.get(powerDetail,&quot;usage&quot;)] [r:if(json.get(powerDetail,&quot;usage&quot;)==&quot;recharge&quot;, json.get(powerDetail,&quot;rechargeOn&quot;), &quot;&quot;)] * &lt;b&gt;Keywords&lt;/b&gt;: [r:json.get(powerDetail, &quot;keywords&quot;)]&lt;/td&gt;
&lt;/tr&gt;
&lt;tr bgcolor=&quot;#cccccc&quot;&gt;
&lt;td&gt; &lt;b&gt;Action&lt;/b&gt;: [r:json.get(powerDetail, &quot;action&quot;)] * &lt;b&gt;Range&lt;/b&gt;: [r:json.get(powerDetail, &quot;rangeText&quot;)]&lt;/td&gt;
&lt;/tr&gt;
[if(hasReqs),CODE:
{
&lt;tr&gt;
&lt;td&gt;&lt;b&gt;Requirements&lt;/b&gt;: [r:json.get(powerDetail, &quot;requirements&quot;)]&lt;/td&gt;
&lt;/tr&gt;
};{};]
&lt;tr&gt;
&lt;td bgcolor=&quot;#cccccc&quot;&gt;&lt;b&gt;Target&lt;/b&gt;: [r:json.get(powerDetail,&quot;targets&quot;)]&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;b&gt;Attack&lt;/b&gt;: +[r:json.get(powerDetail,&quot;attack&quot;)] vs. [r:json.get(powerDetail,&quot;against&quot;)]&lt;/td&gt;
&lt;/tr&gt;
&lt;tr bgcolor=&quot;#cccccc&quot;&gt;
&lt;td&gt;&lt;b&gt;Damage&lt;/b&gt;: [r:json.get(powerDetail, &quot;damage&quot;)] ([r:json.get(powerDetail, &quot;critdamage&quot;)] critical) [r:if(json.contains(powerDetail, &quot;critLower&quot;) &amp;&amp; json.get(powerDetail, &quot;critLower&quot;) != 20, &quot;/ &lt;b&gt;Crit Range&lt;/b&gt;: &quot;+json.get(powerDetail, &quot;critLower&quot;)+&quot;-20&quot;, &quot;&quot;)]&lt;/td&gt;
&lt;/tr&gt;
[if(hasHitEff),CODE:
{
&lt;tr&gt;
&lt;td &gt;&lt;b&gt;Hit&lt;/b&gt;: [r:json.get(powerDetail, &quot;hitEffect&quot;)]&lt;/td&gt;
&lt;/tr&gt;
};{};]
[if(hasMissEff),CODE:
{
&lt;tr bgcolor=&quot;#cccccc&quot;&gt;
&lt;td&gt;&lt;b&gt;Miss&lt;/b&gt;: [r:json.get(powerDetail, &quot;missEffect&quot;)]&lt;/td&gt;
&lt;/tr&gt;
};{};]
[if(hasAlwaysEff),CODE:
{
&lt;tr&gt;
&lt;td&gt;&lt;b&gt;Effect&lt;/b&gt;: [r:json.get(powerDetail, &quot;alwaysEffect&quot;)]&lt;/td&gt;
&lt;/tr&gt;
};{};]
&lt;/table&gt;
&lt;/body&gt;
&lt;/html&gt;</command>
        <label>createTooltip</label>
        <group>User-Defined Functions</group>
        <sortby></sortby>
        <autoExecute>true</autoExecute>
        <includeLabel>false</includeLabel>
        <applyToTokens>false</applyToTokens>
        <fontColorKey>black</fontColorKey>
        <fontSize>1.00em</fontSize>
        <minWidth></minWidth>
        <maxWidth></maxWidth>
        <allowPlayerEdits>false</allowPlayerEdits>
        <toolTip></toolTip>
        <commonMacro>false</commonMacro>
        <compareGroup>true</compareGroup>
        <compareSortPrefix>true</compareSortPrefix>
        <compareCommand>true</compareCommand>
        <compareIncludeLabel>true</compareIncludeLabel>
        <compareAutoExecute>true</compareAutoExecute>
        <compareApplyToSelectedTokens>true</compareApplyToSelectedTokens>
      </net.rptools.maptool.model.MacroButtonProperties>
    </entry>
    <entry>
      <int>145</int>
      <net.rptools.maptool.model.MacroButtonProperties>
        <saveLocation>Token</saveLocation>
        <index>145</index>
        <colorKey>default</colorKey>
        <hotKey>None</hotKey>
        <command>[h:powerTemplate=json.set(&quot;{}&quot;, &quot;powername&quot;, &quot;Enter Name&quot;, &quot;level&quot;, 0, &quot;pCategory&quot;, &quot;Attack&quot;, &quot;keywords&quot;, &quot;none&quot;, &quot;action&quot;, &quot;standard&quot;, &quot;usage&quot;, &quot;at-will&quot;, &quot;attackType&quot;, &quot;melee&quot;, &quot;rangeText&quot;, &quot;melee weapon&quot;, &quot;nominalRange&quot;, 1, &quot;maximumRange&quot;, 1, &quot;reliable&quot;, 0, &quot;spellbook&quot;, 0, &quot;rechargeOn&quot;, 0, &quot;attack&quot;, 0, &quot;against&quot;, &quot;AC&quot;, &quot;targets&quot;, &quot;one creature&quot;, &quot;damage&quot;, 0, &quot;critLower&quot;, 20, &quot;critdamage&quot;, 0, &quot;damageType&quot;, &quot;&quot;, &quot;halfDmgOnMiss&quot;, 0, &quot;requirements&quot;, &quot;--none--&quot;, &quot;hitEffect&quot;, &quot;--none--&quot;, &quot;missEffect&quot;, &quot;--none--&quot;, &quot;alwaysEffect&quot;, &quot;--none--&quot;, &quot;appStateHit&quot;, &quot;{}&quot;, &quot;appStateMiss&quot;, &quot;{}&quot;, &quot;appStateAlways&quot;, &quot;{}&quot;, &quot;expended&quot;, &quot;Available&quot;)]

[h,if(isPropertyEmpty(&quot;Powers&quot;) == 1 || json.isEmpty(Powers)==1),CODE:
{
  [powerList = &quot;Add New&quot;]
  [secondaryList = &quot;No Secondary Attack&quot;]
};
{
  [powerList = listSort(json.fields(Powers),&quot;A+&quot;)]
  [secondaryList = listInsert(powerList, 0, &quot;No Secondary Attack&quot;)]
  [powerList = listAppend(powerList, &quot;Add new&quot;)]
};]

[h:stateList=getTokenStates()]
[h:nonPwrStates = &quot;Immed_Reaction_Used,Curse_Damage_Used,Sneak_Attack_Used,Quarry_Damage_Used,AP_Used&quot;]
[h,foreach(state,nonPwrStates): stateList = listDelete(stateList,listFind(stateList,state))]
[h:stateList=listSort(stateList,&quot;A+&quot;)]
[h:stateList=listInsert(stateList,0,&quot;None&quot;)]
[h:damageTypeList = &quot;untyped, acid, cold, fire, force, lightning, necrotic, poison, psychic, radiant, thunder&quot;]
[h:categoryList = &quot;Attack,Feature,Racial,Utility,Item&quot;]
[h:actionList = &quot;standard,minor,move,free,no action,immediate reaction,immediate interrupt&quot;]
[h:usageList = &quot;at-will,encounter,daily,recharge&quot;]
[h:atkTypeList = &quot;melee,ranged,close,area&quot;]
[h:defList = &quot;AC,Fortitude,Reflex,Will&quot;]
[h:targetOptionList = &quot;one creature, one or two creatures, two creatures, one creature two attacks, each creature in burst, each enemy in burst, targets allies, personal&quot;]
[h:expendList = &quot;Available, Expended, Recharged, Must recharge&quot;]
[h:expireList = &quot;,Beginning of Your Next Turn,End of Your Next Turn,Beginning of Target&apos;s Next Turn,End of Target&apos;s Next Turn,End of Encounter,Save Ends,No Save,Special&quot;]
[h:tempToolTip = &quot;&quot;]

&lt;!--Present an input to select a Power to edit, or to add a new Power--&gt;
[h:status=input(
&quot;whichPower|&quot;+powerList+&quot;|Choose a Power to Edit|LIST|SELECT=0 VALUE=STRING&quot;,
&quot;delete|0|Delete this Power|CHECK&quot;)]
[h:abort(status)]

&lt;!--Delete the Power if the user checks the delete box--&gt;
[if(delete == 1),CODE:
{
    [Powers = json.remove(Powers, whichPower)]
    [macroLabel = whichPower]
    [macIndex = getMacroIndexes(macroLabel)]
    [if(macIndex == &quot;&quot;): assert(0, whichPower+&quot; has been deleted; no macro button to remove.&quot;, 0); removeMacro(macIndex)]
    [assert(0, whichPower+&quot; has been deleted.&quot;, 0)]
};
{};]

&lt;!--Generate the variables for the Power to auto-populate the Power Editing input--&gt;
[h,if(whichPower==&quot;Add New&quot;),CODE:
{  
   [tempToolTip = &quot;&quot;]
   [selectedPower = powerTemplate]
   [varsFromJSON(powerTemplate)]
};
{
   [selectedPower = json.get(Powers, whichPower)]
   [if(json.contains(selectedPower, &quot;spellbook&quot;) == 0): spellbook = 0]
   [if(hasMacro(whichPower)),CODE:
   {
   [macIndex = getMacroIndexes(whichPower)]
   [macroProps = getMacroProps(macIndex, &quot;json&quot;)]
   [if(json.contains(macroProps, &quot;tooltip&quot;)): tempToolTip = json.get(macroProps, &quot;tooltip&quot;)]
   }]

   [varsFromJSON(selectedPower)]
};]

&lt;!--if editing an existing power, find the various power details in the lists established earlier, so you can automatically set them in the editing dialog--&gt;
[h:actionSelect = listFind(actionList, action)]
[h:usageSelect = listFind(usageList, usage)]
[h:againstSelect = listFind(defList, against)]
[h:targSelect = listFind(targetOptionList, targets)]
[h:atktypeSelect = listFind(atkTypeList, attackType)]
[h:expSelect = listFind(expendList, expended)]
[h:catSelect = listFind(categoryList, pCategory)]

[h,switch(usageSelect):
case 0: bgColor = &quot;#006600&quot;;
case 1: bgColor = &quot;#990000&quot;;
case 2: bgColor = &quot;black&quot;;
case 3: bgColor = &quot;blue&quot;;
default: bgColor = &quot;green&quot;;]

&lt;!--To auto-populate the proper damage types, if a power has one or more damage types, cycle through each one listed and find their positions in the damage type list--&gt;
[h,if(damageType != &quot;&quot;),CODE:
{
    [count(3),CODE:
    {
        [damTypeName = listGet(damageType,roll.count)]
        [damListLoc = if(damTypeName != &quot;&quot;, listFind(damageTypeList,damTypeName), 0)]
        [set(&quot;damTypeSelect&quot;+roll.count,damListLoc)]
     }]
};
{
    [count(3): set(&quot;damTypeSelect&quot;+roll.count,0)]
};]

&lt;!--Go through the nested JSON object containing the states to apply, their durations, and their damage amount (if any). A power can impose 4 possible states, so cycle through the loop four times, and locate the proper information to show in the dialog when editing an existing power--&gt;
[h,if(json.isEmpty(appStateHit) == 0),CODE:
{
     [ashList = json.fields(appStateHit)]
     [count(4),CODE:
     {
       [stateName = listGet(ashList, roll.count)]
       [mainListLoc = if(stateName != &quot;&quot;, listFind(stateList, stateName), 0)]
       [set(&quot;hitStateSelect&quot;+roll.count, mainListLoc)]
       [if(stateName != &quot;&quot;): ashDetail = json.get(appStateHit, stateName); ashDetail = &quot;{}&quot;]
       [if(json.isEmpty(ashDetail)==0): expire = json.get(ashDetail, &quot;expires&quot;); expire=&quot; &quot;]
       [if(json.isEmpty(ashDetail)==0): set(&quot;hs&quot;+roll.count+&quot;expire&quot;, listFind(expireList, expire)); set(&quot;hs&quot;+roll.count+&quot;expire&quot;,0)]
       [if(json.isEmpty(ashDetail)==0): set(&quot;hs&quot;+roll.count+&quot;ogd&quot;, json.get(ashDetail,&quot;ogDamAmt&quot;)); set(&quot;hs&quot;+roll.count+&quot;ogd&quot;, 0)]
      }]
};
{
[count(4): set(&quot;hitStateSelect&quot;+roll.count, 0)]
[count(4): set(&quot;hs&quot;+roll.count+&quot;expire&quot;, 0)]
[count(4): set(&quot;hs&quot;+roll.count+&quot;ogd&quot;,0)]
};]

[h,if(json.isEmpty(appStateMiss) == 0),CODE:
{
     [asmList = json.fields(appStateMiss)]
     [count(4),CODE:
   {
       [stateName = listGet(asmList, roll.count)]
       [mainListLoc = if(stateName != &quot;&quot;, listFind(stateList, stateName), 0)]
       [set(&quot;missStateSelect&quot;+roll.count, mainListLoc)]
       [if(stateName != &quot;&quot;): asmDetail = json.get(appStateMiss, stateName); asmDetail = &quot;&quot;]
       [if(json.isEmpty(asmDetail) == 0): set(&quot;ms&quot;+roll.count+&quot;expire&quot;, listFind(expireList, json.get(asmDetail, &quot;expires&quot;))); set(&quot;ms&quot;+roll.count+&quot;expire&quot;,0)]
       [if(json.isEmpty(asmDetail) == 0): set(&quot;ms&quot;+roll.count+&quot;ogd&quot;, json.get(asmDetail,&quot;ogDamAmt&quot;)); set(&quot;ms&quot;+roll.count+&quot;ogd&quot;, 0)]
   }]
};{

[count(4): set(&quot;missStateSelect&quot;+roll.count, 0)]
[count(4): set(&quot;ms&quot;+roll.count+&quot;expire&quot;, 0)]
[count(4): set(&quot;ms&quot;+roll.count+&quot;ogd&quot;,0)]

};]

[h,if(json.isEmpty(appStateAlways) == 0),CODE:
{
     [asaList = json.fields(appStateAlways)]
     [count(4),CODE:
   {
       [stateName = listGet(asaList, roll.count)]
       [mainListLoc = if(stateName != &quot;&quot;, listFind(stateList, stateName), 0)]
       [set(&quot;alwaysStateSelect&quot;+roll.count, mainListLoc)]
       [if(stateName != &quot;&quot;): asaDetail = json.get(appStateAlways, stateName); asaDetail = &quot;&quot;]
       [if(json.isEmpty(asaDetail) == 0): set(&quot;as&quot;+roll.count+&quot;expire&quot;, listFind(expireList, json.get(asaDetail, &quot;expires&quot;))); set(&quot;as&quot;+roll.count+&quot;expire&quot;,0)]
       [if(json.isEmpty(asaDetail) == 0): set(&quot;as&quot;+roll.count+&quot;ogd&quot;, json.get(asaDetail,&quot;ogDamAmt&quot;)); set(&quot;as&quot;+roll.count+&quot;ogd&quot;, 0)]
   }]
};{

[count(4): set(&quot;alwaysStateSelect&quot;+roll.count, 0)]
[count(4): set(&quot;as&quot;+roll.count+&quot;expire&quot;, 0)]
[count(4): set(&quot;as&quot;+roll.count+&quot;ogd&quot;,0)]

};]


&lt;!--Generate the Input Dialog - this is a very long and unwieldy dialog; I&apos;m considering using tabs, but I don&apos;t think they&apos;ll suppor the info right--&gt;

[h:status1=input(
                     	&quot;PowerBasics|Basic Power Info||TAB|SELECT=1&quot;,
	&quot;junk|&lt;html&gt;&lt;h3&gt;&lt;u&gt;&lt;font color=&apos;&quot;+bgColor+&quot;&apos;&gt;&quot;+json.get(selectedPower, &quot;powername&quot;)+&quot;&lt;/font&gt;&lt;/u&gt;&lt;/h3&gt;&lt;/html&gt;|-|LABEL|SPAN=TRUE&quot;,
	&quot;junk|&lt;html&gt;&lt;b&gt;Name, Level, Category&lt;/b&gt;&lt;/html&gt;|-|LABEL|SPAN=TRUE&quot;,
	&quot;newName|N/A|New Power Name (no apostrophes; leave as N/A to keep current name)&quot;,
	&quot;pwrLvl|&quot;+level+&quot;|Power Level&quot;,
	&quot;pwrCategory|&quot;+categoryList+&quot;|Power Category|LIST|SELECT=&quot;+catSelect+&quot; VALUE=STRING&quot;,
	&quot;reqs|&quot;+requirements+&quot;|Special Requirements or Notes&quot;,
	&quot;expend|&quot;+expendList+&quot;|Current Power availability|LIST|SELECT=&quot;+expSelect+&quot; VALUE=STRING&quot;,
	&quot;junk|&lt;html&gt;&lt;b&gt;Usage, Keywords, and Action Information&lt;/b&gt;&lt;/html&gt;|-|LABEL|SPAN=TRUE&quot;,
	&quot;usetype|&quot;+usageList+&quot;|Usage|LIST|SELECT=&quot;+usageSelect+&quot; VALUE=STRING&quot;,
	&quot;rechargeOn|&quot;+rechargeOn+&quot;|For recharge powers, enter recharge values (example: 4,5,6). Leave blank for other power types&quot;,
	&quot;keywords|&quot;+keywords+&quot;|Power Keywords (optional)&quot;,
	&quot;reliable|&quot;+reliable+&quot;|Check here if Power is Reliable|CHECK|&quot;,
                     &quot;spellbook|&quot;+spellbook+&quot;|Power is currently in Spellbook|CHECK|&quot;,
	&quot;acttype|&quot;+actionList+&quot;|Action Type|LIST|SELECT=&quot;+actionSelect+&quot; VALUE=STRING&quot;,
	&quot;atktype|&quot;+atkTypeList+&quot;|Attack Type|LIST|SELECT=&quot;+atktypeSelect+&quot; VALUE=STRING&quot;,
	&quot;junk|&lt;html&gt;&lt;b&gt;Range&lt;b&gt;&lt;/html&gt;|-|LABEL|SPAN=TRUE&quot;,
	&quot;rangeText|&quot;+rangeText+&quot;|Range descriptive text (e.g. &apos;ranged 20/40&apos; or &apos;close burst 3&apos;)&quot;,
	&quot;nomRange|&quot;+nominalRange+&quot;|Normal range of power (in squares, e.g. &apos;20&apos;)&quot;,
	&quot;maxRange|&quot;+maximumRange+&quot;|Maximum range of power / weapon (in squares, e.g. &apos;40&apos;)&quot;,
	&quot;junk|&lt;html&gt;&lt;b&gt;Attack Bonus, Targeted Defense, and Number of Targets&lt;/b&gt;&lt;/html&gt;|-|LABEL|SPAN=TRUE&quot;,	
	&quot;targs|&quot;+targetOptionList+&quot;|Targets|LIST|SELECT=&quot;+targSelect+&quot; VALUE=STRING&quot;,
	&quot;attbonus|&quot;+ attack+&quot;|Attack Bonus (including enhancement bonuses, etc.)&quot;,
	&quot;againstdef|&quot;+defList+&quot;|Defense targeted by attack|LIST|SELECT=&quot;+againstSelect+&quot; VALUE=STRING&quot;,
	&quot;HitCondSettings|Hit||TAB&quot;,
	&quot;junk|&lt;html&gt;&lt;b&gt;Damage Information&lt;/b&gt;&lt;/html&gt;|-|LABEL|SPAN=TRUE&quot;,
	&quot;damstring|&quot;+damage+&quot;|Total power damage expression (include all bonuses*)&quot;,
	&quot;critdamage|&quot;+critdamage+&quot;|Critical damage (if bonus critical dice, enter as dice expression, e.g. 1d6+15 or 15+1d6&quot;,
	&quot;critLower|&quot;+if(critLower != 0, critLower, 20)+&quot;|If expanded critical range, enter lower boundary here&quot;,
	&quot;damtype1|&quot;+damageTypeList+&quot;|First Damage Type|LIST|SELECT=&quot;+damTypeSelect0+&quot; VALUE=STRING&quot;,
	&quot;damtype2|&quot;+damageTypeList+&quot;|Second Damage Type|LIST|SELECT=&quot;+damTypeSelect1+&quot; VALUE=STRING&quot;,
	&quot;damtype3|&quot;+damageTypeList+&quot;|Third Damage Type|LIST|SELECT=&quot;+damTypeSelect2+&quot; VALUE=STRING&quot;,
	&quot;junk|&lt;html&gt;&lt;b&gt;Hit Description&lt;/b&gt;&lt;/html&gt;|JUNK|LABEL|SPAN=TRUE&quot;,
	&quot;hit|&quot;+hitEffect+&quot;|Hit text&quot;,
	&quot;junk|&lt;html&gt;&lt;b&gt;Apply the following conditions/effects&lt;/b&gt;&lt;/html&gt;|JUNK|LABEL|SPAN=TRUE&quot;,
	&quot;appStateHit0|&quot;+stateList+&quot;|&lt;html&gt;&lt;b&gt;First condition&lt;/b&gt;&lt;/html&gt;|LIST|SELECT=&quot;+hitStateSelect0+&quot; VALUE=STRING&quot;,
                     &quot;hitState0Expires|&quot;+expireList+&quot;|&lt;html&gt; &amp;middot; First condition expires&lt;/html&gt;|LIST|SELECT=&quot;+hs0expire+&quot; VALUE=STRING&quot;,
	&quot;hitState0Ongoing|&quot;+hs0ogd+&quot;|&lt;html&gt; &amp;middot; Ongoing Damage / Resist or Vulnerable / Regeneration amount (if applicable)&lt;/html&gt;&quot;,
	&quot;appStateHit1|&quot;+stateList+&quot;|&lt;html&gt;&lt;b&gt;Second condition&lt;/b&gt;&lt;/html&gt;|LIST|SELECT=&quot;+hitStateSelect1+&quot; VALUE=STRING&quot;,
                     &quot;hitState1Expires|&quot;+expireList+&quot;|&lt;html&gt; &amp;middot; Second condition expires&lt;/html&gt;|LIST|SELECT=&quot;+hs1expire+&quot; VALUE=STRING&quot;,
	&quot;hitState1Ongoing|&quot;+hs1ogd+&quot;|&lt;html&gt; &amp;middot; Ongoing Damage / Resist or Vulnerable / Regeneration amount (if applicable)&lt;/html&gt;&quot;,
	&quot;appStateHit2|&quot;+stateList+&quot;|&lt;html&gt;&lt;b&gt;Third condition&lt;/b&gt;&lt;/html&gt;|LIST|SELECT=&quot;+hitStateSelect2+&quot; VALUE=STRING&quot;,
                     &quot;hitState2Expires|&quot;+expireList+&quot;|&lt;html&gt; &amp;middot; Third condition expires&lt;/html&gt;|LIST|SELECT=&quot;+hs2expire+&quot; VALUE=STRING&quot;,
	&quot;hitState2Ongoing|&quot;+hs2ogd+&quot;|&lt;html&gt; &amp;middot; Ongoing Damage / Resist or Vulnerable / Regeneration amount (if applicable)&lt;/html&gt;&quot;,
	&quot;appStateHit3|&quot;+stateList+&quot;|&lt;html&gt;&lt;b&gt;Fourth condition&lt;/b&gt;&lt;/html&gt;|LIST|SELECT=&quot;+hitStateSelect3+&quot; VALUE=STRING&quot;,
                     &quot;hitState3Expires|&quot;+expireList+&quot;|&lt;html&gt; &amp;middot; Fourth condition expires&lt;/html&gt;|LIST|SELECT=&quot;+hs3expire+&quot; VALUE=STRING&quot;,
	&quot;hitState3Ongoing|&quot;+hs3ogd+&quot;|&lt;html&gt; &amp;middot; Ongoing Damage / Resist or Vulnerable / Regeneration amount (if applicable)&lt;/html&gt;&quot;,
	&quot;.|&lt;html&gt; &amp;nbsp; *&lt;i&gt;For weapons with the &lt;b&gt;Brutal&lt;/b&gt; property, write the damage dice in the format XdYrN (where &apos;r&apos; is the weapon&apos;s Brutal value + 1)&lt;/i&gt;&lt;/html&gt;||LABEL|SPAN=TRUE&quot;,
	&quot;.|&lt;html&gt; &amp;nbsp; &lt;i&gt;For example, a 1d6 Brutal 2 weapon would be written here as &apos;1d6r3&apos;.&lt;/i&gt;&lt;/html&gt;||LABEL|SPAN=TRUE&quot;,
	&quot;MissCondSettings|Miss||TAB&quot;,
	&quot;halfDmgOnMiss|&quot;+halfDmgOnMiss+&quot;|Half damage on a miss|CHECK&quot;,
	&quot;junk|&lt;html&gt;&lt;b&gt;Miss Description and Conditions&lt;/b&gt;&lt;/html&gt;|JUNK|LABEL|SPAN=TRUE&quot;,
	&quot;miss|&quot;+missEffect+&quot;|Miss text&quot;,
	&quot;junk|&lt;html&gt;&lt;b&gt;Apply the following conditions/effects&lt;/b&gt;&lt;/html&gt;|JUNK|LABEL|SPAN=TRUE&quot;,
	&quot;appStateMiss0|&quot;+stateList+&quot;|&lt;html&gt;&lt;b&gt;First condition&lt;/b&gt;&lt;/html&gt;|LIST|SELECT=&quot;+missStateSelect0+&quot; VALUE=STRING&quot;,
                     &quot;missState0Expires|&quot;+expireList+&quot;|&lt;html&gt; &amp;middot; First condition expires&lt;/html&gt;|LIST|SELECT=&quot;+ms0expire+&quot; VALUE=STRING&quot;,
	&quot;missState0Ongoing|&quot;+ms0ogd+&quot;|&lt;html&gt; &amp;middot; Ongoing Damage / Resist or Vulnerable / Regeneration amount (if applicable)&lt;/html&gt;&quot;,
	&quot;appStateMiss1|&quot;+stateList+&quot;|&lt;html&gt;&lt;b&gt;Second condition&lt;/b&gt;&lt;/html&gt;|LIST|SELECT=&quot;+missStateSelect1+&quot; VALUE=STRING&quot;,
                     &quot;missState1Expires|&quot;+expireList+&quot;|&lt;html&gt; &amp;middot; Second condition expires&lt;/html&gt;|LIST|SELECT=&quot;+ms1expire+&quot; VALUE=STRING&quot;,
	&quot;missState1Ongoing|&quot;+ms1ogd+&quot;|&lt;html&gt; &amp;middot; Ongoing Damage / Resist or Vulnerable / Regeneration amount (if applicable)&lt;/html&gt;&quot;,
	&quot;EffCondSettings|Effect||TAB&quot;,
	&quot;junk|&lt;html&gt;&lt;b&gt;Effect Description and Conditions&lt;/b&gt;&lt;/html&gt;|JUNK|LABEL|SPAN=TRUE&quot;,
	&quot;eff|&quot;+alwaysEffect+&quot;|Effect text&quot;,
	&quot;junk|&lt;html&gt;&lt;b&gt;Apply the following conditions/effects&lt;/b&gt;&lt;/html&gt;|Junk|LABEL|SPAN=TRUE&quot;,
	&quot;appStateAlways0|&quot;+stateList+&quot;|&lt;html&gt;&lt;b&gt;First condition&lt;/b&gt;&lt;/html&gt;|LIST|SELECT=&quot;+alwaysStateSelect0+&quot; VALUE=STRING&quot;,
                     &quot;alwState0Expires|&quot;+expireList+&quot;|&lt;html&gt; &amp;middot; First condition expires&lt;/html&gt;|LIST|SELECT=&quot;+as0expire+&quot; VALUE=STRING&quot;,
	&quot;alwState0Ongoing|&quot;+as0ogd+&quot;|&lt;html&gt; &amp;middot; Ongoing Damage / Resist or Vulnerable / Regeneration amount (if applicable)&lt;/html&gt;&quot;,
	&quot;appStateAlways1|&quot;+stateList+&quot;|&lt;html&gt;&lt;b&gt;Second condition&lt;/b&gt;&lt;/html&gt;|LIST|SELECT=&quot;+alwaysStateSelect1+&quot; VALUE=STRING&quot;,
                     &quot;alwState1Expires|&quot;+expireList+&quot;|&lt;html&gt; &amp;middot; Second condition expires&lt;/html&gt;|LIST|SELECT=&quot;+as1expire+&quot; VALUE=STRING&quot;,
	&quot;alwState1Ongoing|&quot;+as1ogd+&quot;|&lt;html&gt; &amp;middot; Ongoing Damage / Resist or Vulnerable / Regeneration amount (if applicable)&lt;/html&gt;&quot;
)]

[h:abort(status1)]

&lt;!--If one or more damage types is selected, append them to a list--&gt;
[h:damtype=&quot;&quot;]
[h,if(damtype1 != &quot;&quot;): damtype = listAppend(damtype, damtype1)]
[h,if(damtype2 != &quot;&quot;): damtype = listAppend(damtype, damtype2)]
[h,if(damtype3 != &quot;&quot;): damtype = listAppend(damtype, damtype3)]

&lt;!--If one or more states is selected (for hit, miss, or effect), construct the JSON object that will contain the name of the state, the expiration time, and, if ongoing damage, the amount of damage to apply every round--&gt;
[h:appStateHit = &quot;{}&quot;]
[h,if(appStateHit0 != &quot;None&quot;),CODE:
{
   [h:ash0obj = json.set(&quot;{}&quot;, &quot;expires&quot;, hitState0Expires, &quot;ogDamAmt&quot;, hitState0Ongoing)]
   [h: appStateHit = json.set(appStateHit, appStateHit0, ash0obj)]
};{}]
[h,if(appStateHit1 != &quot;None&quot;),CODE:
{
   [h:ash1obj = json.set(&quot;{}&quot;, &quot;expires&quot;,hitState1Expires, &quot;ogDamAmt&quot;, hitState1Ongoing)]
   [h: appStateHit = json.set(appStateHit, appStateHit1, ash1obj)]
};{};]
[h,if(appStateHit2 != &quot;None&quot;),CODE:
{
    [h:ash2obj = json.set(&quot;{}&quot;, &quot;expires&quot;,hitState2Expires, &quot;ogDamAmt&quot;, hitState2Ongoing)]
   [h: appStateHit = json.set(appStateHit, appStateHit2, ash2obj)]
};{};]
[h,if(appStateHit3 != &quot;None&quot;),CODE:
{
 [ h:ash3obj = json.set(&quot;{}&quot;, &quot;expires&quot;,hitState3Expires, &quot;ogDamAmt&quot;, hitState3Ongoing)]
   [h: appStateHit = json.set(appStateHit, appStateHit3, ash3obj)]
};{};]

[h:appStateMiss = &quot;{}&quot;]
[h,if(appStateMiss1 != &quot;None&quot;),CODE:
{
    [h:asm1obj = json.set(&quot;{}&quot;, &quot;expires&quot;,missState1Expires, &quot;ogDamAmt&quot;, missState1Ongoing)]
    [h: appStateMiss = json.set(appStateMiss, appStateMiss1, asm1obj)]
};{};]
[h,if(appStateMiss0 != &quot;None&quot;),CODE:
{
    [h:asm0obj = json.set(&quot;{}&quot;, &quot;expires&quot;, missState0Expires, &quot;ogDamAmt&quot;, missState0Ongoing)]
    [h: appStateMiss = json.set(appStateMiss, appStateMiss0, asm0obj)]
};{};]

[h:appStateAlways = &quot;&quot;]
[h,if(appStateAlways1 != &quot;None&quot;),CODE:
{
    [h:alw1obj = json.set(&quot;{}&quot;, &quot;expires&quot;, alwState1Expires, &quot;ogDamAmt&quot;, alwState1Ongoing)]
    [h:appStateAlways = json.set(appStateAlways, appStateAlways1, alw1obj)]
};{};]
[h,if(appStateAlways0 != &quot;None&quot;),CODE:
{
    [h:alw0obj = json.set(&quot;{}&quot;, &quot;expires&quot;, alwState0Expires, &quot;ogDamAmt&quot;, alwState0Ongoing)]
    [h:appStateAlways = json.set(appStateAlways, appStateAlways0, alw0obj)]
};{};]

&lt;!--If a new name is selected for the power, assign it to the variable &quot;modifiedName&quot;--&gt;

[h,if(newName != &quot;N/A&quot;): modifiedName =  newName; modifiedName = json.get(selectedPower, &quot;powername&quot;)]

&lt;!--Remove the power from the JSON - this prevents duplication, and is irrelevant for new powers--&gt;
[h:Powers = json.remove(Powers, json.get(selectedPower, &quot;powername&quot;))]

&lt;!--Build a large, temporary JSON object to hold the power details--&gt;
[h:modifiedPower = json.set(&quot;{}&quot;, &quot;powername&quot;, modifiedName, &quot;level&quot;, pwrLvl, &quot;pCategory&quot;, pwrCategory, &quot;keywords&quot;, keywords, &quot;action&quot;, acttype, &quot;usage&quot;, usetype, &quot;attackType&quot;, atktype, &quot;rangeText&quot;, rangeText, &quot;nominalRange&quot;, nomRange, &quot;maximumRange&quot;,maxRange, &quot;reliable&quot;, reliable, &quot;spellbook&quot;, spellbook, &quot;rechargeOn&quot;, rechargeOn, &quot;attack&quot;, attbonus, &quot;against&quot;, againstdef, &quot;targets&quot;, targs, &quot;damage&quot;, damstring, &quot;critLower&quot;, critLower, &quot;critdamage&quot;, critdamage, &quot;damageType&quot;, damtype, &quot;halfDmgOnMiss&quot;, halfDmgOnMiss, &quot;requirements&quot;, reqs, &quot;hitEffect&quot;, hit, &quot;missEffect&quot;, miss, &quot;alwaysEffect&quot;, eff, &quot;appStateHit&quot;, appStateHit, &quot;appStateMiss&quot;, appStateMiss, &quot;appStateAlways&quot;, appStateAlways, &quot;expended&quot;, expend)]

&lt;!--Update the Powers property by setting the temporary JSON object, above, as the nested object corresponding to the new power name--&gt;
[h:Powers=json.set(Powers, json.get(modifiedPower, &quot;powername&quot;), modifiedPower)]

&lt;!-- Begin tooltip generation --&gt;
&lt;!--Determine a few things about the power - effects, requirements, etc.--&gt;
[h,if(usetype == &quot;recharge&quot;): rechargeInfo = rechargeOn; rechargeInfo = &quot;&quot;]
[h,if(critLower &lt; 20): critInfo = &quot;&lt;b&gt;Crit Range&lt;/b&gt;: &quot;+critLower+&quot;-20&quot;; critInfo = &quot;&quot;]
[h,if(reqs != &quot;&quot; &amp;&amp; requirements != &quot;--none--&quot;): hasReqs = 1; hasReqs = 0]
[h,if(hit != &quot;&quot; &amp;&amp; hitEffect != &quot;--none--&quot;): hasHitEff = 1; hasHitEff=0]
[h,if(miss != &quot;&quot; &amp;&amp; missEffect != &quot;--none--&quot;): hasMissEff = 1; hasMissEff = 0]
[h,if(eff != &quot;&quot; &amp;&amp; alwaysEffect != &quot;--none--&quot;): hasAlwaysEff=1; hasAlwaysEff=0]

[h,switch(usetype):
case &quot;at-will&quot;: bgcolor=&quot;#006600&quot;;
case &quot;encounter&quot;: bgcolor=&quot;#990000&quot;;
case &quot;daily&quot;: bgcolor=&quot;#000000&quot;;
case &quot;recharge&quot;:bgcolor=&quot;blue&quot;;]
}]


&lt;!--Create Table Template--&gt;
[h:powerCardTemplate = &quot;&lt;html&gt;&lt;body&gt;&lt;table&gt;&lt;tr&gt;&lt;td&gt;&lt;b&gt;%{modifiedName}&lt;/b&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;b&gt;Usage&lt;/b&gt;: %{usetype} %{rechargeInfo} * &lt;b&gt;Keywords&lt;/b&gt;: %{keywords}&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt; &lt;b&gt;Action&lt;/b&gt;: %{acttype} * &lt;b&gt;Range&lt;/b&gt;: %{rangeText}&lt;/td&gt;&lt;/tr&gt;&quot;]

&lt;!--If there are requirements, show them, otherwise, show nothing--&gt;
[h,if(hasReqs):powerCardTemplate = concat(powerCardTemplate,&quot;&lt;tr&gt;&lt;td&gt;&lt;b&gt;Requirements&lt;/b&gt;: %{reqs}&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&quot;)]

[h:powerCardTemplate = concat(powerCardTemplate, &quot;&lt;td&gt;&lt;b&gt;Target&lt;/b&gt;: %{targs}&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;b&gt;Attack&lt;/b&gt;: +%{attbonus} vs. %{againstdef}&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;b&gt;Damage&lt;/b&gt;: %{damstring} (%{critdamage} critical) %{critInfo}&lt;/td&gt;&lt;/tr&gt;&quot;)]

&lt;!--If there are effects, show them, otherwise, show nothing--&gt;
[h,if(hasHitEff): powerCardTemplate = concat(powerCardTemplate, &quot;&lt;tr&gt;&lt;td &gt;&lt;b&gt;Hit&lt;/b&gt;: %{hit}&lt;/td&gt;&lt;/tr&gt;&quot;)]
[h,if(hasMissEff): powerCardTemplate = concat(powerCardTemplate, &quot;&lt;tr&gt;&lt;td&gt;&lt;b&gt;Miss&lt;/b&gt;: %{miss}&lt;/td&gt;&lt;/tr&gt;&quot;)]
[h,if(hasAlwaysEff): powerCardTemplate = concat(powerCardTemplate, &quot;&lt;tr&gt;&lt;td&gt;&lt;b&gt;Effect&lt;/b&gt;: %{eff}&lt;/td&gt;&lt;/tr&gt;&quot;)]

&lt;!--Close all tags--&gt;
[h:powerCardTemplate = concat(powerCardTemplate, &quot;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt;&quot;)]

[h:generatedTooltip = strformat(powerCardTemplate)]

&lt;!-- end tooltip generation --&gt;

&lt;!--If we are adding a new power, or updating an existing power to a new name, build and/or replace the existing macro buttons--&gt;
[h,if(whichPower == &quot;Add New&quot;),CODE:
{
     [h:powname=newName]
     [h,if(spellbook == 1),CODE:
     {
        [switch(usetype):
        case &quot;at-will&quot;: btnColor = &quot;green&quot;;
        case &quot;encounter&quot;: btnColor = &quot;red&quot;;
        case &quot;daily&quot;: btnColor = &quot;black&quot;;
        case &quot;recharge&quot;: btnColor = &quot;blue&quot;;]
        [if(usetype == &quot;at-will&quot;): fntColor = &quot;black&quot;; fntColor=&quot;white&quot;]
        [propstring=&quot;color=&quot;+btnColor+&quot;; fontColor=&quot;+fntColor+&quot;; group=5. Spellbook; autoExec=true;&quot;]
        [h:macCommand = &apos; [macro(&quot;AttackMain@Lib:4e&quot;):&quot;&apos;+powname+&apos;&quot;] &apos; ]
        [h:createMacro(powname, macCommand, propstring)]
        [h:setMacroProps(powname, &quot;tooltip=&quot;+generatedTooltip)]
      }; 
     {
     [h,switch(usetype):
      case &quot;at-will&quot;: propstring=&quot;color=green; fontColor=black; group=1. At-Will; autoExec=true; sortBy=&quot;+pwrLvl; 
      case &quot;encounter&quot;:propstring=&quot;color=red; fontColor=white; group=2. Encounter; autoExec=true; sortBy=&quot;+pwrLvl; 
      case &quot;daily&quot;: propstring=&quot;color=black; fontColor=white; group=3. Daily; autoExec=true; sortBy=&quot;+pwrLvl; 
      case &quot;recharge&quot;: propstring=&quot;color=blue; fontColor=white; group=4. Recharging; autoExec=true; sortBy=&quot;+pwrLvl;
      default: propstring=&quot;color=green; fontColor=black; group=1. At-Will; autoExec=true; sortBy=&quot;+pwrLvl;]

       [h:macCommand = &apos; [macro(&quot;AttackMain@Lib:4e&quot;):&quot;&apos;+powname+&apos;&quot;] &apos; ]
        [h:createMacro(powname, macCommand, propstring)]
        [h:setMacroProps(powname, &quot;tooltip=&quot;+generatedToolTip)]
     };]
     
};
{
  [h,if(newName != &quot;N/A&quot;): powname= newName; powName = whichPower]
  [h:macIndex = getMacroIndexes(whichPower)]
  [h,if(macIndex != &quot;&quot;):removeMacro(macIndex)]
  [h:bookList = &quot;daily,Utility&quot;]
  [h,if(spellbook == 1),CODE:
     {
        [switch(usetype):
        case &quot;at-will&quot;: btnColor = &quot;green&quot;;
        case &quot;encounter&quot;: btnColor = &quot;red&quot;;
        case &quot;daily&quot;: btnColor = &quot;black&quot;;
        case &quot;recharge&quot;: btnColor = &quot;blue&quot;;]
        [if(usetype == &quot;at-will&quot;): fntColor = &quot;black&quot;; fntColor=&quot;white&quot;]
        [propstring=&quot;color=&quot;+btnColor+&quot;; fontColor=&quot;+fntColor+&quot;; group=5. Spellbook; autoExec=true;&quot;]

        [h:macCommand = &apos; [macro(&quot;AttackMain@Lib:4e&quot;):&quot;&apos;+powname+&apos;&quot;] &apos; ]
        [h:createMacro(powname, macCommand, propstring)]
        [h:setMacroProps(powname, &quot;tooltip=&quot;+generatedToolTip)]
      }; 
     {
     [h,switch(usetype):
      case &quot;at-will&quot;: propstring=&quot;color=green; fontColor=black; group=1. At-Will; autoExec=true; sortBy=&quot;+pwrLvl; 
      case &quot;encounter&quot;:propstring=&quot;color=red; fontColor=white; group=2. Encounter; autoExec=true; sortBy=&quot;+pwrLvl; 
      case &quot;daily&quot;: propstring=&quot;color=black; fontColor=white; group=3. Daily; autoExec=true; sortBy=&quot;+pwrLvl; 
      case &quot;recharge&quot;: propstring=&quot;color=blue; fontColor=white; group=4. Recharging; autoExec=true; sortBy=&quot;+pwrLvl;
      default: propstring=&quot;color=green; fontColor=black; group=1. At-Will; autoExec=true; sortBy=&quot;+pwrLvl;]

      [h:macCommand = &apos; [macro(&quot;AttackMain@Lib:4e&quot;):&quot;&apos;+powname+&apos;&quot;] &apos; ]
        [h:createMacro(powname, macCommand, propstring)]
        [h:setMacroProps(powname, &quot;tooltip=&quot;+generatedToolTip)]
     };]
};]

&lt;!--Confirm the operation is complete--&gt;
[h:input(&quot;.|&quot;+if(newName != &quot;N/A&quot;, newName, whichPower)+&quot; added/updated||LABEL|SPAN=TRUE&quot;)]

</command>
        <label>Edit Powers</label>
        <group>Power Management</group>
        <sortby></sortby>
        <autoExecute>true</autoExecute>
        <includeLabel>false</includeLabel>
        <applyToTokens>false</applyToTokens>
        <fontColorKey>black</fontColorKey>
        <fontSize>1.00em</fontSize>
        <minWidth></minWidth>
        <maxWidth></maxWidth>
        <allowPlayerEdits>true</allowPlayerEdits>
        <toolTip></toolTip>
        <commonMacro>false</commonMacro>
        <compareGroup>true</compareGroup>
        <compareSortPrefix>true</compareSortPrefix>
        <compareCommand>true</compareCommand>
        <compareIncludeLabel>true</compareIncludeLabel>
        <compareAutoExecute>true</compareAutoExecute>
        <compareApplyToSelectedTokens>true</compareApplyToSelectedTokens>
      </net.rptools.maptool.model.MacroButtonProperties>
    </entry>
    <entry>
      <int>27</int>
      <net.rptools.maptool.model.MacroButtonProperties>
        <saveLocation>Token</saveLocation>
        <index>27</index>
        <colorKey>default</colorKey>
        <hotKey>None</hotKey>
        <command>[h:powerName=macro.args]
[h:powerDetail=json.get(Powers,powerName)]
[h:itemSubString=substring(json.get(powerDetail,&quot;keywords&quot;),0,4)]

[h,if(json.get(powerDetail,&quot;requirements&quot;) != &quot;&quot; &amp;&amp; json.get(powerDetail,&quot;requirements&quot;) != &quot;--none--&quot;): hasReqs = 1; hasReqs = 0]
[h,if(json.get(powerDetail,&quot;hitEffect&quot;) != &quot;&quot; &amp;&amp; json.get(powerDetail, &quot;hitEffect&quot;) != &quot;--none--&quot;): hasHitEff = 1; hasHitEff=0]
[h,if(json.get(powerDetail,&quot;missEffect&quot;) != &quot;&quot; &amp;&amp; json.get(powerDetail, &quot;missEffect&quot;) != &quot;--none--&quot;): hasMissEff = 1; hasMissEff = 0]
[h,if(json.get(powerDetail,&quot;alwaysEffect&quot;) != &quot;&quot; &amp;&amp; json.get(powerDetail, &quot;alwaysEffect&quot;) != &quot;--none--&quot;): hasAlwaysEff=1; hasAlwaysEff=0]

[h,if(itemSubString==&quot;item&quot;),CODE:
{
    [bgcolor=&quot;#ff6600&quot;]
};
{
[h,switch(json.get(powerDetail, &quot;usage&quot;)):
case &quot;at-will&quot;: bgcolor=&quot;#006600&quot;;
case &quot;encounter&quot;: bgcolor=&quot;#990000&quot;;
case &quot;daily&quot;: bgcolor=&quot;#000000&quot;;
case &quot;recharge&quot;:bgcolor=&quot;blue&quot;;]}]

&lt;table bgcolor=&quot;white&quot; width=&quot;100%&quot;&gt;
&lt;tr bgcolor=[r:bgcolor]&gt;
&lt;td color=&quot;white&quot;&gt;&lt;b&gt;[r:json.get(powerDetail, &quot;powername&quot;)]&lt;/b&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;b&gt;Usage&lt;/b&gt;: [r:json.get(powerDetail,&quot;usage&quot;)] [r:if(json.get(powerDetail,&quot;usage&quot;)==&quot;recharge&quot;, json.get(powerDetail,&quot;rechargeOn&quot;), &quot;&quot;)] &amp;#10022; &lt;b&gt;Keywords&lt;/b&gt;: [r:json.get(powerDetail, &quot;keywords&quot;)]&lt;/td&gt;
&lt;/tr&gt;
&lt;tr bgcolor=&quot;#cccccc&quot;&gt;
&lt;td&gt; &lt;b&gt;Action&lt;/b&gt;: [r:json.get(powerDetail, &quot;action&quot;)] * &lt;b&gt;Range&lt;/b&gt;: [r:json.get(powerDetail, &quot;rangeText&quot;)]&lt;/td&gt;
&lt;/tr&gt;
[if(hasReqs),CODE:
{
&lt;tr&gt;
&lt;td&gt;&lt;b&gt;Requirements&lt;/b&gt;: [r:json.get(powerDetail, &quot;requirements&quot;)]&lt;/td&gt;
&lt;/tr&gt;
};{};]
&lt;tr&gt;
&lt;td bgcolor=&quot;#cccccc&quot;&gt;&lt;b&gt;Target&lt;/b&gt;: [r:json.get(powerDetail,&quot;targets&quot;)]&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;b&gt;Attack&lt;/b&gt;: +[r:json.get(powerDetail,&quot;attack&quot;)] vs. [r:json.get(powerDetail,&quot;against&quot;)]&lt;/td&gt;
&lt;/tr&gt;
&lt;tr bgcolor=&quot;#cccccc&quot;&gt;
&lt;td&gt;&lt;b&gt;Damage&lt;/b&gt;: [r:json.get(powerDetail, &quot;damage&quot;)] ([r:json.get(powerDetail, &quot;critdamage&quot;)] critical) [r:if(json.contains(powerDetail, &quot;critLower&quot;) &amp;&amp; json.get(powerDetail, &quot;critLower&quot;) != 20, &quot;/ &lt;b&gt;Crit Range&lt;/b&gt;: &quot;+json.get(powerDetail, &quot;critLower&quot;)+&quot;-20&quot;, &quot;&quot;)]&lt;/td&gt;
&lt;/tr&gt;
[if(hasHitEff),CODE:
{
&lt;tr&gt;
&lt;td &gt;&lt;b&gt;Hit&lt;/b&gt;: [r:json.get(powerDetail, &quot;hitEffect&quot;)]&lt;/td&gt;
&lt;/tr&gt;
};{};]
[if(hasMissEff),CODE:
{
&lt;tr bgcolor=&quot;#cccccc&quot;&gt;
&lt;td&gt;&lt;b&gt;Miss&lt;/b&gt;: [r:json.get(powerDetail, &quot;missEffect&quot;)]&lt;/td&gt;
&lt;/tr&gt;
};{};]
[if(hasAlwaysEff),CODE:
{
&lt;tr&gt;
&lt;td&gt;&lt;b&gt;Effect&lt;/b&gt;: [r:json.get(powerDetail, &quot;alwaysEffect&quot;)]&lt;/td&gt;
&lt;/tr&gt;
};{};]
&lt;/table&gt;</command>
        <label>Generate Power Card</label>
        <group>Character Sheet &amp; Power Cards</group>
        <sortby></sortby>
        <autoExecute>true</autoExecute>
        <includeLabel>false</includeLabel>
        <applyToTokens>false</applyToTokens>
        <fontColorKey>black</fontColorKey>
        <fontSize>1.00em</fontSize>
        <minWidth></minWidth>
        <maxWidth></maxWidth>
        <allowPlayerEdits>true</allowPlayerEdits>
        <toolTip></toolTip>
        <commonMacro>false</commonMacro>
        <compareGroup>true</compareGroup>
        <compareSortPrefix>true</compareSortPrefix>
        <compareCommand>true</compareCommand>
        <compareIncludeLabel>true</compareIncludeLabel>
        <compareAutoExecute>true</compareAutoExecute>
        <compareApplyToSelectedTokens>true</compareApplyToSelectedTokens>
      </net.rptools.maptool.model.MacroButtonProperties>
    </entry>
    <entry>
      <int>146</int>
      <net.rptools.maptool.model.MacroButtonProperties>
        <saveLocation>Token</saveLocation>
        <index>146</index>
        <colorKey>default</colorKey>
        <hotKey>None</hotKey>
        <command>[h:debugMode = getLibProperty(&quot;DEBUGMODE&quot;)]
[h:debugMacro = getMacroName()]
[h:targets = arg(0)]
[h:filter = arg(1)]
[h:power = arg(2)]

[h,if(listGet(targets,0) == listGet(targets,1)),CODE:
{
[h:dupeTarget = listGet(targets,0)]

[h:exp = getTokenNames(&quot;json&quot;, filter)]
[h:expList = listSort(json.toList(exp),&quot;N+&quot;)]
[h:expList = listDelete(expList,listFind(expList,dupeTarget))]

[h,if(expList == &quot;&quot;):assert(0, rangeError(), 0)]

&lt;!--Create Image List of Targets--&gt;
[H: imgList = expList]
[H: Num = listCount(imgList)]
[h,COUNT(Num),CODE:
   {
     [h:targetName=listGet(imgList,roll.count)]
     [h,token(targetName): image=getTokenImage()]
     [h:imgList=listReplace(imgList,roll.count,targetName+&quot; &quot;+image)]
   }]

      [h:status=input(
         &quot;.|&lt;html&gt;&lt;b&gt;&quot;+power+&quot;&lt;/b&gt; requires that you target two separate creatures,&lt;/html&gt;||LABEL|SPAN=TRUE&quot;,
         &quot;.|&lt;html&gt;however, you targeted &lt;b&gt;&quot;+listGet(targets,0)+&quot;&lt;/b&gt; twice. Please select&lt;/html&gt;||LABEL|SPAN=TRUE&quot;,
         &quot;.|a valid second target.||LABEL|SPAN=TRUE&quot;,
         &quot;.|&lt;html&gt;&lt;p align=&apos;center&apos;&gt;---------------------------------------------------&lt;/p&gt;&lt;/html&gt;| |LABEL|SPAN=TRUE&quot;,
         &quot;newTarget2|&quot;+imgList+&quot;|Targets|LIST|SELECT=0 ICON=TRUE ICONSIZE=30&quot;)]
      [h:abort(status)]
      
      [h:targets = listReplace(targets, 1, listGet(expList,newTarget2))]
      [if(debugMode): debug(&quot;debugMacro&quot;, &quot;targets&quot;)]
      [macro.return = targets]
};
{
      [macro.return = targets]
};]
</command>
        <label>checkTwoTargets</label>
        <group>User-Defined Functions</group>
        <sortby></sortby>
        <autoExecute>true</autoExecute>
        <includeLabel>false</includeLabel>
        <applyToTokens>false</applyToTokens>
        <fontColorKey>black</fontColorKey>
        <fontSize>1.00em</fontSize>
        <minWidth></minWidth>
        <maxWidth></maxWidth>
        <allowPlayerEdits>true</allowPlayerEdits>
        <toolTip></toolTip>
        <commonMacro>false</commonMacro>
        <compareGroup>true</compareGroup>
        <compareSortPrefix>true</compareSortPrefix>
        <compareCommand>true</compareCommand>
        <compareIncludeLabel>true</compareIncludeLabel>
        <compareAutoExecute>true</compareAutoExecute>
        <compareApplyToSelectedTokens>true</compareApplyToSelectedTokens>
      </net.rptools.maptool.model.MacroButtonProperties>
    </entry>
    <entry>
      <int>29</int>
      <net.rptools.maptool.model.MacroButtonProperties>
        <saveLocation>Token</saveLocation>
        <index>29</index>
        <colorKey>default</colorKey>
        <hotKey>None</hotKey>
        <command>[h:skillList=listSort(json.fields(Skills), &quot;A+&quot;)]
[h:sortedSkillList=&quot;&quot;]

[h,foreach(skill, SkillList),CODE:
{
   [h:locSkillBonus=json.get(Skills, skill)]
   [h:modSign=if(locSkillBonus&gt;=0,&quot;+&quot;,&quot;&quot;)]
   [h:friendlyListing=skill+&quot; (&quot;+modSign+locSkillBonus+&quot;)&quot;]
   [h: sortedSkillList=listAppend(sortedSkillList, friendlyListing)]
}
]

[h:status=input(
	&quot;skillNum|&quot;+sortedSkillList+&quot;|Select Skill|LIST|SELECT=0&quot;,
	&quot;otherSkillMod|0|Additional modifiers or penalties to the roll (use negative numbers for penalties)&quot;)]
[h:abort(status)]

[h:skillName=listGet(skillList,skillNum)]

[h:baseSkillMod=json.get(Skills,skillName)]
[h:d20roll=1d20]
[if(isPC()),CODE:
{
   &lt;b&gt;[r:skillName]&lt;/b&gt; check result: [d20roll+baseSkillMod+otherSkillMod]
};
{
  [h:result = d20roll+baseSkillMod+otherSkillMod]
  [t: outputTo(&apos;gm&apos;,  &quot;&lt;b&gt;&quot;+skillName+&quot;&lt;/b&gt; check result: &quot;+result)]
};]</command>
        <label>Skill Check</label>
        <group>Skills</group>
        <sortby></sortby>
        <autoExecute>true</autoExecute>
        <includeLabel>false</includeLabel>
        <applyToTokens>false</applyToTokens>
        <fontColorKey>black</fontColorKey>
        <fontSize>1.00em</fontSize>
        <minWidth></minWidth>
        <maxWidth></maxWidth>
        <allowPlayerEdits>true</allowPlayerEdits>
        <toolTip></toolTip>
        <commonMacro>false</commonMacro>
        <compareGroup>true</compareGroup>
        <compareSortPrefix>true</compareSortPrefix>
        <compareCommand>true</compareCommand>
        <compareIncludeLabel>true</compareIncludeLabel>
        <compareAutoExecute>true</compareAutoExecute>
        <compareApplyToSelectedTokens>true</compareApplyToSelectedTokens>
      </net.rptools.maptool.model.MacroButtonProperties>
    </entry>
    <entry>
      <int>37</int>
      <net.rptools.maptool.model.MacroButtonProperties>
        <saveLocation>Token</saveLocation>
        <index>37</index>
        <colorKey>default</colorKey>
        <hotKey>None</hotKey>
        <command>[h:selectedTargets=arg(0)]


[h:inputParams = json.append(&quot;[]&quot;, &quot;.|Level of Cover|&lt;html&gt;&lt;b&gt;&lt;u&gt;Target&lt;/u&gt;&lt;/b&gt;&lt;/html&gt;|LABEL&quot;)]
[h,foreach(enemy,selectedTargets): inputParams = json.append(inputParams, &quot;target&quot;+roll.count+&quot;cover|None (0),Regular (-2),Superior (-5)|&lt;html&gt; &amp;nbsp; &quot;+enemy+&quot;&lt;/html&gt;|RADIO|SELECT=0 ORIENT=H&quot;)]
[h:inputParams = json.toList(inputParams, &quot;##&quot;)]
[h:status=input(inputParams)]
[h:abort(status)]

[h:coverMod=json.set(&quot;{}&quot;, &quot;key&quot;, &quot;0&quot;)]

[h,foreach(target, selectedTargets),CODE:
{
   [switch(eval(&quot;target&quot;+roll.count+&quot;cover&quot;)), CODE:
   case 0:
   {
      [h:coverMod=json.set(coverMod, target, 0)]
   };
   case 1:
   {
      [h:coverMod=json.set(coverMod, target, 2)]
   };
   case 2:
   {
       [h:coverMod=json.set(coverMod, target, 5)]
   };]
}]
[r:coverMod]

</command>
        <label>Varying Cover</label>
        <group>Combat - Targeting</group>
        <sortby></sortby>
        <autoExecute>true</autoExecute>
        <includeLabel>false</includeLabel>
        <applyToTokens>false</applyToTokens>
        <fontColorKey>black</fontColorKey>
        <fontSize>1.00em</fontSize>
        <minWidth></minWidth>
        <maxWidth></maxWidth>
        <allowPlayerEdits>true</allowPlayerEdits>
        <toolTip></toolTip>
        <commonMacro>false</commonMacro>
        <compareGroup>true</compareGroup>
        <compareSortPrefix>true</compareSortPrefix>
        <compareCommand>true</compareCommand>
        <compareIncludeLabel>true</compareIncludeLabel>
        <compareAutoExecute>true</compareAutoExecute>
        <compareApplyToSelectedTokens>true</compareApplyToSelectedTokens>
      </net.rptools.maptool.model.MacroButtonProperties>
    </entry>
    <entry>
      <int>41</int>
      <net.rptools.maptool.model.MacroButtonProperties>
        <saveLocation>Token</saveLocation>
        <index>41</index>
        <colorKey>default</colorKey>
        <hotKey>None</hotKey>
        <command>[h:selectedTargets=arg(0)]

[h:inputParams = json.append(&quot;[]&quot;, &quot;.|Granting Combat Advantage?|&lt;html&gt;&lt;b&gt;Target&lt;/b&gt;&lt;/html&gt;|LABEL&quot;)]
[h,foreach(enemy,selectedTargets): inputParams = json.append(inputParams, &quot;target&quot;+roll.count+&quot;ca|Yes,No|&lt;html&gt; &amp;nbsp; &quot;+enemy+&quot;&lt;/html&gt;|RADIO|SELECT=0 ORIENT=H&quot;)]
[h:inputParams = json.toList(inputParams, &quot;##&quot;)]
[h:status=input(inputParams)]
[h:abort(status)]

[h:comAdvMod=json.set(&quot;{}&quot;, &quot;key&quot;, &quot;0&quot;)]

[h,foreach(target, selectedTargets),CODE:
{
   [switch(eval(&quot;target&quot;+roll.count+&quot;ca&quot;)), CODE:
   case 0:
   {
      [h:comAdvMod=json.set(comAdvMod, target, 2)]
   };
   case 1:
   {
      [h:comAdvMod=json.set(comAdvMod, target, 0)]
   };]
}]


[r:comAdvMod]
</command>
        <label>Varying CA</label>
        <group>Combat - Targeting</group>
        <sortby></sortby>
        <autoExecute>true</autoExecute>
        <includeLabel>false</includeLabel>
        <applyToTokens>false</applyToTokens>
        <fontColorKey>black</fontColorKey>
        <fontSize>1.00em</fontSize>
        <minWidth></minWidth>
        <maxWidth></maxWidth>
        <allowPlayerEdits>true</allowPlayerEdits>
        <toolTip></toolTip>
        <commonMacro>false</commonMacro>
        <compareGroup>true</compareGroup>
        <compareSortPrefix>true</compareSortPrefix>
        <compareCommand>true</compareCommand>
        <compareIncludeLabel>true</compareIncludeLabel>
        <compareAutoExecute>true</compareAutoExecute>
        <compareApplyToSelectedTokens>true</compareApplyToSelectedTokens>
      </net.rptools.maptool.model.MacroButtonProperties>
    </entry>
    <entry>
      <int>51</int>
      <net.rptools.maptool.model.MacroButtonProperties>
        <saveLocation>Token</saveLocation>
        <index>51</index>
        <colorKey>default</colorKey>
        <hotKey>None</hotKey>
        <command>[h:powerList=json.fields(Powers)]


  &lt;h2&gt;Power Availability&lt;/h2&gt;
    &lt;table&gt;
        &lt;tr&gt;
            &lt;td&gt;&lt;b&gt;Power Name&lt;/b&gt;&lt;/td&gt;
            &lt;td&gt;&lt;b&gt;Status&lt;/b&gt;&lt;/td&gt;
        &lt;/tr&gt;
        [foreach(power, powerList, &quot;&quot;),CODE:
        {
        [h:powerDetail=json.get(Powers,power)]
           &lt;tr&gt;
                [h:powUseFreq=json.get(powerDetail,&quot;usage&quot;)]
                [r, SWITCH(powUseFreq):
                    case &quot;at-will&quot;: &quot;&lt;td bgcolor=green&gt;&lt;b&gt;&lt;font color=white&gt;&quot;+power;
                    case &quot;encounter&quot;: &quot;&lt;td bgcolor=maroon&gt;&lt;b&gt;&lt;font color=white&gt;&quot;+power;
                    case &quot;daily&quot;:&quot;&lt;td bgcolor=black&gt;&lt;b&gt;&lt;font color=white&gt;&quot;+power;
                    case &quot;recharge&quot;:&quot;&lt;td bgcolor=blue&gt;&lt;b&gt;&lt;font color=white&gt;&quot;+power;]
            &lt;/td&gt;
            &lt;td&gt;
            	&lt;b&gt;&lt;font color=black&gt;[r:json.get(powerDetail,&quot;expended&quot;)]&lt;/font&gt;&lt;/b&gt;
            &lt;/td&gt;
            &lt;/tr&gt;               
        }
        ]
        &lt;tr&gt;
	[IF(isPC()),CODE:
	{
	&lt;td bgcolor=maroon&gt;&lt;b&gt;&lt;font color=white bgcolor=maroon&gt;Second Wind&lt;/font&gt;&lt;/b&gt;&lt;/td&gt;
	&lt;td&gt;&lt;b&gt;&lt;font color=black&gt;[r:json.get(SecondWind,&quot;expended&quot;)]&lt;/font&gt;&lt;/b&gt;&lt;/td&gt;
	};{};]
       &lt;/tr&gt;
 	[h:leaderPowers = json.fields(LeaderHealing)]
  	[foreach(power, leaderPowers, &quot;&quot;), CODE:
	{       
	&lt;tr&gt;
                   		 [IF(isPropertyEmpty(&quot;LeaderHealing&quot;) == 1),CODE:
                   		{};
                    	 	{
		   [h:powerDetail = json.get(LeaderHealing, power)]
		   [h:uses = json.get(powerDetail, &quot;usesLeft&quot;)]
		   &lt;td bgcolor=maroon&gt;&lt;b&gt;&lt;font color=white bgcolor=maroon&gt;[r:power]&lt;/font&gt;&lt;/b&gt;&lt;/td&gt;
		   &lt;td&gt;&lt;b&gt;&lt;font color = black&gt; [r:uses] use(s) remaining.&lt;/font&gt;&lt;/b&gt;&lt;/td&gt;
		};]
	&lt;/tr&gt;
	}]
       &lt;/table&gt;</command>
        <label>Power Use Tracker</label>
        <group>Power Management</group>
        <sortby></sortby>
        <autoExecute>true</autoExecute>
        <includeLabel>false</includeLabel>
        <applyToTokens>false</applyToTokens>
        <fontColorKey>black</fontColorKey>
        <fontSize>1.00em</fontSize>
        <minWidth></minWidth>
        <maxWidth></maxWidth>
        <allowPlayerEdits>true</allowPlayerEdits>
        <toolTip></toolTip>
        <commonMacro>false</commonMacro>
        <compareGroup>true</compareGroup>
        <compareSortPrefix>true</compareSortPrefix>
        <compareCommand>true</compareCommand>
        <compareIncludeLabel>true</compareIncludeLabel>
        <compareAutoExecute>true</compareAutoExecute>
        <compareApplyToSelectedTokens>true</compareApplyToSelectedTokens>
      </net.rptools.maptool.model.MacroButtonProperties>
    </entry>
    <entry>
      <int>48</int>
      <net.rptools.maptool.model.MacroButtonProperties>
        <saveLocation>Token</saveLocation>
        <index>48</index>
        <colorKey>default</colorKey>
        <hotKey>None</hotKey>
        <command>[h:powList=json.fields(Powers)]
[h:rechargePowers = &quot;&quot;]

[h,foreach(power, powList),CODE:
{
    [powDetails = json.get(Powers, power)]
    [usage = json.get(powDetails, &quot;usage&quot;)]
    [expended = json.get(powDetails, &quot;expended&quot;)]
    [if(usage == &quot;recharge&quot; &amp;&amp; expended != &quot;Available&quot;): rechargePowers = listAppend(rechargePowers, power); rechargePowers = rechargePowers]
}]

[h: status=input(
   &quot;selectedPower|&quot;+listSort(rechargePowers, &quot;a&quot;)+&quot;|Choose Power to Recharge|LIST|SELECT=0 VALUE=STRING&quot;
)]
[h:abort(status)]


[h:selectedPowerInfo= json.get(Powers, selectedPower)]
[h:rechargeVals = json.get(selectedPowerInfo, &quot;rechargeOn&quot;)]

[h:rechargeRoll = 1d6]

[if(listFind(rechargeVals, rechargeRoll) != -1),CODE:
{    
   [h:input(&quot;junk|&lt;html&gt;Recharge Roll: &quot;+rechargeRoll+&quot;&lt;br&gt;Recharges On: &quot;+rechargeVals+&quot;&lt;br&gt;&lt;i&gt;&quot;+selectedPower+&quot;&lt;/i&gt; power has recharged&lt;/html&gt;|-|LABEL|SPAN=TRUE&quot;)]
   [h:selectedPowerInfo = json.set(selectedPowerInfo, &quot;expended&quot;, &quot;Available&quot;)]
   [h:Powers = json.set(Powers, selectedPower, selectedPowerInfo)]
   [h:setMacroProps(selectedPower,&quot;color=blue;&quot;)]
};
{
[h:input(&quot;junk|&lt;html&gt;&quot;+&quot;Recharge Roll: &quot;+rechargeRoll+&quot;&lt;br&gt;&lt;i&gt;&quot;+selectedPower+&quot;&lt;/i&gt; power has not recharged&lt;/html&gt;|-|LABEL|SPAN=TRUE&quot;)]
};]

</command>
        <label>RechargePower</label>
        <group>Combat</group>
        <sortby></sortby>
        <autoExecute>true</autoExecute>
        <includeLabel>false</includeLabel>
        <applyToTokens>false</applyToTokens>
        <fontColorKey>black</fontColorKey>
        <fontSize>1.00em</fontSize>
        <minWidth></minWidth>
        <maxWidth></maxWidth>
        <allowPlayerEdits>false</allowPlayerEdits>
        <toolTip></toolTip>
        <commonMacro>false</commonMacro>
        <compareGroup>true</compareGroup>
        <compareSortPrefix>true</compareSortPrefix>
        <compareCommand>true</compareCommand>
        <compareIncludeLabel>true</compareIncludeLabel>
        <compareAutoExecute>true</compareAutoExecute>
        <compareApplyToSelectedTokens>true</compareApplyToSelectedTokens>
      </net.rptools.maptool.model.MacroButtonProperties>
    </entry>
    <entry>
      <int>53</int>
      <net.rptools.maptool.model.MacroButtonProperties>
        <saveLocation>Token</saveLocation>
        <index>53</index>
        <colorKey>default</colorKey>
        <hotKey>None</hotKey>
        <command>[h:powerList=json.fields(Powers)]

[h,foreach(power, powerList),CODE:
{
    [h:powerDetail=json.get(Powers, power)]
    [h:useType=json.get(powerDetail, &quot;usage&quot;)]
    [h:availStatus=json.get(powerDetail,&quot;expended&quot;)]
    [IF(useType==&quot;encounter&quot; &amp;&amp; availStatus==&quot;Expended&quot;),CODE:
		{
		[h:powerDetail=json.set(powerDetail,&quot;expended&quot;,&quot;Available&quot;)]
		[h:Powers=json.set(Powers, power, powerDetail)]
		[h:setMacroProps(json.get(powerDetail,&quot;powername&quot;),&quot;color=red;&quot;)]
		};
		{
		};
     ]
     [IF(useType==&quot;daily&quot; &amp;&amp; availStatus==&quot;Expended&quot;),CODE:
		{
		[h:powerDetail=json.set(powerDetail,&quot;expended&quot;,&quot;Available&quot;)]
		[h:Powers=json.set(Powers, power, powerDetail)]
		[h:setMacroProps(json.get(powerDetail, &quot;powername&quot;),&quot;color=black;&quot;)]
		};
		{
		};
     ]
}
]


[h,if(isPropertyEmpty(&quot;LeaderHealing&quot;) != 0 || json.isEmpty(LeaderHealing) != 0), CODE:
{};
{
 [leaderPowers = json.fields(LeaderHealing)]
 [foreach(power, leaderPowers),CODE:
   {      
   [powerDetail = json.get(LeaderHealing, power)]
   [maxLeaderHeals = json.get(powerDetail, &quot;maxUses&quot;)]
   [resetPower = json.set(powerDetail, &quot;usesLeft&quot;, maxLeaderHeals)]
   [LeaderHealing = json.set(LeaderHealing, power, resetPower)]
   [setMacroProps(power, &quot;color=red;&quot;)]
   }]
};]

[h:swReset=&quot;Available&quot;]
[h:SecondWind=json.set(SecondWind, &quot;expended&quot;, &quot;Available&quot;)]
[h:setMacroProps(&quot;Second Wind&quot;,&quot;color=red;&quot;)]
[h:APSpent=0]
[h:ActionPoints=1]
[h:OngoingDamage = &quot;{}&quot;]
[h:ExternalTiming = &quot;{}&quot;]
[h:MarkedBy = &quot;&quot;]
[h:setProperty(&quot;LastAttackAdjustment&quot;, json.set(&quot;{}&quot;, &quot;adjustment&quot;, 0))]
[h:setProperty(&quot;LastDefenseAdjustment&quot;, json.set(&quot;{}&quot;, &quot;defense&quot;, &quot;AC&quot;, &quot;adjustment&quot;, 0))]

[h:SurgeRemaining=SurgePerDay]

After an extended rest, [r:getName()] has recovered all healing surges and all of [r:Pronoun2] Daily and Encounter powers.</command>
        <label>Extended Rest</label>
        <group>Resting</group>
        <sortby></sortby>
        <autoExecute>true</autoExecute>
        <includeLabel>false</includeLabel>
        <applyToTokens>false</applyToTokens>
        <fontColorKey>black</fontColorKey>
        <fontSize>1.00em</fontSize>
        <minWidth></minWidth>
        <maxWidth></maxWidth>
        <allowPlayerEdits>true</allowPlayerEdits>
        <toolTip></toolTip>
        <commonMacro>false</commonMacro>
        <compareGroup>true</compareGroup>
        <compareSortPrefix>true</compareSortPrefix>
        <compareCommand>true</compareCommand>
        <compareIncludeLabel>true</compareIncludeLabel>
        <compareAutoExecute>true</compareAutoExecute>
        <compareApplyToSelectedTokens>true</compareApplyToSelectedTokens>
      </net.rptools.maptool.model.MacroButtonProperties>
    </entry>
    <entry>
      <int>52</int>
      <net.rptools.maptool.model.MacroButtonProperties>
        <saveLocation>Token</saveLocation>
        <index>52</index>
        <colorKey>default</colorKey>
        <hotKey>None</hotKey>
        <command>[h:powerList=json.fields(Powers)]

[h,foreach(power, powerList),CODE:
{
    [h:powerDetail=json.get(Powers, power)]
    [h:useType=json.get(powerDetail, &quot;usage&quot;)]
    [h:availStatus=json.get(powerDetail,&quot;expended&quot;)]
    [IF(useType==&quot;encounter&quot; &amp;&amp; availStatus==&quot;Expended&quot;),CODE:
		{
		[h:powerDetail=json.set(powerDetail,&quot;expended&quot;,&quot;Available&quot;)]
		[h:Powers=json.set(Powers, power, powerDetail)]
		[h:setMacroProps(json.get(powerDetail, &quot;powername&quot;),&quot;color=red;&quot;)]
		};
		{
		};
     ]
}
]

[h,if(isPropertyEmpty(&quot;LeaderHealing&quot;) != 0 || json.isEmpty(LeaderHealing) != 0), CODE:
{};
{
   [leaderPowers = json.fields(LeaderHealing)]
   [if(listContains(leaderPowers, &quot;Lay on Hands&quot;)): leaderPowers = listDelete(leaderPowers, listFind(leaderPowers, &quot;Lay on Hands&quot;)); leaderPowers=leaderPowers]
   [foreach(power, leaderPowers),CODE:
   {      
   [powerDetail = json.get(LeaderHealing, power)]
   [maxLeaderHeals = json.get(powerDetail, &quot;maxUses&quot;)]
   [resetPower = json.set(powerDetail, &quot;usesLeft&quot;, maxLeaderHeals)]
   [LeaderHealing = json.set(LeaderHealing, power, resetPower)]
   [setMacroProps(power, &quot;color=red;&quot;)]
   }]
};]


[h:OngoingDamage = &quot;{}&quot;]
[h:ExternalTiming = &quot;{}&quot;]
[h:MarkedBy = &quot;&quot;]
[h:setProperty(&quot;LastAttackAdjustment&quot;, json.set(&quot;{}&quot;, &quot;adjustment&quot;, 0))]
[h:setProperty(&quot;LastDefenseAdjustment&quot;, json.set(&quot;{}&quot;, &quot;defense&quot;, &quot;AC&quot;, &quot;adjustment&quot;, 0))]

[h:swReset=&quot;Available&quot;]
[h:SecondWind=json.set(SecondWind, &quot;expended&quot;, &quot;Available&quot;)]
[h:setMacroProps(&quot;Second Wind&quot;,&quot;color=red;&quot;)]
[h:APSpent=0]

After a breather, [r:getName()] has recovered [r:Pronoun2] Encounter powers.
</command>
        <label>Short Rest</label>
        <group>Resting</group>
        <sortby></sortby>
        <autoExecute>true</autoExecute>
        <includeLabel>false</includeLabel>
        <applyToTokens>false</applyToTokens>
        <fontColorKey>black</fontColorKey>
        <fontSize>1.00em</fontSize>
        <minWidth></minWidth>
        <maxWidth></maxWidth>
        <allowPlayerEdits>true</allowPlayerEdits>
        <toolTip></toolTip>
        <commonMacro>false</commonMacro>
        <compareGroup>true</compareGroup>
        <compareSortPrefix>true</compareSortPrefix>
        <compareCommand>true</compareCommand>
        <compareIncludeLabel>true</compareIncludeLabel>
        <compareAutoExecute>true</compareAutoExecute>
        <compareApplyToSelectedTokens>true</compareApplyToSelectedTokens>
      </net.rptools.maptool.model.MacroButtonProperties>
    </entry>
    <entry>
      <int>56</int>
      <net.rptools.maptool.model.MacroButtonProperties>
        <saveLocation>Token</saveLocation>
        <index>56</index>
        <colorKey>default</colorKey>
        <hotKey>None</hotKey>
        <command>[h:powList=json.fields(Powers)]

[h: status=input(
   &quot;pname|&quot;+listSort(powList, &quot;a&quot;)+&quot;|Choose Power to duplicate|LIST|SELECT=0 VALUE=STRING&quot;,
   &quot;newName|--Name--|Name for the duplicate power?&quot;,
   &quot;newPowerUse|at-will,encounter,daily,recharge|What is the use frequency of the duplicate power?|LIST|SELECT=0 VALUE=STRING&quot;)]
[h:abort(status)]

[h,if(newName == &quot;--Name--&quot; || newName == pname),CODE:
{
    [h:status=input(&quot;junk|Please enter a new name for the duplicated power|-|LABEL|SPAN=TRUE&quot;)]
    [h:abort(status)]
    [r:duplicatePower()]
};
{

[h:dupePowerInfo = json.get(Powers, pname)]

[h:dupePowerInfo = json.set(dupePowerInfo, &quot;powername&quot;, newName)]
[h:dupePowerInfo = json.set(dupePowerInfo, &quot;usage&quot;, newPowerUse)]
[h:Powers = json.set(Powers, newName, dupePowerInfo)]

[h:keywords = json.get(dupePowerInfo, &quot;keywords&quot;)]
[h:itemSubString=substring(keywords,0,4)]
[h:pwrLvl = json.get(dupePowerInfo, &quot;pwrLvl&quot;)]

[h,if(itemSubString==&quot;item&quot;),CODE:
{
  [propstring=&quot;color=orange; fontColor=black; group=5. Item; autoExec=true;&quot;]
};
{
[h,switch(json.get(dupePowerInfo,&quot;usage&quot;)):
case &quot;at-will&quot;: propstring=&quot;color=green; fontColor=black; group=1. At-Will; autoExec=true; sortBy=&quot;+pwrLvl; 
case &quot;encounter&quot;:propstring=&quot;color=red; fontColor=white; group=2. Encounter; autoExec=true; sortBy=&quot;+pwrLvl; 
case &quot;daily&quot;: propstring=&quot;color=black; fontColor=white; group=3. Daily; autoExec=true; sortBy=&quot;+pwrLvl; 
case &quot;recharge&quot;: propstring=&quot;color=blue; fontColor=white; group=4. Recharging; autoExec=true; sortBy=&quot;+pwrLvl;
default: propstring=&quot;color=green; fontColor=black; group=1. At-Will; autoExec=true; sortBy=&quot;+pwrLvl;]}]

[h:createMacro(newName, &quot;[macro(&apos;AttackMain@Lib:4e&apos;):&apos;&quot;+newName+&quot;&apos;]&quot;, propstring)]
[h:input(&quot;junk|&quot;+newName+&quot; successfully copied from &quot;+pname+&quot;|-|LABEL|SPAN=TRUE&quot;)]
};]</command>
        <label>Duplicate Power</label>
        <group>Power Management</group>
        <sortby></sortby>
        <autoExecute>true</autoExecute>
        <includeLabel>false</includeLabel>
        <applyToTokens>false</applyToTokens>
        <fontColorKey>black</fontColorKey>
        <fontSize>1.00em</fontSize>
        <minWidth></minWidth>
        <maxWidth></maxWidth>
        <allowPlayerEdits>false</allowPlayerEdits>
        <toolTip></toolTip>
        <commonMacro>false</commonMacro>
        <compareGroup>true</compareGroup>
        <compareSortPrefix>true</compareSortPrefix>
        <compareCommand>true</compareCommand>
        <compareIncludeLabel>true</compareIncludeLabel>
        <compareAutoExecute>true</compareAutoExecute>
        <compareApplyToSelectedTokens>true</compareApplyToSelectedTokens>
      </net.rptools.maptool.model.MacroButtonProperties>
    </entry>
    <entry>
      <int>63</int>
      <net.rptools.maptool.model.MacroButtonProperties>
        <saveLocation>Token</saveLocation>
        <index>63</index>
        <colorKey>default</colorKey>
        <hotKey>None</hotKey>
        <command>&lt;!--Collect the data on the Leader Power being used--&gt;
[h:debugmode = getLibProperty(&quot;DEBUGMODE&quot;)]
[h:debugmacro = getMacroName()]
[h:LeaderPowers = getProperty(&quot;LeaderHealing&quot;)]
[h:powerName = macro.args]
[h:healPower = json.get(LeaderPowers, powerName)]
[h:powerAbilBonus = json.get(healPower, &quot;abilityBonus&quot;)]
[h:powerBonusHP = json.get(healPower, &quot;bonusHPDice&quot;)]
[h:powerRange = json.get(healPower, &quot;range&quot;)]
[h:powerUses = json.get(healPower, &quot;usesLeft&quot;)]
[h,if(json.contains(healPower, &quot;usesTargetSurge&quot;)==1): powerUsesTargetSurge = json.get(healPower, &quot;usesTargetSurge&quot;); powerUsesTargetSurge = &quot;Yes&quot;]

&lt;!--Pull the proper bonus amount from the character casting the power--&gt;
[h,switch(powerAbilBonus):
case &quot;Strength&quot;: fixedHPBonus = StrBonus;
case &quot;Constitution&quot;: fixedHPBonus = ConBonus;
case &quot;Dexterity&quot;: fixedHPBonus = DexBonus;
case &quot;Intelligence&quot;: fixedHPBonus= IntBonus;
case &quot;Wisdom&quot;: fixedHPBonus = WisBonus;
case &quot;Charisma&quot;: fixedHPBonus = ChaBonus;
case &quot;None&quot;: fixedHPBonus = 0;]
[h,if(powerBonusHP != &quot;None&quot;): hpDiceBonus = eval(powerBonusHP); hpDiceBonus = 0]

&lt;!--If the power has been used the maximum number of times, abort the macro with an error message--&gt;
[h:assert(powerUses &gt; 0, token.name+&quot; cannot use &quot;+powerName+&quot; again during this encounter&quot;, 0)]

&lt;!--Get the targets in range (and whether a PC or NPC is calling the power, so we know who to put in the target list--&gt;
[h:me=getName()]
[h:calledByPC=isPC(me)]
[h:maxRange=powerRange]
[h,if(calledByPC):expList=json.toList(getTokenNames(&quot;json&quot;, &apos;{pc:true,  visible:true, unsetStates:[&quot;Dead&quot;,&quot;Reticle&quot;], range: { from:1, upto:&apos;+maxRange+&apos;, distancePerCell:false, metric:&quot;ONE_ONE_ONE&quot;}}&apos;)); expList=json.toList(getTokenNames(&quot;json&quot;,  &apos;{npc:true, unsetStates:[&quot;Dead&quot;,&quot;Reticle&quot;],  visible:true, range: { from:1, upto:&apos;+maxRange+&apos;, distancePerCell:false, metric:&quot;ONE_ONE_ONE&quot;}}&apos;))]

&lt;!--Add yourself to the list, since powers can be used on yourself--&gt;
[h:expList = listAppend(expList, me)]

&lt;!--Algorithm for assembling a list of targets with token images--&gt;
[H: imgList = expList]
[H: Num = listCount(imgList)]
[h,COUNT(Num),CODE:
{
[h:targetName=listGet(imgList,roll.count)]
[h,token(targetName): image=getTokenImage()]
[h:imgList=listReplace(imgList,roll.count,targetName+&quot; &quot;+image)]
}]

&lt;!--Create the input() dialog to ask if any additional bonus HP is coming down the pike--&gt;
[h:status=input(
&quot;targetNum|&quot;+imgList+&quot;|Use &quot;+powerName+&quot; on|LIST|SELECT=0 ICON=TRUE ICONSIZE=30&quot;,
&quot;miscExtraHP|0|Misc Extra Healing (do not include Healer&apos;s Lore or similar features)&quot;)]
[h:abort(status)]

&lt;!--Get the selected target, and check if the target can benefit from it or if they have no surges left--&gt;
[h:target=listGet(expList,targetNum)]
[token(target),CODE:
{
[if(powerUsesTargetSurge == &quot;Yes&quot; &amp;&amp; SurgeRemaining &lt; 1):assert(0, target +&quot; has no surges remaining, and cannot benefit from &quot;+powerName, 0)]
}]

&lt;!--Deduct this usage from the power, and update the power JSON so that it knows how many uses are left--&gt;
[h:powerUses = powerUses - 1]
[h:healPower = json.set(healPower, &quot;usesLeft&quot;, powerUses)]
[h:LeaderHealing = json.set(LeaderHealing, powerName, healPower)]
&lt;!--Gray out the button if the power is used up for this encounter--&gt;
[h,if(json.get(healPower, &quot;usesLeft&quot;) &lt; 1): setMacroProps(powerName, &quot;color=gray;&quot;); &quot;&quot;]
[h,if(powerName==&quot;Lay on Hands&quot;): SurgeRemaining = SurgeRemaining -1]

[h:switchToken(target)]
[h:surgeHP = SurgeValue]
[h,if(powerUsesTargetSurge == &quot;Yes&quot;): SurgeRemaining = SurgeRemaining - 1]
[h:totalAdditionalHP = fixedHPBonus +if(powerName == &quot;Healing Spirit&quot;, 0, hpDiceBonus) +surgeHP]
[r:procHealing(totalAdditionalHP,&quot;regains&quot;,&quot;Leader&quot;,miscExtraHP, powerName, target)]</command>
        <label>Process Leader Healing</label>
        <group>Combat - Healing</group>
        <sortby>3</sortby>
        <autoExecute>true</autoExecute>
        <includeLabel>false</includeLabel>
        <applyToTokens>false</applyToTokens>
        <fontColorKey>black</fontColorKey>
        <fontSize>1.00em</fontSize>
        <minWidth></minWidth>
        <maxWidth></maxWidth>
        <allowPlayerEdits>false</allowPlayerEdits>
        <toolTip></toolTip>
        <commonMacro>false</commonMacro>
        <compareGroup>true</compareGroup>
        <compareSortPrefix>true</compareSortPrefix>
        <compareCommand>true</compareCommand>
        <compareIncludeLabel>true</compareIncludeLabel>
        <compareAutoExecute>true</compareAutoExecute>
        <compareApplyToSelectedTokens>true</compareApplyToSelectedTokens>
      </net.rptools.maptool.model.MacroButtonProperties>
    </entry>
    <entry>
      <int>62</int>
      <net.rptools.maptool.model.MacroButtonProperties>
        <saveLocation>Token</saveLocation>
        <index>62</index>
        <colorKey>default</colorKey>
        <hotKey>None</hotKey>
        <command>[h:assert(json.isEmpty(Powers)==0, &quot;Character sheet cannot be displayed until you add at least one power to the character.&quot;, 0)]
[h: powerList=listSort(json.fields(Powers), &quot;A+&quot;)]
[h,if(json.isEmpty(LeaderHealing) || isPropertyEmpty(&quot;LeaderHealing&quot;)): leaderPowerList=&quot;&quot;; leaderPowerList = listSort(json.fields(LeaderHealing), &quot;A+&quot;)]
[h:awList=&quot;&quot;]
[h:encList=&quot;&quot;]
[h:dList=&quot;&quot;]
[h:rList=&quot;&quot;]
[h:dispResists = &quot;&quot;]
[h:dispVuln = &quot;&quot;]
[h:sortedPowerList=&quot;&quot;]
[h:me = currentToken()]
[h,foreach(dmgt, Resist),if(json.get(Resist,dmgt)&gt;0): dispResists =  listAppend(dispResists, json.get(Resist, dmgt)+&quot; &quot;+dmgt)]
[h,foreach(dmgt,Vulnerable),if(json.get(Vulnerable,dmgt)&gt;0): dispVuln = listAppend(dispVuln, json.get(Vulnerable, dmgt)+&quot; &quot;+dmgt)]

[h,foreach(power, powerList),CODE:
{
	[powerInfo=json.get(Powers,power)]
	[usage=json.get(powerInfo,&quot;usage&quot;)]
	[pname=json.get(powerInfo,&quot;powername&quot;)]
	[switch(usage):
	case &quot;at-will&quot;: awList=listAppend(awList,pname);
	case &quot;encounter&quot;: encList=listAppend(encList,pname);
	case &quot;daily&quot;: dList=listAppend(dList,pname);
	case &quot;recharge&quot;:rList=listAppend(rList,pname);]
}]

[h:awList=listSort(awList,&quot;A+&quot;)]
[h:encList=listSort(encList,&quot;A+&quot;)]
[h:dList=listSort(dList,&quot;A+&quot;)]
[h:rList=listSort(rList,&quot;A+&quot;)]

[h:sortedPowerList=if(rList!=&quot;&quot;, listInsert(sortedPowerList, 0, rList), sortedPowerList)]
[h:sortedPowerList=if(dList!=&quot;&quot;, listInsert(sortedPowerList,0, dList), sortedPowerList)]
[h:sortedPowerList=if(encList!=&quot;&quot;, listInsert(sortedPowerList,0,encList), sortedPowerList)]
[h:sortedPowerList=if(awList!=&quot;&quot;, listInsert(sortedPowerList,0,awList), sortedPowerList)]
[h:num=listCount(sortedPowerList)]


[h:skillList=json.fields(Skills)]



&lt;html&gt;
&lt;body&gt;
&lt;table width=&quot;100%&quot; bgcolor=&quot;#ffffff&quot;&gt;
&lt;tr bgcolor=&quot;#000000&quot;&gt;
&lt;td colspan=&quot;2&quot; color=&quot;#ffffff&quot;&gt;&lt;b&gt;[r:token.name]&lt;/b&gt;&lt;/td&gt;&lt;td color=&quot;#ffffff&quot; style=&quot;text-align:right;&quot;&gt;&lt;b&gt;Level [r:CharLevel] [r:Race] [r:Class]&lt;/b&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;table width=&quot;100%&quot; bgcolor=#ffffff&quot;&gt;
&lt;tr&gt;
&lt;td valign=&quot;top&quot; width=&quot;55%&quot;&gt;&lt;b&gt;Initiative Bonus&lt;/b&gt;: [r:if(InitBonus&gt;=0, &quot;+&quot;+InitBonus, InitBonus)]&lt;br&gt;
&lt;b&gt;HP&lt;/b&gt;: [r:CurrHP]/[r:MaxHP], &lt;b&gt;Bloodied&lt;/b&gt;: [r:Bloodied]&lt;br&gt;
[r:if(dispResists == &quot;&quot;, &quot;&quot;, &quot;&lt;b&gt;Resist &lt;/b&gt;&quot;+dispResists+&quot;&lt;br&gt;&quot;)]
[r:if(dispVuln == &quot;&quot;, &quot;&quot;, &quot;&lt;b&gt;Vulnerable &lt;/b&gt;&quot;+dispVuln+&quot;&lt;br&gt;&quot;)]
&lt;b&gt;AC&lt;/b&gt;: [r:AC], &lt;b&gt;Fort&lt;/b&gt;: [r:Fortitude], &lt;b&gt;Ref&lt;/b&gt;: [r:Reflex], &lt;b&gt;Will&lt;/b&gt;: [r:Will]&lt;br&gt;
&lt;b&gt;Speed&lt;/b&gt;: [r:Speed]&lt;br&gt;
&lt;b&gt;Healing Surge Value&lt;/b&gt;: [r:SurgeValue]&lt;br&gt;
&lt;b&gt;Healing Surges&lt;/b&gt;: [r:SurgeRemaining] / [r:SurgePerDay]&lt;/td&gt;

&lt;td valign=&quot;top&quot;&gt;&lt;b&gt;Str&lt;/b&gt;: [r:Strength] ([r:if(StrBonus&gt;=0, &quot;+&quot;+StrBonus, StrBonus)])&lt;br&gt;
&lt;b&gt;Con&lt;/b&gt;: [r:Constitution] ([r:if(ConBonus&gt;=0, &quot;+&quot;+ConBonus, ConBonus)])&lt;br&gt;
&lt;b&gt;Dex&lt;/b&gt;: [r:Dexterity] ([r:if(DexBonus&gt;=0, &quot;+&quot;+DexBonus, DexBonus)])&lt;br&gt;
&lt;b&gt;Int&lt;/b&gt;: [r:Intelligence] ([r:if(IntBonus &gt;= 0, &quot;+&quot;+IntBonus, IntBonus)])&lt;br&gt;
&lt;b&gt;Wis&lt;/b&gt;: [r:Wisdom] ([r:if(WisBonus&gt;=0, &quot;+&quot;+WisBonus, WisBonus)])&lt;br&gt;
&lt;b&gt;Cha&lt;/b&gt;: [r:Charisma] ([r:if(ChaBonus&gt;=0, &quot;+&quot;+ChaBonus, ChaBonus)])&lt;/td&gt;
&lt;td style=&quot;text-align:right;&quot;&gt;
&lt;img src=&apos;[r:getTokenImage()]&apos; width=&quot;100&quot; height=&quot;100&quot;&gt;&lt;/img&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td bgcolor=&quot;#dcdcdc&quot; colspan=&quot;3&quot; width=&quot;100%&quot; valign=&quot;top&quot;&gt;
&lt;b&gt;&lt;u&gt;Skills&lt;/u&gt;&lt;/b&gt;:&lt;br&gt;

[foreach(skill, skillList),CODE:
{
	[h:skillBonus = json.get(Skills, skill)]
	&lt;b&gt;[r:skill]&lt;/b&gt; ([r:if(skillBonus&gt;=0, &quot;+&quot;+skillBonus, skillBonus)])
}]
&lt;/td&gt;
&lt;/tr&gt;

[foreach(power,sortedPowerList,&quot;&quot;),CODE:
{
[h:powerDetail=json.get(Powers, power)]
	[h:usage=json.get(powerDetail, &quot;usage&quot;)]
	[h,if(json.get(powerDetail,&quot;requirements&quot;) != &quot;&quot; &amp;&amp; json.get(powerDetail,&quot;requirements&quot;) != &quot;--none--&quot;): hasReqs = 1; hasReqs = 0]
	[h,if(json.get(powerDetail,&quot;hitEffect&quot;) != &quot;&quot; &amp;&amp; json.get(powerDetail, &quot;hitEffect&quot;) != &quot;--none--&quot;): hasHitEff = 1; hasHitEff=0]
	[h,if(json.get(powerDetail,&quot;missEffect&quot;) != &quot;&quot; &amp;&amp; json.get(powerDetail, &quot;missEffect&quot;) != &quot;--none--&quot;): hasMissEff = 1; hasMissEff = 0]
	[h,if(json.get(powerDetail,&quot;alwaysEffect&quot;) != &quot;&quot; &amp;&amp; json.get(powerDetail, &quot;alwaysEffect&quot;) != &quot;--none--&quot;): hasAlwaysEff=1; hasAlwaysEff=0]
	[h,switch(usage):
	case &quot;at-will&quot;: bgcolor=&quot;#006600&quot;;
	case &quot;encounter&quot;: bgcolor=&quot;#990000&quot;;
	case &quot;daily&quot;: bgcolor=&quot;#000000&quot;;
	case &quot;recharge&quot;:bgcolor=&quot;blue&quot;;
	default:bgcolor=&quot;#006600&quot;;]
	&lt;tr bgcolor=[r:bgcolor]&gt;
	&lt;td colspan=&quot;1&quot; color=&quot;#ffffff&quot; width=&quot;75%&quot;&gt;&lt;b&gt;[r:if(json.get(powerDetail,&quot;expended&quot;)==&quot;expended&quot;,&quot;&amp;#9746&quot;, &quot;&amp;#9744&quot;)] &lt;font color=&quot;white&quot;&gt;[r:json.get(powerDetail,&quot;powername&quot;)]&lt;/font&gt;&lt;/b&gt;&lt;/td&gt;
	&lt;td&gt;
	&lt;td colspan=&quot;2&quot; color=&quot;#ffffff&quot; width=&quot;25%&quot; align=&quot;right&quot;&gt;&lt;b&gt;[r:Class] [r:json.get(powerDetail,&quot;pCategory&quot;)] [r:json.get(powerDetail,&quot;level&quot;)]&lt;/td&gt;
	&lt;/tr&gt;
	&lt;tr bgcolor=[r:bgcolor]&gt;
	&lt;td colspan=&quot;3&quot; color=&quot;#ffffff&quot;&gt;([r:json.get(powerDetail, &quot;action&quot;)] &amp;#10022; [r:json.get(powerDetail, &quot;usage&quot;)])
	&lt;b&gt; / Keywords&lt;/b&gt;: [r:json.get(powerDetail,&quot;keywords&quot;)] / &lt;b&gt;Targets&lt;/b&gt; [r:json.get(powerDetail,&quot;targets&quot;)]&lt;/td&gt;
	&lt;tr bgcolor=&quot;#ffffff&quot;&gt;
	&lt;td colspan=&quot;3&quot;&gt;+[r:json.get(powerDetail,&quot;attack&quot;)] vs. [r:json.get(powerDetail, &quot;against&quot;)], [r:json.get(powerDetail,&quot;damage&quot;)] ([r:json.get(powerDetail,&quot;critdamage&quot;)] critical) [r:if(json.contains(powerDetail, &quot;critLower&quot;) &amp;&amp; json.get(powerDetail, &quot;critLower&quot;) != 20, &quot;/ &lt;b&gt;Crit Range&lt;/b&gt;: &quot;+json.get(powerDetail, &quot;critLower&quot;)+&quot;-20&quot;, &quot;&quot;)]&lt;br&gt;
	[r,if(hasHitEff):&quot;&lt;b&gt;Hit&lt;/b&gt;: &quot;+json.get(powerDetail, &quot;hitEffect&quot;)+&quot;&lt;br&gt;&quot;]
	[r,if(hasMissEff): &quot;&lt;b&gt;Miss&lt;/b&gt;: &quot;+json.get(powerDetail, &quot;missEffect&quot;)+&quot;&lt;br&gt;&quot;]
	[r,if(hasAlwaysEff): &quot;&lt;b&gt;Effect&lt;/b&gt;: &quot;+json.get(powerDetail, &quot;alwaysEffect&quot;)+&quot;&lt;br&gt;&quot;]
	[r,if(hasReqs): &quot;&lt;b&gt;Requirements&lt;/b&gt;: &quot;+json.get(powerDetail, &quot;requirements&quot;)]
	&lt;/td&gt;
	&lt;/tr&gt;	
}]


[if(listCount(leaderPowerList) &gt; 0), foreach(healPower, leaderPowerList, &quot;&quot;),CODE:
{
     [h:healPowerDetail = json.get(LeaderHealing,healPower)]
     [h:lpMaxUses = json.get(healPowerDetail, &quot;maxUses&quot;)]
     [h:lpUsesLeft = json.get(healPowerDetail, &quot;usesLeft&quot;)]
    [h,switch(json.get(healPowerDetail, &quot;abilityBonus&quot;)):
    case &quot;Strength&quot;: fixedHPBonus = StrBonus;
    case &quot;Constitution&quot;: fixedHPBonus = ConBonus;
    case &quot;Dexterity&quot;: fixedHPBonus = DexBonus;
    case &quot;Intelligence&quot;: fixedHPBonus= IntBonus;
    case &quot;Wisdom&quot;: fixedHPBonus = WisBonus;
    case &quot;Charisma&quot;: fixedHPBonus = ChaBonus;
    case &quot;None&quot;: fixedHPBonus = 0;]
    [h:checkboxes = &quot;&quot;]

    [h,if(lpMaxUses - lpUsesLeft == 0),CODE:
    {
        [count(lpMaxUses): checkboxes = checkboxes + &quot;&amp;#9744&quot;]
    };
    {
        [count(lpMaxUses - lpUsesLeft): checkboxes = checkboxes + &quot;&amp;#9746&quot;]
        [count(lpUsesLeft): checkboxes = checkboxes + &quot;&amp;#9744&quot;]
     };]

     [h,if(json.get(healPowerDetail, &quot;abilityBonus&quot;)==&quot;None&quot;): healBoost = &quot;&quot;; healBoost = &quot;+&quot;+json.get(healPowerDetail,&quot;abilityBonus&quot;)]
     &lt;tr bgcolor=&quot;#990000&quot;&gt;
     &lt;td colspan=&quot;3&quot; color=&quot;#ffffff&quot;&gt;&lt;b&gt;[r:checkboxes]&lt;font color=&quot;white&quot;&gt;[r:healPower]&lt;/font&gt;&lt;/b&gt;&lt;/td&gt;&lt;/tr&gt;
      &lt;tr&gt;
      &lt;td colspan=&quot;3&quot;&gt;&lt;b&gt;Bonus to Healing:&lt;/b&gt; [r:json.get(healPowerDetail, &quot;bonusHPDice&quot;) +&quot;+&quot;+ fixedHPBonus, &quot;N/A&quot;)]; &lt;b&gt;Uses Per [r:if(healPower == &quot;Lay on Hands&quot;, &quot;Day&quot;, &quot;Encounter&quot;)]:&lt;/b&gt; [r:lpMaxUses]&lt;/td&gt;
      &lt;/tr&gt;
};
{};]
&lt;/table&gt;
&lt;/body&gt;
&lt;html&gt;
</command>
        <label>Generate Basic Sheet</label>
        <group>Character Sheet &amp; Power Cards</group>
        <sortby></sortby>
        <autoExecute>true</autoExecute>
        <includeLabel>false</includeLabel>
        <applyToTokens>true</applyToTokens>
        <fontColorKey>black</fontColorKey>
        <fontSize>1.00em</fontSize>
        <minWidth></minWidth>
        <maxWidth></maxWidth>
        <allowPlayerEdits>false</allowPlayerEdits>
        <toolTip></toolTip>
        <commonMacro>false</commonMacro>
        <compareGroup>true</compareGroup>
        <compareSortPrefix>true</compareSortPrefix>
        <compareCommand>true</compareCommand>
        <compareIncludeLabel>true</compareIncludeLabel>
        <compareAutoExecute>true</compareAutoExecute>
        <compareApplyToSelectedTokens>true</compareApplyToSelectedTokens>
      </net.rptools.maptool.model.MacroButtonProperties>
    </entry>
    <entry>
      <int>61</int>
      <net.rptools.maptool.model.MacroButtonProperties>
        <saveLocation>Token</saveLocation>
        <index>61</index>
        <colorKey>default</colorKey>
        <hotKey>None</hotKey>
        <command>[h:powerObj=Powers]
[frame(&quot;Character Sheet&quot;):
{
  [macro(&quot;Generate Basic Sheet@this&quot;):token.name]
}]
[h:abort(0)]</command>
        <label>Display Character Sheet</label>
        <group>Character Sheet &amp; Power Cards</group>
        <sortby></sortby>
        <autoExecute>true</autoExecute>
        <includeLabel>false</includeLabel>
        <applyToTokens>false</applyToTokens>
        <fontColorKey>black</fontColorKey>
        <fontSize>1.00em</fontSize>
        <minWidth></minWidth>
        <maxWidth></maxWidth>
        <allowPlayerEdits>true</allowPlayerEdits>
        <toolTip></toolTip>
        <commonMacro>false</commonMacro>
        <compareGroup>true</compareGroup>
        <compareSortPrefix>true</compareSortPrefix>
        <compareCommand>true</compareCommand>
        <compareIncludeLabel>true</compareIncludeLabel>
        <compareAutoExecute>true</compareAutoExecute>
        <compareApplyToSelectedTokens>true</compareApplyToSelectedTokens>
      </net.rptools.maptool.model.MacroButtonProperties>
    </entry>
    <entry>
      <int>68</int>
      <net.rptools.maptool.model.MacroButtonProperties>
        <saveLocation>Token</saveLocation>
        <index>68</index>
        <colorKey>default</colorKey>
        <hotKey>None</hotKey>
        <command>[h:dmgHealth = listSort(getTokenStates(&quot;,&quot;, &quot;Damage and Health&quot;), &quot;A+&quot;)]
[h:dmgHealth = listInsert(dmgHealth, 0, &quot;&quot;)]

[h:markList = listSort(getTokenStates(&quot;,&quot;, &quot;Marks&quot;), &quot;A+&quot;)]
[h:markList = listInsert(markList, 0, &quot;&quot;)]

[h:mentalList = listSort(getTokenStates(&quot;,&quot;, &quot;Mental&quot;), &quot;A+&quot;)]
[h:mentalList = listInsert(mentalList, 0, &quot;&quot;)]

[h:moveList = listSort(getTokenStates(&quot;,&quot;, &quot;Movement&quot;), &quot;A+&quot;)]
[h:moveList = listInsert(moveList, 0, &quot;&quot;)]

[h:ongoingList=listSort(getTokenStates(&quot;,&quot;, &quot;Ongoing&quot;), &quot;A+&quot;)]
[h:ongoingList = listInsert(ongoingList, 0, &quot;&quot;)]

[h:physicalList=listSort(getTokenStates(&quot;,&quot;, &quot;Physical&quot;), &quot;A+&quot;)]
[h:physicalList = listInsert(physicalList, 0, &quot;&quot;)]

[h:sensoryList=listSort(getTokenStates(&quot;,&quot;, &quot;Sensory&quot;), &quot;A+&quot;)]
[h:sensoryList = listInsert(sensoryList, 0, &quot;&quot;)]

[h:bpList = listSort(getTokenStates(&quot;,&quot;,&quot;Bonuses &amp; Penalties&quot;), &quot;A+&quot;)]
[h:bpList = listInsert(bpList, 0, &quot;&quot;)]

[h:trvList = listSort(getTokenStates(&quot;,&quot;,&quot;Temporary Resist and Vulnerable&quot;), &quot;A+&quot;)]
[h:trvList = listInsert(trvList,0,&quot;&quot;)]

[h:charFilter = json.set(&quot;{}&quot;, &quot;visible&quot;, 1)]
[h:charList = getTokenNames(&quot;,&quot;, charFilter)]
[h:charList = listInsert(charList,0, &quot;&quot;)]
[h:expireList = &quot; ,End of Next Turn,Beginning of Next Turn,End of Encounter,Save Ends,No Save,Special&quot;]

[h:defAdjust=getLibProperty(&quot;DefAdjustments&quot;)]
[h:attAdjust=getLibProperty(&quot;AttAdjustments&quot;)]
[h:resAdjust =getLibProperty(&quot;RAdjusts&quot;)]
[h:vlnAdjust =getLibProperty(&quot;VAdjusts&quot;)]
[h:start = getInitiativeRound()]

[h:status=input(
&quot;hdConds|Health &amp; Damage||TAB|SELECT=1&quot;,
&quot;.|&lt;html&gt;&lt;b&gt;Note:&lt;/b&gt; in this dialog, duration is always relative to the &lt;i&gt;imposing character&apos;s&lt;/i&gt; turn.&lt;/html&gt;||LABEL|SPAN=TRUE&quot;,
&quot;junk|&lt;html&gt;&lt;b&gt;Health &amp; Defenses&lt;/b&gt;&lt;/html&gt;|-|LABEL|SPAN=TRUE&quot;,
&quot;newDmg|&quot;+dmgHealth+&quot;|Condition|LIST|SELECT=0 VALUE=STRING&quot;,
&quot;ndImposedBy|&quot;+charList+&quot;|Imposed By|LIST|SELECT=0 VALUE=STRING&quot;,
&quot;ndExpires|&quot;+expireList+&quot;|Condition Expires|LIST|SELECT=0 VALUE=STRING&quot;,
&quot;ndRegenAmt|0|For Regeneration, enter regeneration amount&quot;,
&quot;junk|&lt;html&gt;&lt;b&gt;Ongoing Damage&lt;/b&gt;&lt;/html&gt;|-|LABEL|SPAN=TRUE&quot;,
&quot;newOngoing|&quot;+ongoingList+&quot;|Condition|LIST|SELECT=0 VALUE=STRING&quot;,
&quot;nogImposedBy|&quot;+charList+&quot;|Imposed By|LIST|SELECT=0 VALUE=STRING&quot;,
&quot;nogAmount|0|Amount of ongoing damage&quot;,
&quot;nogExpires|&quot;+expireList+&quot;|Expires|LIST|SELECT=0 VALUE=STRING&quot;,
&quot;.|&lt;html&gt;&lt;b&gt;Temporary Resist/Vulnerable&lt;/b&gt;&lt;/html&gt;||LABEL|SPAN=TRUE&quot;,
&quot;newTRV|&quot;+trvList+&quot;|Resistance/Vulnerability|LIST|SELECT=0 VALUE=STRING&quot;,
&quot;ntrvImposedBy|&quot;+charList+&quot;|Imposed By|LIST|SELECT=0 VALUE=STRING&quot;,
&quot;ntrvAmount|0|Amount of Resistance or Vulnerability (use positive numbers)&quot;,
&quot;ntrvExpires|&quot;+expireList+&quot;|Expires|LIST|SELECT=0 VALUE=STRING&quot;,
&quot;mqcConds|Marks/Bonuses/Penalties||TAB&quot;,
&quot;.|&lt;html&gt;&lt;b&gt;Note:&lt;/b&gt; in this dialog, duration is always relative to the &lt;i&gt;imposing character&apos;s&lt;/i&gt; turn.&lt;/html&gt;||LABEL|SPAN=TRUE&quot;,
&quot;junk|&lt;html&gt;&lt;b&gt;Marks, Curses, and Quarries&lt;/b&gt;&lt;/html&gt;|-|LABEL|SPAN=TRUE&quot;,
&quot;newMark|&quot;+markList+&quot;|Condition|LIST|SELECT=0 VALUE=STRING&quot;,
&quot;nmImposedBy|&quot;+charList+&quot;|Imposed By|LIST|SELECT=0 VALUE=STRING&quot;,
&quot;nmExpires|&quot;+expireList+&quot;|Expires|LIST|SELECT=0 VALUE=STRING&quot;,
&quot;junk|&lt;html&gt;&lt;b&gt;Miscellaneous Bonuses &amp; Penalties&lt;/b&gt;&lt;/html&gt;|-|LABEL|SPAN=TRUE&quot;,
&quot;newBP|&quot;+bpList+&quot;|Bonus or Penalty|LIST|SELECT=0 VALUE=STRING&quot;,
&quot;nbpImposedBy|&quot;+charList+&quot;|Imposed by|LIST|SELECT=0 VALUE=STRING&quot;,
&quot;nbpExpires|&quot;+expireList+&quot;|Expires|LIST|SELECT=0 VALUE=STRING&quot;,
&quot;pmsConds|Physical/Mental/Sensory||TAB&quot;,
&quot;.|&lt;html&gt;&lt;b&gt;Note:&lt;/b&gt; in this dialog, duration is always relative to the &lt;i&gt;imposing character&apos;s&lt;/i&gt; turn.&lt;/html&gt;||LABEL|SPAN=TRUE&quot;,
&quot;junk|&lt;html&gt;&lt;b&gt;Physical Conditions&lt;/b&gt;&lt;/html&gt;|-|LABEL|SPAN=TRUE&quot;,
&quot;newPhysical|&quot;+physicalList+&quot;|Condition|LIST|SELECT=0 VALUE=STRING&quot;,
&quot;npImposedBy|&quot;+charList+&quot;|Imposed by|LIST|SELECT=0 VALUE=STRING&quot;,
&quot;npExpires|&quot;+expireList+&quot;|Expires|LIST|SELECT=0 VALUE=STRING&quot;,
&quot;junk|&lt;html&gt;&lt;b&gt;Mental Conditions&lt;/b&gt;&lt;/html&gt;|-|LABEL|SPAN=TRUE&quot;,
&quot;newMental|&quot;+mentalList+&quot;|Condition|LIST|SELECT=0 VALUE=STRING&quot;,
&quot;nmnImposedBy|&quot;+charList+&quot;|Imposed By|LIST|SELECT=0 VALUE=STRING&quot;,
&quot;nmnExpires|&quot;+expireList+&quot;|Expires|LIST|SELECT=0 VALUE=STRING&quot;,
&quot;junk|&lt;html&gt;&lt;b&gt;Sensory Conditions&lt;/b&gt;&lt;/html&gt;|-|LABEL|SPAN=TRUE&quot;,
&quot;newSensory|&quot;+sensoryList+&quot;|Condition|LIST|SELECT=0 VALUE=STRING&quot;,
&quot;nsImposedBy|&quot;+charList+&quot;|Imposed by|LIST|SELECT=0 VALUE=STRING&quot;,
&quot;nsExpires|&quot;+expireList+&quot;|Expires|LIST|SELECT=0 VALUE=STRING&quot;,
&quot;junk|&lt;html&gt;&lt;b&gt;Movement Conditions&lt;/b&gt;&lt;/html&gt;|-|LABEL|SPAN=TRUE&quot;,
&quot;newMove|&quot;+moveList+&quot;|Condition|LIST|SELECT=0 VALUE=STRING&quot;,
&quot;nmvImposedBy|&quot;+charList+&quot;|Imposed by|LIST|SELECT=0 VALUE=STRING&quot;,
&quot;nmvExpires|&quot;+expireList+&quot;|Expires|LIST|SELECT=0 VALUE=STRING&quot;)]
[h:abort(status)]

[h:extConditions=&quot;{}&quot;]
[h:intConditions = &quot;{}&quot;]

[h,if(newDmg != &quot;&quot;),CODE:
{
  [setState(newDmg, 1)]
  [if(ndImposedBy == &quot;&quot;): ndImposedBy =token.name]
  [if(ndExpires == &quot;&quot;): ndExpires = &quot;End of Next Turn&quot;]
  [h,if(newDmg == &quot;SecondWindBonus&quot;),CODE:
  {
      [procDefBonus()]
      [ndExpires = &quot;Beginning of Next Turn&quot;]
      [ndImposedBy = token.name]
  };{};]
  [newStateObj = json.set(&quot;{}&quot;, &quot;ogDamAmt&quot;, ndRegenAmt, &quot;imposedBy&quot;, ndImposedBy, &quot;expires&quot;, ndExpires, &quot;start&quot;, start)]
  [ExternalTiming = json.set(ExternalTiming, newDmg, newStateObj)]
};  
{};]

[h,if(newOngoing != &quot;&quot;),CODE:
{
  [setState(newOngoing, 1)]
  [if(nogExpires == &quot;&quot;): nogExpires = &quot;End of Next Turn&quot;]
  [if(nogImposedBy == &quot;&quot;): nogImposedBy = token.name]
  [newStateObj = json.set(&quot;{}&quot;, &quot;ogDamAmt&quot;, nogAmount, &quot;imposedBy&quot;, nogImposedBy, &quot;expires&quot;, nogExpires, &quot;start&quot;, start)]
  [OngoingDamage = json.set(OngoingDamage, newOngoing, newStateObj)]
};
{};]

[h,if(newMark != &quot;&quot;),CODE:
{
  [setState(newMark, 1)]
  [if(nmImposedBy == &quot;&quot;): nmImposedBy = token.name]
  [if(nmExpires == &quot;&quot;): nmExpires = &quot;End of Next Turn&quot;]
  [newStateObj = json.set(&quot;{}&quot;, &quot;imposedBy&quot;, nmImposedBy, &quot;expires&quot;, nmExpires, &quot;start&quot;, start)]
  [ExternalTiming = json.set(ExternalTiming, newMark, newStateObj)]
  [if(listFind(getLibProperty(&quot;TrueMarks&quot;)!=-1): MarkedBy = nmImposedBy; MarkedBy = MarkedBy]
};
{};]

[h,if(newMental != &quot;&quot;),CODE:
{
  [setState(newMental, 1)]
  [if(nmnImposedBy == &quot;&quot;): nmnImposedBy =token.name]
  [if(nmnExpires == &quot;&quot;): nmnExpires = &quot;End of Next Turn&quot;]
  [newStateObj = json.set(&quot;{}&quot;, &quot;imposedBy&quot;, nmnImposedBy, &quot;expires&quot;, nmnExpires, &quot;start&quot;, start)]
  [ExternalTiming = json.set(ExternalTiming, newMental, newStateObj)]
  };
{};]

[h,if(newPhysical != &quot;&quot;),CODE:
{
  [setState(newPhysical, 1)]
  [if(npImposedBy == &quot;&quot;): npImposedBy =token.name]
  [if(npExpires == &quot;&quot;): npExpires = &quot;End of Next Turn&quot;]
  [newStateObj = json.set(&quot;{}&quot;, &quot;imposedBy&quot;, npImposedBy, &quot;expires&quot;, npExpires, &quot;start&quot;, start)]
    [ExternalTiming = json.set(ExternalTiming, newPhysical, newStateObj)]
  };
{};]

[h,if(newSensory != &quot;&quot;),CODE:
{
  [setState(newSensory, 1)]
  [if(nsImposedBy == &quot;&quot;): nsImposedBy =token.name]
  [if(nsExpires == &quot;&quot;): nsExpires = &quot;End of Next Turn&quot;]
  [newStateObj = json.set(&quot;{}&quot;, &quot;imposedBy&quot;, nsImposedBy, &quot;expires&quot;, nsExpires, &quot;start&quot;, start)]
    [ExternalTiming = json.set(ExternalTiming, newSensory, newStateObj)]
};
{};]

[h,if(newMove != &quot;&quot;),CODE:
{
  [setState(newMove, 1)]
  [if(nmvImposedBy == &quot;&quot;): nmvImposedBy =token.name]
  [if(nmvExpires == &quot;&quot;): nmvExpires = &quot;End of Next Turn&quot;]
  [newStateObj = json.set(&quot;{}&quot;, &quot;imposedBy&quot;, nmvImposedBy, &quot;expires&quot;, nmvExpires, &quot;start&quot;, start)]
  [ExternalTiming = json.set(ExternalTiming, newMove, newStateObj)]
};{};]

[h,if(newBP != &quot;&quot;),CODE:
{
  [setState(newBP, 1)]
  [if(nbpImposedBy == &quot;&quot;): nbpImposedBy = token.name]
  [if(nbpExpires == &quot;&quot;): nbpExpires = &quot;End of Next Turn&quot;]
  [if(listFind(defAdjust, newBP) != -1): procDefBonus()]
  [if(listFind(attAdjust, newBP) != -1): procAttBonus()]
  [newStateObj = json.set(&quot;{}&quot;, &quot;imposedBy&quot;, nbpImposedBy, &quot;expires&quot;, nbpExpires, &quot;start&quot;, start)]
  [ExternalTiming = json.set(ExternalTiming, newBP, newStateObj)]
};{};]


[h,if(newTRV != &quot;&quot;),CODE:
{
  [setState(newTRV, 1)]
  [if(ntrvImposedBy == &quot;&quot;): ntrvImposedBy = token.name]
  [if(ntrvExpires == &quot;&quot;): ntrvExpires = &quot;End of Next Turn&quot;]
  [if(listFind(resAdjust, newTRV) != -1): procTempResist(newTRV,ntrvAmount)]
  [if(listFind(vlnAdjust, newTRV) != -1): procTempVulnerable(newTRV,ntrvAmount)]
  [newStateObj = json.set(&quot;{}&quot;, &quot;imposedBy&quot;, ntrvImposedBy, &quot;expires&quot;, ntrvExpires, &quot;start&quot;, start)]
  [ExternalTiming = json.set(ExternalTiming, newTRV, newStateObj)]
};{};]</command>
        <label>Add New Condition</label>
        <group>Conditions</group>
        <sortby></sortby>
        <autoExecute>true</autoExecute>
        <includeLabel>false</includeLabel>
        <applyToTokens>false</applyToTokens>
        <fontColorKey>black</fontColorKey>
        <fontSize>1.00em</fontSize>
        <minWidth></minWidth>
        <maxWidth></maxWidth>
        <allowPlayerEdits>false</allowPlayerEdits>
        <toolTip></toolTip>
        <commonMacro>false</commonMacro>
        <compareGroup>true</compareGroup>
        <compareSortPrefix>true</compareSortPrefix>
        <compareCommand>true</compareCommand>
        <compareIncludeLabel>true</compareIncludeLabel>
        <compareAutoExecute>true</compareAutoExecute>
        <compareApplyToSelectedTokens>true</compareApplyToSelectedTokens>
      </net.rptools.maptool.model.MacroButtonProperties>
    </entry>
    <entry>
      <int>64</int>
      <net.rptools.maptool.model.MacroButtonProperties>
        <saveLocation>Token</saveLocation>
        <index>64</index>
        <colorKey>default</colorKey>
        <hotKey>None</hotKey>
        <command>[h:leaderHeals = &quot;Healing Infusion - Restorative, Healing Spirit, Healing Word, Inspiring Word, Lay on Hands, Majestic Word&quot;]
[h:abilityList = &quot;None, Strength, Constitution, Dexterity, Intelligence, Wisdom, Charisma&quot;]
[h:bonusDice=&quot;None, 1d6, 2d6, 3d6, 4d6, 5d6, 6d6&quot;]
[h:rangeList=&quot;1,5,10,15&quot;]
[h:uses=&quot;1,2,3&quot;]

[h:status1=input(
&quot;whichHealPower|&quot;+leaderHeals+&quot;|Which Leader healing power do you have?|LIST|SELECT=0 VALUE=STRING&quot;,
&quot;abilityBonus|&quot;+abilityList+&quot;|Bonus from Ability (if any)|LIST|SELECT=0 VALUE=STRING&quot;,
&quot;bonusHPDice|&quot;+bonusDice+&quot;|Amount of additional HP (if any; ignore for Healing Spirit)|LIST|SELECT=0 VALUE=STRING&quot;,
&quot;powerRange|&quot;+rangeList+&quot;|Range of Power (for touch, use 1)|LIST|SELECT=0 VALUE=STRING&quot;,
&quot;usesPerEnc|&quot;+uses+&quot;|Uses per encounter (ignored for Lay on Hands)|LIST|SELECT=0 VALUE=STRING&quot;,
&quot;usesTargetSurge|Yes,No|Does this power require the target to spend a healing surge?|RADIO|SELECT=0 VALUE=STRING&quot;)]
[h:abort(status1)]

[h,if(whichHealPower == &quot;Lay on Hands&quot;),CODE:
{ 
    [usesPerEnc = max(1, WisBonus)]
    [powerRange = 1]
    [usesTargetSurge = &quot;No&quot;]
};
{};]
    

[h:newLeaderPowerDetails=&quot;{}&quot;]
[h:newLeaderPowerDetails= json.set(newLeaderPowerDetails, &quot;abilityBonus&quot;, abilityBonus, &quot;bonusHPDice&quot;, bonusHPDice, &quot;range&quot;, powerRange, &quot;maxUses&quot;, usesPerEnc, &quot;usesLeft&quot;, usesPerEnc, &quot;usesTargetSurge&quot;, usesTargetSurge)]

[h:LeaderHealing = json.set(LeaderHealing, whichHealPower,  newLeaderPowerDetails)]

[h:propstring=&quot;color=red; fontColor=white; group=2. Encounter; autoExec=true;&quot;]

[h:createMacro(whichHealPower, &quot;[macro(&apos;Process Leader Healing@Lib:4e&apos;):&apos;&quot;+whichHealPower+&quot;&apos;]&quot;, propstring)]

[r:whichHealPower] added/updated.</command>
        <label>Setup Leader Healing</label>
        <group>Combat - Healing</group>
        <sortby>4</sortby>
        <autoExecute>true</autoExecute>
        <includeLabel>false</includeLabel>
        <applyToTokens>false</applyToTokens>
        <fontColorKey>black</fontColorKey>
        <fontSize>1.00em</fontSize>
        <minWidth></minWidth>
        <maxWidth></maxWidth>
        <allowPlayerEdits>false</allowPlayerEdits>
        <toolTip></toolTip>
        <commonMacro>false</commonMacro>
        <compareGroup>true</compareGroup>
        <compareSortPrefix>true</compareSortPrefix>
        <compareCommand>true</compareCommand>
        <compareIncludeLabel>true</compareIncludeLabel>
        <compareAutoExecute>true</compareAutoExecute>
        <compareApplyToSelectedTokens>true</compareApplyToSelectedTokens>
      </net.rptools.maptool.model.MacroButtonProperties>
    </entry>
    <entry>
      <int>78</int>
      <net.rptools.maptool.model.MacroButtonProperties>
        <saveLocation>Token</saveLocation>
        <index>78</index>
        <colorKey>default</colorKey>
        <hotKey>None</hotKey>
        <command>&lt;!--List of Marking abilities--&gt;
[h:realMarks = getLibProperty(&quot;TrueMarks&quot;)]
[h:attAdjust = getLibProperty(&quot;AttAdjustments&quot;)]
[h:defAdjust = getLibProperty(&quot;DefAdjustments&quot;)]
[h:rvAdjust =getLibProperty(&quot;RVAdjusts&quot;)]

&lt;!--Get Conditions and Ongoing Damage Properties from the token--&gt;
[h:allMyConditions = getProperty(&quot;ExternalTiming&quot;)]
[h:allMyOngoingDamage = getProperty(&quot;OngoingDamage&quot;)]

&lt;!--Create lists from the JSON objects to use in the input() dialog--&gt;
[h:allMyCondList = listSort(json.fields(allMyConditions), &quot;A+&quot;)]
[h:allMyODList = listSort(json.fields(allMyOngoingDamage), &quot;A+&quot;)]

&lt;!--Create a full list of all conditions so the user can see what they&apos;re currently suffering from--&gt;
[h:fullList = if(allMyCondList != &quot;&quot; || allMyODList != &quot;&quot;, allMyCondList+if(allMyODList !=&quot;&quot;, &quot; / &quot;, &quot;&quot;)+allMyODList, &quot;No current conditions&quot;)]

&lt;!--Insert &quot;Do Not Removes&quot; so that the user doesn&apos;t have to remove a condition if they don&apos;t want to--&gt;
[h:AllMyCondList = listInsert(allMyCondList, 0, &quot;Do Not Remove Any Conditions&quot;)]
[h:AllMyCondList = listAppend(allMyCondList, &quot;Remove All Conditions&quot;)]
[h:AllMyODList = listInsert(allMyODList, 0, &quot;Do Not Remove Any Ongoing Damage&quot;)]
[h:AllMyODList = listAppend(allMyODList, &quot;Remove All Ongoing Damage&quot;)]
[h:defAdjust=&quot;DefenseBonus,DefensePenalty&quot;]

&lt;!--Input dialog--&gt;
[h:status=input(
&quot;junk|&quot;+fullList+&quot;|Current Conditions|LABEL&quot;,
&quot;clearCond|&quot;+AllMyCondList+&quot;|Remove which condition?|LIST|SELECT=0 VALUE=STRING&quot;,
&quot;clearOD|&quot;+AllMyODList+&quot;|Remove which ongoing damage condition?|LIST|SELECT=0 VALUE=STRING&quot;)]
[h:abort(status)]


[switch(clearCond),CODE:
case &quot;Do Not Remove Any Conditions&quot;: { };
case &quot;Remove All Conditions&quot;:
{
   [h:currConds = json.fields(ExternalTiming)]
   [h,foreach(condition,currConds),CODE:
   {
   [h,if(condition == &quot;SecondWindBonus&quot;): restoreDefenses(&quot;SecondWindBonus&quot;)]
   [h,if(listFind(defAdjust,condition)!=-1): restoreDefenses(condition)]
   [h,if(listFind(attAdjust,condition)!=-1): restoreAttacks(condition)]
   [h:ExternalTiming = json.remove(ExternalTiming, condition)]
   [h,if(listFind(realMarks,condition)!=-1): MarkedBy = &quot;&quot;; MarkedBy = MarkedBy]
   [h,if(listFind(rvAdjust,condition)!=-1):restoreRV(condition)]
   [h:setState(condition, 0)]
   }]
   [r:currConds] conditions removed.
};
default: 
{
   [h,if(clearCond == &quot;SecondWindBonus&quot;): restoreDefenses(&quot;SecondWindBonus&quot;)]
   [h,if(listFind(defAdjust,clearCond)!=-1): restoreDefenses(clearCond)]
   [h,if(listFind(attAdjust,clearCond)!=-1): restoreAttacks(clearCond)]
   [h:ExternalTiming = json.remove(ExternalTiming, clearCond)]
   [h,if(listFind(realMarks,clearCond)!=-1): MarkedBy = &quot;&quot;; MarkedBy = MarkedBy]
   [h,if(listFind(rvAdjust, clearCond)!=-1):restoreRV(clearCond)]
   [h:setState(clearCond, 0)]
   [r:clearCond] condition removed.
};]

[h,switch(clearOD),CODE:
case &quot;Do Not Remove Any Ongoing Damage&quot;: {};
case &quot;Remove All Ongoing Damage&quot;:
{
   [currOD = json.fields(OngoingDamage)]
   [h,foreach(damage,currOD): OngoingDamage = json.remove(OngoingDamage, damage)]
   [h,foreach(damage,currOD): setState(damage, 0)]
   Ongoing [r,foreach(damage,currOD): substring(damage,7)] damage conditions removed.
};
default:
{
   [OngoingDamage = json.remove(OngoingDamage, clearOD)]
   [setState(clearOD, 0)]
};]</command>
        <label>Clear Conditions</label>
        <group>Conditions</group>
        <sortby></sortby>
        <autoExecute>true</autoExecute>
        <includeLabel>false</includeLabel>
        <applyToTokens>false</applyToTokens>
        <fontColorKey>black</fontColorKey>
        <fontSize>1.00em</fontSize>
        <minWidth></minWidth>
        <maxWidth></maxWidth>
        <allowPlayerEdits>false</allowPlayerEdits>
        <toolTip></toolTip>
        <commonMacro>false</commonMacro>
        <compareGroup>true</compareGroup>
        <compareSortPrefix>true</compareSortPrefix>
        <compareCommand>true</compareCommand>
        <compareIncludeLabel>true</compareIncludeLabel>
        <compareAutoExecute>true</compareAutoExecute>
        <compareApplyToSelectedTokens>true</compareApplyToSelectedTokens>
      </net.rptools.maptool.model.MacroButtonProperties>
    </entry>
    <entry>
      <int>79</int>
      <net.rptools.maptool.model.MacroButtonProperties>
        <saveLocation>Token</saveLocation>
        <index>79</index>
        <colorKey>default</colorKey>
        <hotKey>None</hotKey>
        <command>[h:debugmode=getLibProperty(&apos;debugmode&apos;)]
[h:debugmacro=getMacroName()]
[h,if(argCount() &gt; 0):turnEnd = arg(0); turnEnd = 0]
[h:me = getName()]
[h:ogDmg = getProperty(&quot;OngoingDamage&quot;)]
[h:allMyConditions = getProperty(&quot;ExternalTiming&quot;)]
[h:allMyOngoingDamage = getProperty(&quot;OngoingDamage&quot;)]
[h:allMyODList = json.fields(allMyOngoingDamage)]
[h:allMyConditionList = json.fields(allMyConditions)]
[h:seList = &quot;&quot;]
[h:saveBonusList = &quot;&quot;]
[h:saveBonuses=getProperty(&quot;SaveBonusReminders&quot;)]
[h:saveMods = json.fields(saveBonuses)]
[h:defAdjust = getLibProperty(&quot;DefAdjustments&quot;)]
[h:attAdjust = getLibProperty(&quot;AttAdjustments&quot;)]
[h:rvAdjust = getLibProperty(&quot;RVAdjusts&quot;)]
[h:realMarks = getLibProperty(&quot;TrueMarks&quot;)]

[h,foreach(item,saveMods),CODE:
{
   [spec=json.get(saveBonuses, item)]
   [if(spec!=0): saveBonusList = listAppend(saveBonusList, spec)]
}]
[h,foreach(condition, allMyConditionList),CODE:
{
  [condInfo = json.get(allMyConditions, condition)]
  [expires = json.get(condInfo,&quot;expires&quot;)]
  [if(expires == &quot;Save Ends&quot;): seList = listAppend(seList, condition)]
}]

[h,foreach(condition, allMyODList),CODE:
{
  [condInfo = json.get(allMyOngoingDamage, condition)]
  [expires = json.get(condInfo,&quot;expires&quot;)]
  [if(expires == &quot;Save Ends&quot;): seList = listAppend(seList, condition)]
}]

[h,if(seList == &quot;&quot; &amp;&amp; turnEnd == 0),CODE:
{
[h:status1=input(
&quot;junk|General Saving Throw|-|LABEL|SPAN=TRUE&quot;,
&quot;saveMod|0|Enter bonus/penalty to save (if any)&quot;,
&quot;deathSave|0|This is a Death Save|CHECK&quot;,
&quot;.|&quot;+if(saveBonusList != &quot;&quot;, saveBonusList, &quot;None&quot;)+&quot;|&lt;html&gt;&lt;b&gt;Bonuses to specific saving throws&lt;/b&gt;&lt;/html&gt;|LABEL&quot;)]
[h:abort(status1)]
[h:saved20 = 1d20]
[h:saveRoll=saved20+saveMod]
[h:saveBD = saved20+&quot;+&quot;+saveMod]
[displaySave(saveRoll, &quot;&quot;, token.name, deathSave, saveBD)]
};{};]

[foreach(condition, seList, &quot;&quot;),CODE:
{
[h:assert(seList != &quot;&quot;, &quot;There are no conditions for you to save against&quot;, 0)]
[h:status2=input(
&quot;saveAgainst|&quot;+seList+&quot;|Save against which condition?|LIST|SELECT=0 VALUE=STRING&quot;,
&quot;saveMod|0|Save penalty or bonuses&quot;,
&quot;.|&quot;+if(saveBonusList != &quot;&quot;, saveBonusList, &quot;None&quot;)+&quot;|&lt;html&gt;&lt;b&gt;Bonuses to specific saving throws&lt;/b&gt;&lt;/html&gt;|LABEL&quot;)]
[h:abort(status2)]
[h:saved20 = 1d20]
[h:saveRoll = saved20+saveMod]
[if(saveRoll &gt;= 10),CODE:
   {
       [h:saveBreakdown = saved20+&quot;+&quot;+saveMod]
       [h,if(debugmode):debug(&quot;saveAgainst&quot;,&quot;allMyConditionList&quot;)]
       [h:setState(saveAgainst, 0)]
       [h:OngoingDamage = json.remove(OngoingDamage, saveAgainst)]
       [h:ExternalTiming = json.remove(ExternalTiming, saveAgainst)]   
       [h,if(debugmode): debug(&quot;saveAgainst&quot;,&quot;ExternalTiming&quot;)]
       [h,if(listFind(defAdjust, saveAgainst) != -1): restoreDefenses(saveAgainst)]
       [h,if(listFind(attAdjust, saveAgainst) != -1): restoreAttacks()]
       [h,if(listFind(rvAdjust,saveAgainst) != -1): restoreRV(saveAgainst)]
       [h,if(listFind(realMarks,saveAgainst) != -1): MarkedBy = &quot;&quot;; MarkedBy = MarkedBy]
       [h:seList = listDelete(seList, listFind(seList, saveAgainst))]
       [r:displaySave(saveRoll, saveAgainst, token.name, &quot;&quot;, saveBreakdown)]
   };
   {
        [h:saveBreakdown = saved20+&quot;+&quot;+saveMod]
        [h:setState(saveAgainst,1)]
        [h:seList = listDelete(seList, listFind(seList, saveAgainst))]
        [r:displaySave(saveRoll, saveAgainst, token.name, &quot;&quot;,saveBreakdown)]   
    };]
}]</command>
        <label>Saving Throw</label>
        <group>Conditions</group>
        <sortby></sortby>
        <autoExecute>true</autoExecute>
        <includeLabel>false</includeLabel>
        <applyToTokens>false</applyToTokens>
        <fontColorKey>black</fontColorKey>
        <fontSize>1.00em</fontSize>
        <minWidth></minWidth>
        <maxWidth></maxWidth>
        <allowPlayerEdits>false</allowPlayerEdits>
        <toolTip></toolTip>
        <commonMacro>false</commonMacro>
        <compareGroup>true</compareGroup>
        <compareSortPrefix>true</compareSortPrefix>
        <compareCommand>true</compareCommand>
        <compareIncludeLabel>true</compareIncludeLabel>
        <compareAutoExecute>true</compareAutoExecute>
        <compareApplyToSelectedTokens>true</compareApplyToSelectedTokens>
      </net.rptools.maptool.model.MacroButtonProperties>
    </entry>
    <entry>
      <int>75</int>
      <net.rptools.maptool.model.MacroButtonProperties>
        <saveLocation>Token</saveLocation>
        <index>75</index>
        <colorKey>default</colorKey>
        <hotKey>None</hotKey>
        <command>[h:debug.numArgs = argCount()]
[h:debug.Input = &quot;.|&lt;html&gt;&lt;table&gt;%{debug.TableContent}&lt;/table&gt;&lt;/html&gt;|Debugger|LABEL|SPAN=TRUE&quot;]

[h:debug.Row = &quot;&lt;tr&gt;&lt;td&gt;&lt;b&gt;%{debug.varName}&lt;/b&gt;&lt;/td&gt;&lt;td&gt;%{debug.varValue}&lt;/td&gt;&lt;/tr&gt;&quot;]

[h:debug.Header = &quot;&lt;tr&gt;&lt;td&gt;&lt;b&gt;Variable&lt;/b&gt;&lt;/td&gt;&lt;td&gt;&lt;b&gt;Value&lt;/b&gt;&lt;/td&gt;&lt;/tr&gt;&quot; ]
[h:debug.TableContent = &quot;&quot;]
[h,count(debug.numArgs,&quot;&lt;br&gt;&quot;),CODE:
{
  [debug.varName = arg(roll.count)]
  [debug.varValue = eval(arg(roll.count))]
  [debug.TableContent = debug.TableContent+strformat(debug.Row)]
}]

[h:debug.TableContent = debug.Header+debug.TableContent]

[h:debug.Break = input(strformat(debug.Input))]
[h:abort(debug.Break)]</command>
        <label>debugDialog</label>
        <group>User-Defined Functions</group>
        <sortby></sortby>
        <autoExecute>true</autoExecute>
        <includeLabel>false</includeLabel>
        <applyToTokens>false</applyToTokens>
        <fontColorKey>black</fontColorKey>
        <fontSize>1.00em</fontSize>
        <minWidth></minWidth>
        <maxWidth></maxWidth>
        <allowPlayerEdits>false</allowPlayerEdits>
        <toolTip></toolTip>
        <commonMacro>false</commonMacro>
        <compareGroup>true</compareGroup>
        <compareSortPrefix>true</compareSortPrefix>
        <compareCommand>true</compareCommand>
        <compareIncludeLabel>true</compareIncludeLabel>
        <compareAutoExecute>true</compareAutoExecute>
        <compareApplyToSelectedTokens>true</compareApplyToSelectedTokens>
      </net.rptools.maptool.model.MacroButtonProperties>
    </entry>
    <entry>
      <int>85</int>
      <net.rptools.maptool.model.MacroButtonProperties>
        <saveLocation>Token</saveLocation>
        <index>85</index>
        <colorKey>default</colorKey>
        <hotKey>None</hotKey>
        <command>[h,if(argCount() != 1): assert(0, &quot;varsFromJSON() requires exactly one argument&quot;, 0); jsonObject = arg(0)]

[h:varList=json.fields(jsonObject)]

[h,foreach(var,varList),CODE:
{
     [value = json.get(jsonObject,var)]
     [set(var,value)]
}]
</command>
        <label>varsFromJSON</label>
        <group>User-Defined Functions</group>
        <sortby></sortby>
        <autoExecute>true</autoExecute>
        <includeLabel>false</includeLabel>
        <applyToTokens>false</applyToTokens>
        <fontColorKey>black</fontColorKey>
        <fontSize>1.00em</fontSize>
        <minWidth></minWidth>
        <maxWidth></maxWidth>
        <allowPlayerEdits>false</allowPlayerEdits>
        <toolTip></toolTip>
        <commonMacro>false</commonMacro>
        <compareGroup>true</compareGroup>
        <compareSortPrefix>true</compareSortPrefix>
        <compareCommand>true</compareCommand>
        <compareIncludeLabel>true</compareIncludeLabel>
        <compareAutoExecute>true</compareAutoExecute>
        <compareApplyToSelectedTokens>true</compareApplyToSelectedTokens>
      </net.rptools.maptool.model.MacroButtonProperties>
    </entry>
    <entry>
      <int>84</int>
      <net.rptools.maptool.model.MacroButtonProperties>
        <saveLocation>Token</saveLocation>
        <index>84</index>
        <colorKey>default</colorKey>
        <hotKey>None</hotKey>
        <command>[h:debugmode = getLibProperty(&quot;DEBUGMODE&quot;)]
[h:debugmacro = getMacroName()]
[h:SelectedEnemy = arg(0)]
[h:thisEnemy = json.get(procStateData, SelectedEnemy)]
[h:stateInfo = json.get(thisEnemy, &quot;StateList&quot;)]
[h:imposedBy = json.get(thisEnemy, &quot;tokenName&quot;)]
[h:event = json.get(thisEnemy, &quot;hit&quot;)]
[h:start = getInitiativeRound()]
[h,if(debugmode): debug(&quot;SelectedEnemy&quot;, &quot;thisEnemy&quot;, &quot;imposedBy&quot;, &quot;stateInfo&quot;, &quot;event&quot;)]

[h:imposedStatesList = json.fields(stateInfo)]
[h:switchToken(SelectedEnemy)]
[h:realMarks = getLibProperty(&quot;TrueMarks&quot;)]
[h:promptForDef =getLibProperty(&quot;DefAdjustments&quot;)]
[h:promptForAtt = getLibProperty(&quot;AttAdjustments&quot;)]
[h:resAdjust=getLibProperty(&quot;RAdjusts&quot;)]
[h:vlnAdjust=getLibProperty(&quot;VAdjusts&quot;)]

[h,foreach(state,imposedStatesList),CODE:
{
      [if(length(state) &gt; 4 &amp;&amp; substring(state, 0, 4)==&quot;Ongo&quot;),CODE:
        {
            [stateDetails = json.get(stateInfo, state)]
                        [stateExpires = json.get(stateDetails, &quot;expires&quot;)]
            [if(stateExpires ==&quot;End of Target&apos;s Next Turn&quot; || stateExpires==&quot;Beginning of Target&apos;s Next Turn&quot;): stateImposedBy = SelectedEnemy; stateImposedBy = imposedBy]
            [dmgAmount = json.get(stateDetails, &quot;ogDamAmt&quot;)]     
            [newStateObj = json.set(&quot;{}&quot;, &quot;imposedBy&quot;, stateImposedBy, &quot;expires&quot;, stateExpires, &quot;start&quot;, start, &quot;ogDamAmt&quot;, dmgAmount)]
            [OngoingDamage = json.set(OngoingDamage, state, newStateObj)]
            [setState(state,1)]
       };
      {
            [if(listFind(promptForDef, state) != -1): procDefBonus()]
            [if(listFind(promptForAtt, state) != -1): procAttBonus()]
            [stateDetails = json.get(stateInfo, state)]
            [stateExpires = json.get(stateDetails, &quot;expires&quot;)]
             [if(stateExpires ==&quot;End of Target&apos;s Next Turn&quot; || stateExpires==&quot;Beginning of Target&apos;s Next Turn&quot;): stateImposedBy = SelectedEnemy; stateImposedBy = imposedBy]
            [dmgAmount = json.get(stateDetails, &quot;ogDamAmt&quot;)]
            [newStateObj = json.set(&quot;{}&quot;, &quot;imposedBy&quot;, stateImposedBy, &quot;expires&quot;, stateExpires, &quot;start&quot;, start, &quot;ogDamAmt&quot;, dmgAmount)]
            [ExternalTiming = json.set(ExternalTiming, state, newStateObj)]
            [setState(state,1)]
            [if(listFind(realMarks, state) != -1): MarkedBy = imposedBy; MarkedBy = MarkedBy]
            [if(listFind(resAdjust,state) != -1): procTempResist(state,dmgAmount)]
            [if(listFind(vlnAdjust,state)!=-1):procTempVulnerable(state,dmgAmount)]
      };]
}]</command>
        <label>procStates</label>
        <group>User-Defined Functions</group>
        <sortby></sortby>
        <autoExecute>true</autoExecute>
        <includeLabel>false</includeLabel>
        <applyToTokens>false</applyToTokens>
        <fontColorKey>black</fontColorKey>
        <fontSize>1.00em</fontSize>
        <minWidth></minWidth>
        <maxWidth></maxWidth>
        <allowPlayerEdits>false</allowPlayerEdits>
        <toolTip></toolTip>
        <commonMacro>false</commonMacro>
        <compareGroup>true</compareGroup>
        <compareSortPrefix>true</compareSortPrefix>
        <compareCommand>true</compareCommand>
        <compareIncludeLabel>true</compareIncludeLabel>
        <compareAutoExecute>true</compareAutoExecute>
        <compareApplyToSelectedTokens>true</compareApplyToSelectedTokens>
      </net.rptools.maptool.model.MacroButtonProperties>
    </entry>
    <entry>
      <int>86</int>
      <net.rptools.maptool.model.MacroButtonProperties>
        <saveLocation>Token</saveLocation>
        <index>86</index>
        <colorKey>default</colorKey>
        <hotKey>None</hotKey>
        <command>&lt;!--Determine the Condition Responsible for the Adjustment to the Defenses--&gt;
[h:defAdjSource = arg(0)]

&lt;!--If Second Wind is the source, simply adjust all defenses downward by 2, otherwise--&gt;
&lt;!--retrieve the last adjustment to defenses and compensate for it--&gt;

[h,if(defAdjSource == &quot;SecondWindBonus&quot;),CODE:
{
   [h:AC = AC - 2]
   [h:Fortitude = Fortitude - 2]
   [h:Reflex = Reflex - 2]
   [h:Will = Will - 2]
};
{
   [lastAdjustment = getProperty(&quot;LastDefenseAdjustment&quot;)]
   [adjAmount = json.get(lastAdjustment, &quot;adjustment&quot;)]
   [adjDefs = json.get(lastAdjustment, &quot;defense&quot;)]
   [if(adjDefs == &quot;All Defenses&quot;): adjDefs = &quot;AC,Fortitude,Reflex,Will&quot;]
   [foreach(def,adjDefs),CODE:
   {
         [defVal = getProperty(def)]
         [newDefVal = defVal + (0 - adjAmount)]
         [setProperty(def, newDefVal)]
   }]
   [h:setProperty(&quot;LastDefenseAdjustment&quot;, json.set(&quot;{}&quot;, &quot;Defense&quot;,&quot;AC&quot;,&quot;adjustment&quot;, 0))]
};]</command>
        <label>restoreDefenses</label>
        <group>User-Defined Functions</group>
        <sortby></sortby>
        <autoExecute>true</autoExecute>
        <includeLabel>false</includeLabel>
        <applyToTokens>false</applyToTokens>
        <fontColorKey>black</fontColorKey>
        <fontSize>1.00em</fontSize>
        <minWidth></minWidth>
        <maxWidth></maxWidth>
        <allowPlayerEdits>false</allowPlayerEdits>
        <toolTip></toolTip>
        <commonMacro>false</commonMacro>
        <compareGroup>true</compareGroup>
        <compareSortPrefix>true</compareSortPrefix>
        <compareCommand>true</compareCommand>
        <compareIncludeLabel>true</compareIncludeLabel>
        <compareAutoExecute>true</compareAutoExecute>
        <compareApplyToSelectedTokens>true</compareApplyToSelectedTokens>
      </net.rptools.maptool.model.MacroButtonProperties>
    </entry>
    <entry>
      <int>81</int>
      <net.rptools.maptool.model.MacroButtonProperties>
        <saveLocation>Token</saveLocation>
        <index>81</index>
        <colorKey>default</colorKey>
        <hotKey>None</hotKey>
        <command>[h:me=getName()]
[h:currentDamageInfo = &quot;{}&quot;]
[h:calledByPC=isPC(me)]
[h,if(calledByPC):expList=json.toList(getTokenNames(&quot;json&quot;, &apos;{npc:true, unsetStates:[&quot;Dead&quot;],  visible:true}&apos;)); expList=json.toList(getTokenNames(&quot;json&quot;,  &apos;{pc:true, unsetStates:[&quot;Dead&quot;],  visible:true}&apos;))]

[H: imgList = expList]
[H: Num = listCount(imgList)]

[h,COUNT(Num),CODE:
{
[h:targetName=listGet(imgList,roll.count)]
[h,token(targetName): image=getTokenImage()]
[h:imgList=listReplace(imgList,roll.count,targetName+&quot; &quot;+image)]
}]

[h:status=input(
		&quot;targetNum|&quot;+imgList+&quot;|Select Target|LIST|SELECT=0 ICON=TRUE ICONSIZE=30&quot;,
		&quot;feature|Hunter&apos;s Quarry, Sneak Attack, Warlock&apos;s Curse,Other|Type of Striker Damage|LIST|SELECT=0 VALUE=STRING&quot;,
		&quot;CQSDice|1d6,1d8,2d6,2d8,3d6,3d8|Extra Damage Dice|LIST|SELECT=0 VALUE=STRING&quot;,
		&quot;dBonus|0|Bonus damage if any (e.g. Brutal Scoundrel sneak attack bonus)&quot;,
		&quot;critAttack|0|Was the attack a critical hit?|CHECK&quot;
		)
]

[h:abort(status)]

[h: CQSCrit=number(substring(CQSDice,0,1)) * number(substring(CQSDice,2)) ]

[h:target=listGet(expList,targetNum)]
[h:dmg=if(critattack,CQSCrit,eval(CQSDice))+dBonus]
[h:strikerDamage=json.set(&quot;{}&quot;, &quot;target&quot;, target, &quot;damage&quot;, dmg, &quot;damtype&quot;, &quot;untyped, untyped, untyped&quot;, &quot;atktype&quot;, &quot;melee&quot;)]
[h:currentDamageInfo = json.set(currentDamageInfo, target, strikerDamage)]
[r:feature] deals an additional [dmg] damage to [r:target]



[h:striker=me]

[h,SWITCH(feature),CODE:
case &quot;Hunter&apos;s Quarry&quot;: {
		[h,token(striker): state.Quarry_Damage_Used=1]
		};
case &quot;Sneak Attack&quot;:{
		[h,token(striker): state.Sneak_Attack_Used=1]
		};
case &quot;Warlock&apos;s Curse&quot;:{
		[h,token(striker): state.Curse_Damage_Used=1]
		};]



[r:procDamage(target)]</command>
        <label>Striker Damage</label>
        <group>Combat - Damage</group>
        <sortby></sortby>
        <autoExecute>true</autoExecute>
        <includeLabel>false</includeLabel>
        <applyToTokens>false</applyToTokens>
        <fontColorKey>black</fontColorKey>
        <fontSize>1.00em</fontSize>
        <minWidth></minWidth>
        <maxWidth></maxWidth>
        <allowPlayerEdits>false</allowPlayerEdits>
        <toolTip></toolTip>
        <commonMacro>false</commonMacro>
        <compareGroup>true</compareGroup>
        <compareSortPrefix>true</compareSortPrefix>
        <compareCommand>true</compareCommand>
        <compareIncludeLabel>true</compareIncludeLabel>
        <compareAutoExecute>true</compareAutoExecute>
        <compareApplyToSelectedTokens>true</compareApplyToSelectedTokens>
      </net.rptools.maptool.model.MacroButtonProperties>
    </entry>
    <entry>
      <int>80</int>
      <net.rptools.maptool.model.MacroButtonProperties>
        <saveLocation>Token</saveLocation>
        <index>80</index>
        <colorKey>default</colorKey>
        <hotKey>None</hotKey>
        <command>[h:status=input(
&quot;dmgAmount|0|Amount of damage taken&quot;,
&quot;dmgType|untyped,acid,cold,fire,force,lightning,necrotic,poison,psychic,radiant,thunder|Damage Type|LIST|SELECT=0 VALUE=STRING&quot;,
&quot;atkType|melee, ranged, close, area|Attack type (use melee as default)|LIST|SELECT=0 VALUE=STRING&quot;)]
[h:abort(status)]

[h:dmgType = dmgType+&quot;, untyped, untyped&quot;]
[h:damageInfo=json.set(&quot;{}&quot;, getName(), json.set(&quot;{}&quot;, &quot;damage&quot;, dmgAmount, &quot;damtype&quot;, dmgType, &quot;atktype&quot;, atkType, &quot;target&quot;, token.name))]
[h:setProperty(&quot;currentDamageInfo&quot;, damageInfo)]

[macro(&quot;Damage@this&quot;):&quot;&quot;]</command>
        <label>General Damage</label>
        <group>Combat - Damage</group>
        <sortby></sortby>
        <autoExecute>true</autoExecute>
        <includeLabel>false</includeLabel>
        <applyToTokens>false</applyToTokens>
        <fontColorKey>black</fontColorKey>
        <fontSize>1.00em</fontSize>
        <minWidth></minWidth>
        <maxWidth></maxWidth>
        <allowPlayerEdits>false</allowPlayerEdits>
        <toolTip></toolTip>
        <commonMacro>false</commonMacro>
        <compareGroup>true</compareGroup>
        <compareSortPrefix>true</compareSortPrefix>
        <compareCommand>true</compareCommand>
        <compareIncludeLabel>true</compareIncludeLabel>
        <compareAutoExecute>true</compareAutoExecute>
        <compareApplyToSelectedTokens>true</compareApplyToSelectedTokens>
      </net.rptools.maptool.model.MacroButtonProperties>
    </entry>
    <entry>
      <int>83</int>
      <net.rptools.maptool.model.MacroButtonProperties>
        <saveLocation>Token</saveLocation>
        <index>83</index>
        <colorKey>default</colorKey>
        <hotKey>None</hotKey>
        <command>[h:defineFunction(&quot;procDamage&quot;, &quot;Damage@Lib:4e&quot;)]
[h:defineFunction(&quot;procHealing&quot;, &quot;Healing@Lib:4e&quot;)]
[h:defineFunction(&quot;procStates&quot;, &quot;procStates@Lib:4e&quot;)]
[h:defineFunction(&quot;varsFromJSON&quot;, &quot;varsFromJSON@Lib:4e&quot;, 0, 0)]
[h:defineFunction(&quot;debug&quot;, &quot;debugDialog@Lib:4e&quot;, 0, 0)]
[h:defineFunction(&quot;displaySave&quot;, &quot;displaySave@Lib:4e&quot;)]
[h:defineFunction(&quot;restoreDefenses&quot;, &quot;restoreDefenses@Lib:4e&quot;)]
[h:defineFunction(&quot;restoreAttacks&quot;, &quot;restoreAttacks@this&quot;)]
[h:defineFunction(&quot;duplicatePower&quot;, &quot;Duplicate Power@&quot;+getMacroLocation())]
[h:defineFunction(&quot;rangeError&quot;, &quot;rangeError@&quot;+getMacroLocation())]
[h:defineFunction(&quot;outputTo&quot;, &quot;outputTo@this&quot;)]
[h:defineFunction(&quot;procMarks&quot;, &quot;Marks and Quarries@this&quot;)]
[h:defineFunction(&quot;varyCA&quot;, &quot;Varying CA@this&quot;)]
[h:defineFunction(&quot;varyCover&quot;, &quot;Varying Cover@this&quot;)]
[h:defineFunction(&quot;extractDice&quot;, &quot;extractDice@this&quot;)]
[h:defineFunction(&quot;procDefBonus&quot;, &quot;procDefBonus@this&quot;)]
[h:defineFunction(&quot;procAttBonus&quot;, &quot;procAttBonus@this&quot;)]
[h:defineFunction(&quot;launchPower&quot;, &quot;launchPower@this&quot;)]
[h:defineFunction(&quot;savingThrow&quot;, &quot;Saving Throw@this&quot;)]
[h:defineFunction(&quot;cycleTurn&quot;, &quot;cycleTurn@this&quot;)]
[h:defineFunction(&quot;trimNumber&quot;, &quot;trimNumber@this&quot;, 1)]
[h:defineFunction(&quot;procTempResist&quot;, &quot;procTempResist@this&quot;)]
[h:defineFunction(&quot;procTempVulnerable&quot;, &quot;procTempVulnerable@this&quot;)]
[h:defineFunction(&quot;restoreRV&quot;, &quot;restoreRV@this&quot;)]
[h:defineFunction(&quot;advanceInit&quot;, &quot;advanceInit@this&quot;)]
[h:defineFunction(&quot;calcAOE&quot;, &quot;calcAOE@this&quot;)]
[h:defineFunction(&quot;rollTwice&quot;, &quot;rollTwice@this&quot;)]
[h:defineFunction(&quot;updateStats&quot;, &quot;updateStats@this&quot;)]
[h:defineFunction(&quot;getP&quot;, &quot;getp@this&quot;)]
[h:defineFunction(&quot;hasP&quot;,&quot;hasp@this&quot;)]
[h:defineFunction(&quot;setP&quot;,&quot;setp@this&quot;)]
[h:defineFunction(&quot;processAttack&quot;, &quot;Process Attack@this&quot;)]
[h:defineFunction(&quot;hitResolver&quot;, &quot;Hit Resolver@this&quot;)]
[h:defineFunction(&quot;createTooltip&quot;, &quot;createTooltip@this&quot;)]
[h:defineFunction(&quot;checkTwoTargets&quot;,&quot;checkTwoTargets@this&quot;)]</command>
        <label>onCampaignLoad</label>
        <group>User-Defined Functions</group>
        <sortby></sortby>
        <autoExecute>true</autoExecute>
        <includeLabel>false</includeLabel>
        <applyToTokens>false</applyToTokens>
        <fontColorKey>black</fontColorKey>
        <fontSize>1.00em</fontSize>
        <minWidth></minWidth>
        <maxWidth></maxWidth>
        <allowPlayerEdits>false</allowPlayerEdits>
        <toolTip></toolTip>
        <commonMacro>false</commonMacro>
        <compareGroup>true</compareGroup>
        <compareSortPrefix>true</compareSortPrefix>
        <compareCommand>true</compareCommand>
        <compareIncludeLabel>true</compareIncludeLabel>
        <compareAutoExecute>true</compareAutoExecute>
        <compareApplyToSelectedTokens>true</compareApplyToSelectedTokens>
      </net.rptools.maptool.model.MacroButtonProperties>
    </entry>
    <entry>
      <int>82</int>
      <net.rptools.maptool.model.MacroButtonProperties>
        <saveLocation>Token</saveLocation>
        <index>82</index>
        <colorKey>default</colorKey>
        <hotKey>None</hotKey>
        <command>[h:saveResult = arg(0)]
[h:saveAgainst = arg(1)]
[h:character = arg(2)]
[h:deathSave = arg(3)]
[h:saveBD = arg(4)]
[h,if(deathSave == 1),CODE:
{
    [if(saveResult &lt; 10): result = &quot;&lt;html&gt;&lt;b&gt;Death Save result&lt;/b&gt;: &lt;span  bgcolor=&apos;#dcdcdc&apos; title=&apos;&quot;+saveBD+&quot;&apos;&gt;&quot; +saveResult+&quot;&lt;/span&gt;. &quot;+token.name+&quot; fails a Death Save, and moves one step closer to death.&lt;/html&gt;&quot;]
    [if(saveResult &gt;=10 &amp;&amp; saveResult &lt; 20): result = &quot;&lt;html&gt;&lt;b&gt;Death Save result&lt;/b&gt;: &lt;span  bgcolor=&apos;#dcdcdc&apos; title=&apos;&quot;+saveBD+&quot;&apos;&gt;&quot;+saveResult+&quot;&lt;/span&gt;. &quot;+token.name+&quot;&apos;s condition does not change.&lt;/html&gt;&quot;]
    [if(saveResult &gt;= 20): result = &quot;&lt;html&gt;&lt;b&gt;Death Save result&lt;/b&gt;: &lt;span  bgcolor=&apos;#dcdcdc&apos; title=&apos;&quot;+saveBD+&quot;&apos;&gt;&quot;+saveResult+&quot;&lt;/span&gt;. If &quot;+token.name+&quot; may spend a healing surge, and regain hit points from the surge as if &quot;+token.name+&quot; had 0 hit points. If &quot;+token.name+&quot; does not have any healing surges left, their condition does not change.&lt;/html&gt;&quot;]
};
{
   [h,if(saveResult &lt; 10): result = &quot;&lt;html&gt;&lt;b&gt;Saving Throw:&lt;/b&gt; &lt;span bgcolor=&apos;#dcdcdc&apos; title=&apos;&quot;+saveBD+&quot;&apos;&gt;&quot;+saveResult+&quot;&lt;/span&gt;. &quot;+character+&quot; does not succeed on saving throw&quot;+if(saveAgainst == &quot;&quot;, &quot;.&lt;/html&gt;&quot;, &quot; against &quot;+saveAgainst+&quot;&lt;/html&gt;&quot;); result= &quot;&lt;html&gt;&lt;b&gt;Saving Throw:&lt;/b&gt; &lt;span bgcolor=&apos;#dcdcdc&apos; title=&apos;&quot;+saveBD+&quot;&apos;&gt;&quot;+saveResult+&quot;&lt;/span&gt;. &quot;+character+&quot; succeeds on a saving throw&quot;+if(saveAgainst == &quot;&quot;, &quot;.&lt;/html&gt;&quot;, &quot; against &quot;+saveAgainst+&quot;&lt;/html&gt;&quot;)]
};]

[if(isNPC(character)),CODE:
{
     [outputTo(&quot;gm&quot;, result)]
};
{
     [outputTo(&quot;all&quot;, result)]
}]</command>
        <label>displaySave</label>
        <group>User-Defined Functions</group>
        <sortby></sortby>
        <autoExecute>true</autoExecute>
        <includeLabel>false</includeLabel>
        <applyToTokens>false</applyToTokens>
        <fontColorKey>black</fontColorKey>
        <fontSize>1.00em</fontSize>
        <minWidth></minWidth>
        <maxWidth></maxWidth>
        <allowPlayerEdits>false</allowPlayerEdits>
        <toolTip></toolTip>
        <commonMacro>false</commonMacro>
        <compareGroup>true</compareGroup>
        <compareSortPrefix>true</compareSortPrefix>
        <compareCommand>true</compareCommand>
        <compareIncludeLabel>true</compareIncludeLabel>
        <compareAutoExecute>true</compareAutoExecute>
        <compareApplyToSelectedTokens>true</compareApplyToSelectedTokens>
      </net.rptools.maptool.model.MacroButtonProperties>
    </entry>
    <entry>
      <int>93</int>
      <net.rptools.maptool.model.MacroButtonProperties>
        <saveLocation>Token</saveLocation>
        <index>93</index>
        <colorKey>default</colorKey>
        <hotKey>None</hotKey>
        <command>[h:Init=1d20+Initiative]

[r,if(isPC()),CODE:
{
   Initiative roll: [r:Init].
};
{
    [r:outputTo(&quot;self&quot;, token.name+&quot; initiative roll: &quot;+Init)]
};]

[h:addToInitiative(0,Init)]
[h:sortInitiative()]</command>
        <label>Initiative</label>
        <group>Combat</group>
        <sortby></sortby>
        <autoExecute>true</autoExecute>
        <includeLabel>false</includeLabel>
        <applyToTokens>false</applyToTokens>
        <fontColorKey>black</fontColorKey>
        <fontSize>1.00em</fontSize>
        <minWidth></minWidth>
        <maxWidth></maxWidth>
        <allowPlayerEdits>false</allowPlayerEdits>
        <toolTip></toolTip>
        <commonMacro>false</commonMacro>
        <compareGroup>true</compareGroup>
        <compareSortPrefix>true</compareSortPrefix>
        <compareCommand>true</compareCommand>
        <compareIncludeLabel>true</compareIncludeLabel>
        <compareAutoExecute>true</compareAutoExecute>
        <compareApplyToSelectedTokens>true</compareApplyToSelectedTokens>
      </net.rptools.maptool.model.MacroButtonProperties>
    </entry>
    <entry>
      <int>92</int>
      <net.rptools.maptool.model.MacroButtonProperties>
        <saveLocation>Token</saveLocation>
        <index>92</index>
        <colorKey>default</colorKey>
        <hotKey>None</hotKey>
        <command>[h:input(&quot;.|&lt;html&gt;&lt;b&gt;There are no targets in range&lt;/b&gt;&lt;/html&gt;||LABEL|SPAN=TRUE&quot;)]
[h:returnVal = &quot;&quot;]
[returnVal]</command>
        <label>rangeError</label>
        <group>User-Defined Functions</group>
        <sortby></sortby>
        <autoExecute>true</autoExecute>
        <includeLabel>false</includeLabel>
        <applyToTokens>false</applyToTokens>
        <fontColorKey>black</fontColorKey>
        <fontSize>1.00em</fontSize>
        <minWidth></minWidth>
        <maxWidth></maxWidth>
        <allowPlayerEdits>false</allowPlayerEdits>
        <toolTip></toolTip>
        <commonMacro>false</commonMacro>
        <compareGroup>true</compareGroup>
        <compareSortPrefix>true</compareSortPrefix>
        <compareCommand>true</compareCommand>
        <compareIncludeLabel>true</compareIncludeLabel>
        <compareAutoExecute>true</compareAutoExecute>
        <compareApplyToSelectedTokens>true</compareApplyToSelectedTokens>
      </net.rptools.maptool.model.MacroButtonProperties>
    </entry>
    <entry>
      <int>95</int>
      <net.rptools.maptool.model.MacroButtonProperties>
        <saveLocation>Token</saveLocation>
        <index>95</index>
        <colorKey>default</colorKey>
        <hotKey>None</hotKey>
        <command>[r: json.get(macro.args, &apos;toSend&apos;)]</command>
        <label>conditionalOutput</label>
        <group>User-Defined Functions</group>
        <sortby></sortby>
        <autoExecute>true</autoExecute>
        <includeLabel>false</includeLabel>
        <applyToTokens>false</applyToTokens>
        <fontColorKey>black</fontColorKey>
        <fontSize>1.00em</fontSize>
        <minWidth></minWidth>
        <maxWidth></maxWidth>
        <allowPlayerEdits>false</allowPlayerEdits>
        <toolTip></toolTip>
        <commonMacro>false</commonMacro>
        <compareGroup>true</compareGroup>
        <compareSortPrefix>true</compareSortPrefix>
        <compareCommand>true</compareCommand>
        <compareIncludeLabel>true</compareIncludeLabel>
        <compareAutoExecute>true</compareAutoExecute>
        <compareApplyToSelectedTokens>true</compareApplyToSelectedTokens>
      </net.rptools.maptool.model.MacroButtonProperties>
    </entry>
    <entry>
      <int>94</int>
      <net.rptools.maptool.model.MacroButtonProperties>
        <saveLocation>Token</saveLocation>
        <index>94</index>
        <colorKey>default</colorKey>
        <hotKey>None</hotKey>
        <command>[h: toSend = &apos;{}&apos;]
[h: argTest = json.type(arg(0))]
[h, if(argTest==&apos;ARRAY&apos;), code:
{
    [h: toWho = &apos;list&apos;]
    [h: toSend = json.set(toSend, &apos;mlOutputList&apos;, arg(0))]
};{
    [h: toWho = arg(0)]
}]

[h: toSend = json.set(toSend, &apos;toSend&apos;, arg(1))]
[h: conditionalOutput = macroLinkText(&apos;conditionalOutput@this&apos;, toWho, toSend)]
[h: execLink(conditionalOutput, 1)]</command>
        <label>outputTo</label>
        <group>User-Defined Functions</group>
        <sortby></sortby>
        <autoExecute>true</autoExecute>
        <includeLabel>false</includeLabel>
        <applyToTokens>false</applyToTokens>
        <fontColorKey>black</fontColorKey>
        <fontSize>1.00em</fontSize>
        <minWidth></minWidth>
        <maxWidth></maxWidth>
        <allowPlayerEdits>false</allowPlayerEdits>
        <toolTip></toolTip>
        <commonMacro>false</commonMacro>
        <compareGroup>true</compareGroup>
        <compareSortPrefix>true</compareSortPrefix>
        <compareCommand>true</compareCommand>
        <compareIncludeLabel>true</compareIncludeLabel>
        <compareAutoExecute>true</compareAutoExecute>
        <compareApplyToSelectedTokens>true</compareApplyToSelectedTokens>
      </net.rptools.maptool.model.MacroButtonProperties>
    </entry>
    <entry>
      <int>89</int>
      <net.rptools.maptool.model.MacroButtonProperties>
        <saveLocation>Token</saveLocation>
        <index>89</index>
        <colorKey>default</colorKey>
        <hotKey>None</hotKey>
        <command>[h:powerTemplate=json.set(&quot;{}&quot;, &quot;powername&quot;, &quot;Enter Name&quot;, &quot;level&quot;, 0, &quot;pCategory&quot;, &quot;Attack&quot;, &quot;keywords&quot;, &quot;none&quot;, &quot;action&quot;, &quot;standard&quot;, &quot;usage&quot;, &quot;at-will&quot;, &quot;attackType&quot;, &quot;melee&quot;, &quot;rangeText&quot;, &quot;melee weapon&quot;, &quot;nominalRange&quot;, 1, &quot;maximumRange&quot;, 1, &quot;reliable&quot;, 0, &quot;spellbook&quot;, 0, &quot;rechargeOn&quot;, 0, &quot;attack&quot;, 0, &quot;against&quot;, &quot;AC&quot;, &quot;targets&quot;, &quot;one creature&quot;, &quot;damage&quot;, 0, &quot;critLower&quot;, 20, &quot;critdamage&quot;, 0, &quot;damageType&quot;, &quot;&quot;, &quot;halfDmgOnMiss&quot;, 0, &quot;requirements&quot;, &quot;--none--&quot;, &quot;hitEffect&quot;, &quot;--none--&quot;, &quot;missEffect&quot;, &quot;--none--&quot;, &quot;alwaysEffect&quot;, &quot;--none--&quot;, &quot;appStateHit&quot;, &quot;{}&quot;, &quot;appStateMiss&quot;, &quot;{}&quot;, &quot;appStateAlways&quot;, &quot;{}&quot;, &quot;expended&quot;, &quot;Available&quot;)]

[h,if(isPropertyEmpty(&quot;Powers&quot;) == 1 || json.isEmpty(Powers)==1),CODE:
{
  [powerList = &quot;Add New&quot;]
  [secondaryList = &quot;No Secondary Attack&quot;]
};
{
  [powerList = listSort(json.fields(Powers),&quot;A+&quot;)]
  [secondaryList = listInsert(powerList, 0, &quot;No Secondary Attack&quot;)]
  [powerList = listAppend(powerList, &quot;Add new&quot;)]
};]

[h:stateList=getTokenStates()]
[h:nonPwrStates = &quot;Immed_Reaction_Used,Curse_Damage_Used,Sneak_Attack_Used,Quarry_Damage_Used,AP_Used&quot;]
[h,foreach(state,nonPwrStates): stateList = listDelete(stateList,listFind(stateList,state))]
[h:stateList=listSort(stateList,&quot;A+&quot;)]
[h:stateList=listInsert(stateList,0,&quot;None&quot;)]
[h:damageTypeList = &quot;untyped, acid, cold, fire, force, lightning, necrotic, poison, psychic, radiant, thunder&quot;]
[h:categoryList = &quot;Attack,Feature,Racial,Utility,Item&quot;]
[h:actionList = &quot;standard,minor,move,free,no action,immediate reaction,immediate interrupt&quot;]
[h:usageList = &quot;at-will,encounter,daily,recharge&quot;]
[h:atkTypeList = &quot;melee,ranged,close,area&quot;]
[h:defList = &quot;AC,Fortitude,Reflex,Will&quot;]
[h:targetOptionList = &quot;one creature, one or two creatures, two creatures, one creature two attacks, each creature in burst, each enemy in burst, targets allies, personal&quot;]
[h:expendList = &quot;Available, Expended, Recharged, Must recharge&quot;]
[h:expireList = &quot;,Beginning of Your Next Turn,End of Your Next Turn,Beginning of Target&apos;s Next Turn,End of Target&apos;s Next Turn,End of Encounter,Save Ends,No Save,Special&quot;]

&lt;!--Present an input to select a Power to edit, or to add a new Power--&gt;
[h:status=input(
&quot;whichPower|&quot;+powerList+&quot;|Choose a Power to Edit|LIST|SELECT=0 VALUE=STRING&quot;,
&quot;delete|0|Delete this Power|CHECK&quot;)]
[h:abort(status)]

&lt;!--Delete the Power if the user checks the delete box--&gt;
[if(delete == 1),CODE:
{
    [Powers = json.remove(Powers, whichPower)]
    [macroLabel = whichPower]
    [macIndex = getMacroIndexes(macroLabel)]
    [if(macIndex == &quot;&quot;): assert(0, whichPower+&quot; has been deleted; no macro button to remove.&quot;, 0); removeMacro(macIndex)]
    [assert(0, whichPower+&quot; has been deleted.&quot;, 0)]
};
{};]

&lt;!--Generate the variables for the Power to auto-populate the Power Editing input--&gt;
[h,if(whichPower==&quot;Add New&quot;),CODE:
{  
   [tempToolTip = &quot;&quot;]
   [selectedPower = powerTemplate]
   [varsFromJSON(powerTemplate)]
};
{
   [selectedPower = json.get(Powers, whichPower)]
   [if(json.contains(selectedPower, &quot;spellbook&quot;) == 0): spellbook = 0]
   [macIndex = getMacroIndexes(whichPower)]
   [macroProps = getMacroProps(macIndex, &quot;json&quot;)]
   [if(json.contains(macroProps, &quot;tooltip&quot;)): tempToolTip = json.get(macroProps, &quot;tooltip&quot;); tempToolTip = &quot;&quot;]

   [varsFromJSON(selectedPower)]
};]

&lt;!--if editing an existing power, find the various power details in the lists established earlier, so you can automatically set them in the editing dialog--&gt;
[h:actionSelect = listFind(actionList, action)]
[h:usageSelect = listFind(usageList, usage)]
[h:againstSelect = listFind(defList, against)]
[h:targSelect = listFind(targetOptionList, targets)]
[h:atktypeSelect = listFind(atkTypeList, attackType)]
[h:expSelect = listFind(expendList, expended)]
[h:catSelect = listFind(categoryList, pCategory)]

[h,switch(usageSelect):
case 0: bgColor = &quot;#006600&quot;;
case 1: bgColor = &quot;#990000&quot;;
case 2: bgColor = &quot;black&quot;;
case 3: bgColor = &quot;blue&quot;;
default: bgColor = &quot;green&quot;;]

&lt;!--To auto-populate the proper damage types, if a power has one or more damage types, cycle through each one listed and find their positions in the damage type list--&gt;
[h,if(damageType != &quot;&quot;),CODE:
{
    [count(3),CODE:
    {
        [damTypeName = listGet(damageType,roll.count)]
        [damListLoc = if(damTypeName != &quot;&quot;, listFind(damageTypeList,damTypeName), 0)]
        [set(&quot;damTypeSelect&quot;+roll.count,damListLoc)]
     }]
};
{
    [count(3): set(&quot;damTypeSelect&quot;+roll.count,0)]
};]

&lt;!--Go through the nested JSON object containing the states to apply, their durations, and their damage amount (if any). A power can impose 4 possible states, so cycle through the loop four times, and locate the proper information to show in the dialog when editing an existing power--&gt;
[h,if(json.isEmpty(appStateHit) == 0),CODE:
{
     [ashList = json.fields(appStateHit)]
     [count(4),CODE:
     {
       [stateName = listGet(ashList, roll.count)]
       [mainListLoc = if(stateName != &quot;&quot;, listFind(stateList, stateName), 0)]
       [set(&quot;hitStateSelect&quot;+roll.count, mainListLoc)]
       [if(stateName != &quot;&quot;): ashDetail = json.get(appStateHit, stateName); ashDetail = &quot;{}&quot;]
       [if(json.isEmpty(ashDetail)==0): expire = json.get(ashDetail, &quot;expires&quot;); expire=&quot; &quot;]
       [if(json.isEmpty(ashDetail)==0): set(&quot;hs&quot;+roll.count+&quot;expire&quot;, listFind(expireList, expire)); set(&quot;hs&quot;+roll.count+&quot;expire&quot;,0)]
       [if(json.isEmpty(ashDetail)==0): set(&quot;hs&quot;+roll.count+&quot;ogd&quot;, json.get(ashDetail,&quot;ogDamAmt&quot;)); set(&quot;hs&quot;+roll.count+&quot;ogd&quot;, 0)]
      }]
};
{
[count(4): set(&quot;hitStateSelect&quot;+roll.count, 0)]
[count(4): set(&quot;hs&quot;+roll.count+&quot;expire&quot;, 0)]
[count(4): set(&quot;hs&quot;+roll.count+&quot;ogd&quot;,0)]
};]

[h,if(json.isEmpty(appStateMiss) == 0),CODE:
{
     [asmList = json.fields(appStateMiss)]
     [count(4),CODE:
   {
       [stateName = listGet(asmList, roll.count)]
       [mainListLoc = if(stateName != &quot;&quot;, listFind(stateList, stateName), 0)]
       [set(&quot;missStateSelect&quot;+roll.count, mainListLoc)]
       [if(stateName != &quot;&quot;): asmDetail = json.get(appStateMiss, stateName); asmDetail = &quot;&quot;]
       [if(json.isEmpty(asmDetail) == 0): set(&quot;ms&quot;+roll.count+&quot;expire&quot;, listFind(expireList, json.get(asmDetail, &quot;expires&quot;))); set(&quot;ms&quot;+roll.count+&quot;expire&quot;,0)]
       [if(json.isEmpty(asmDetail) == 0): set(&quot;ms&quot;+roll.count+&quot;ogd&quot;, json.get(asmDetail,&quot;ogDamAmt&quot;)); set(&quot;ms&quot;+roll.count+&quot;ogd&quot;, 0)]
   }]
};{

[count(4): set(&quot;missStateSelect&quot;+roll.count, 0)]
[count(4): set(&quot;ms&quot;+roll.count+&quot;expire&quot;, 0)]
[count(4): set(&quot;ms&quot;+roll.count+&quot;ogd&quot;,0)]

};]

[h,if(json.isEmpty(appStateAlways) == 0),CODE:
{
     [asaList = json.fields(appStateAlways)]
     [count(4),CODE:
   {
       [stateName = listGet(asaList, roll.count)]
       [mainListLoc = if(stateName != &quot;&quot;, listFind(stateList, stateName), 0)]
       [set(&quot;alwaysStateSelect&quot;+roll.count, mainListLoc)]
       [if(stateName != &quot;&quot;): asaDetail = json.get(appStateAlways, stateName); asaDetail = &quot;&quot;]
       [if(json.isEmpty(asaDetail) == 0): set(&quot;as&quot;+roll.count+&quot;expire&quot;, listFind(expireList, json.get(asaDetail, &quot;expires&quot;))); set(&quot;as&quot;+roll.count+&quot;expire&quot;,0)]
       [if(json.isEmpty(asaDetail) == 0): set(&quot;as&quot;+roll.count+&quot;ogd&quot;, json.get(asaDetail,&quot;ogDamAmt&quot;)); set(&quot;as&quot;+roll.count+&quot;ogd&quot;, 0)]
   }]
};{

[count(4): set(&quot;alwaysStateSelect&quot;+roll.count, 0)]
[count(4): set(&quot;as&quot;+roll.count+&quot;expire&quot;, 0)]
[count(4): set(&quot;as&quot;+roll.count+&quot;ogd&quot;,0)]

};]


&lt;!--Generate the Input Dialog - this is a very long and unwieldy dialog; I&apos;m considering using tabs, but I don&apos;t think they&apos;ll suppor the info right--&gt;

[h:status1=input(
                     	&quot;PowerBasics|Basic Power Info||TAB|SELECT=1&quot;,
	&quot;junk|&lt;html&gt;&lt;h3&gt;&lt;u&gt;&lt;font color=&apos;&quot;+bgColor+&quot;&apos;&gt;&quot;+json.get(selectedPower, &quot;powername&quot;)+&quot;&lt;/font&gt;&lt;/u&gt;&lt;/h3&gt;&lt;/html&gt;|-|LABEL|SPAN=TRUE&quot;,
	&quot;junk|&lt;html&gt;&lt;b&gt;Name, Level, Category&lt;/b&gt;&lt;/html&gt;|-|LABEL|SPAN=TRUE&quot;,
	&quot;newName|N/A|New Power Name (no apostrophes; leave as N/A to keep current name)&quot;,
	&quot;pwrLvl|&quot;+level+&quot;|Power Level&quot;,
	&quot;pwrCategory|&quot;+categoryList+&quot;|Power Category|LIST|SELECT=&quot;+catSelect+&quot; VALUE=STRING&quot;,
	&quot;reqs|&quot;+requirements+&quot;|Special Requirements or Notes&quot;,
	&quot;expend|&quot;+expendList+&quot;|Current Power availability|LIST|SELECT=&quot;+expSelect+&quot; VALUE=STRING&quot;,
	&quot;junk|&lt;html&gt;&lt;b&gt;Usage, Keywords, and Action Information&lt;/b&gt;&lt;/html&gt;|-|LABEL|SPAN=TRUE&quot;,
	&quot;usetype|&quot;+usageList+&quot;|Usage|LIST|SELECT=&quot;+usageSelect+&quot; VALUE=STRING&quot;,
	&quot;rechargeOn|&quot;+rechargeOn+&quot;|For recharge powers, enter recharge values (example: 4,5,6). Leave blank for other power types&quot;,
	&quot;keywords|&quot;+keywords+&quot;|Power Keywords (optional)&quot;,
	&quot;reliable|&quot;+reliable+&quot;|Check here if Power is Reliable|CHECK|&quot;,
                     &quot;spellbook|&quot;+spellbook+&quot;|Power is currently in Spellbook|CHECK|&quot;,
	&quot;acttype|&quot;+actionList+&quot;|Action Type|LIST|SELECT=&quot;+actionSelect+&quot; VALUE=STRING&quot;,
	&quot;atktype|&quot;+atkTypeList+&quot;|Attack Type|LIST|SELECT=&quot;+atktypeSelect+&quot; VALUE=STRING&quot;,
	&quot;junk|&lt;html&gt;&lt;b&gt;Range&lt;b&gt;&lt;/html&gt;|-|LABEL|SPAN=TRUE&quot;,
	&quot;rangeText|&quot;+rangeText+&quot;|Range descriptive text (e.g. &apos;ranged 20/40&apos; or &apos;close burst 3&apos;)&quot;,
	&quot;nomRange|&quot;+nominalRange+&quot;|Normal range of power (in squares, e.g. &apos;20&apos;)&quot;,
	&quot;maxRange|&quot;+maximumRange+&quot;|Maximum range of power / weapon (in squares, e.g. &apos;40&apos;)&quot;,
	&quot;junk|&lt;html&gt;&lt;b&gt;Attack Bonus, Targeted Defense, and Number of Targets&lt;/b&gt;&lt;/html&gt;|-|LABEL|SPAN=TRUE&quot;,	
	&quot;targs|&quot;+targetOptionList+&quot;|Targets|LIST|SELECT=&quot;+targSelect+&quot; VALUE=STRING&quot;,
	&quot;attbonus|&quot;+ attack+&quot;|Attack Bonus (including enhancement bonuses, etc.)&quot;,
	&quot;againstdef|&quot;+defList+&quot;|Defense targeted by attack|LIST|SELECT=&quot;+againstSelect+&quot; VALUE=STRING&quot;,
	&quot;HitCondSettings|Hit||TAB&quot;,
	&quot;junk|&lt;html&gt;&lt;b&gt;Damage Information&lt;/b&gt;&lt;/html&gt;|-|LABEL|SPAN=TRUE&quot;,
	&quot;damstring|&quot;+damage+&quot;|Total power damage expression (include all bonuses*)&quot;,
	&quot;critdamage|&quot;+critdamage+&quot;|Critical damage (if bonus critical dice, enter as dice expression, e.g. 1d6+15 or 15+1d6&quot;,
	&quot;critLower|&quot;+if(critLower != 0, critLower, 20)+&quot;|If expanded critical range, enter lower boundary here&quot;,
	&quot;damtype1|&quot;+damageTypeList+&quot;|First Damage Type|LIST|SELECT=&quot;+damTypeSelect0+&quot; VALUE=STRING&quot;,
	&quot;damtype2|&quot;+damageTypeList+&quot;|Second Damage Type|LIST|SELECT=&quot;+damTypeSelect1+&quot; VALUE=STRING&quot;,
	&quot;damtype3|&quot;+damageTypeList+&quot;|Third Damage Type|LIST|SELECT=&quot;+damTypeSelect2+&quot; VALUE=STRING&quot;,
	&quot;junk|&lt;html&gt;&lt;b&gt;Hit Description&lt;/b&gt;&lt;/html&gt;|JUNK|LABEL|SPAN=TRUE&quot;,
	&quot;hit|&quot;+hitEffect+&quot;|Hit text&quot;,
	&quot;junk|&lt;html&gt;&lt;b&gt;Apply the following conditions/effects&lt;/b&gt;&lt;/html&gt;|JUNK|LABEL|SPAN=TRUE&quot;,
	&quot;appStateHit0|&quot;+stateList+&quot;|&lt;html&gt;&lt;b&gt;First condition&lt;/b&gt;&lt;/html&gt;|LIST|SELECT=&quot;+hitStateSelect0+&quot; VALUE=STRING&quot;,
                     &quot;hitState0Expires|&quot;+expireList+&quot;|&lt;html&gt; &amp;middot; First condition expires&lt;/html&gt;|LIST|SELECT=&quot;+hs0expire+&quot; VALUE=STRING&quot;,
	&quot;hitState0Ongoing|&quot;+hs0ogd+&quot;|&lt;html&gt; &amp;middot; Ongoing Damage / Resist or Vulnerable / Regeneration amount (if applicable)&lt;/html&gt;&quot;,
	&quot;appStateHit1|&quot;+stateList+&quot;|&lt;html&gt;&lt;b&gt;Second condition&lt;/b&gt;&lt;/html&gt;|LIST|SELECT=&quot;+hitStateSelect1+&quot; VALUE=STRING&quot;,
                     &quot;hitState1Expires|&quot;+expireList+&quot;|&lt;html&gt; &amp;middot; Second condition expires&lt;/html&gt;|LIST|SELECT=&quot;+hs1expire+&quot; VALUE=STRING&quot;,
	&quot;hitState1Ongoing|&quot;+hs1ogd+&quot;|&lt;html&gt; &amp;middot; Ongoing Damage / Resist or Vulnerable / Regeneration amount (if applicable)&lt;/html&gt;&quot;,
	&quot;appStateHit2|&quot;+stateList+&quot;|&lt;html&gt;&lt;b&gt;Third condition&lt;/b&gt;&lt;/html&gt;|LIST|SELECT=&quot;+hitStateSelect2+&quot; VALUE=STRING&quot;,
                     &quot;hitState2Expires|&quot;+expireList+&quot;|&lt;html&gt; &amp;middot; Third condition expires&lt;/html&gt;|LIST|SELECT=&quot;+hs2expire+&quot; VALUE=STRING&quot;,
	&quot;hitState2Ongoing|&quot;+hs2ogd+&quot;|&lt;html&gt; &amp;middot; Ongoing Damage / Resist or Vulnerable / Regeneration amount (if applicable)&lt;/html&gt;&quot;,
	&quot;appStateHit3|&quot;+stateList+&quot;|&lt;html&gt;&lt;b&gt;Fourth condition&lt;/b&gt;&lt;/html&gt;|LIST|SELECT=&quot;+hitStateSelect3+&quot; VALUE=STRING&quot;,
                     &quot;hitState3Expires|&quot;+expireList+&quot;|&lt;html&gt; &amp;middot; Fourth condition expires&lt;/html&gt;|LIST|SELECT=&quot;+hs3expire+&quot; VALUE=STRING&quot;,
	&quot;hitState3Ongoing|&quot;+hs3ogd+&quot;|&lt;html&gt; &amp;middot; Ongoing Damage / Resist or Vulnerable / Regeneration amount (if applicable)&lt;/html&gt;&quot;,
	&quot;.|&lt;html&gt; &amp;nbsp; *&lt;i&gt;For weapons with the &lt;b&gt;Brutal&lt;/b&gt; property, write the damage dice in the format XdYrN (where &apos;r&apos; is the weapon&apos;s Brutal value + 1)&lt;/i&gt;&lt;/html&gt;||LABEL|SPAN=TRUE&quot;,
	&quot;.|&lt;html&gt; &amp;nbsp; &lt;i&gt;For example, a 1d6 Brutal 2 weapon would be written here as &apos;1d6r3&apos;.&lt;/i&gt;&lt;/html&gt;||LABEL|SPAN=TRUE&quot;,
	&quot;MissCondSettings|Miss||TAB&quot;,
	&quot;halfDmgOnMiss|&quot;+halfDmgOnMiss+&quot;|Half damage on a miss|CHECK&quot;,
	&quot;junk|&lt;html&gt;&lt;b&gt;Miss Description and Conditions&lt;/b&gt;&lt;/html&gt;|JUNK|LABEL|SPAN=TRUE&quot;,
	&quot;miss|&quot;+missEffect+&quot;|Miss text&quot;,
	&quot;junk|&lt;html&gt;&lt;b&gt;Apply the following conditions/effects&lt;/b&gt;&lt;/html&gt;|JUNK|LABEL|SPAN=TRUE&quot;,
	&quot;appStateMiss0|&quot;+stateList+&quot;|&lt;html&gt;&lt;b&gt;First condition&lt;/b&gt;&lt;/html&gt;|LIST|SELECT=&quot;+missStateSelect0+&quot; VALUE=STRING&quot;,
                     &quot;missState0Expires|&quot;+expireList+&quot;|&lt;html&gt; &amp;middot; First condition expires&lt;/html&gt;|LIST|SELECT=&quot;+ms0expire+&quot; VALUE=STRING&quot;,
	&quot;missState0Ongoing|&quot;+ms0ogd+&quot;|&lt;html&gt; &amp;middot; Ongoing Damage / Resist or Vulnerable / Regeneration amount (if applicable)&lt;/html&gt;&quot;,
	&quot;appStateMiss1|&quot;+stateList+&quot;|&lt;html&gt;&lt;b&gt;Second condition&lt;/b&gt;&lt;/html&gt;|LIST|SELECT=&quot;+missStateSelect1+&quot; VALUE=STRING&quot;,
                     &quot;missState1Expires|&quot;+expireList+&quot;|&lt;html&gt; &amp;middot; Second condition expires&lt;/html&gt;|LIST|SELECT=&quot;+ms1expire+&quot; VALUE=STRING&quot;,
	&quot;missState1Ongoing|&quot;+ms1ogd+&quot;|&lt;html&gt; &amp;middot; Ongoing Damage / Resist or Vulnerable / Regeneration amount (if applicable)&lt;/html&gt;&quot;,
	&quot;EffCondSettings|Effect||TAB&quot;,
	&quot;junk|&lt;html&gt;&lt;b&gt;Effect Description and Conditions&lt;/b&gt;&lt;/html&gt;|JUNK|LABEL|SPAN=TRUE&quot;,
	&quot;eff|&quot;+alwaysEffect+&quot;|Effect text&quot;,
	&quot;junk|&lt;html&gt;&lt;b&gt;Apply the following conditions/effects&lt;/b&gt;&lt;/html&gt;|Junk|LABEL|SPAN=TRUE&quot;,
	&quot;appStateAlways0|&quot;+stateList+&quot;|&lt;html&gt;&lt;b&gt;First condition&lt;/b&gt;&lt;/html&gt;|LIST|SELECT=&quot;+alwaysStateSelect0+&quot; VALUE=STRING&quot;,
                     &quot;alwState0Expires|&quot;+expireList+&quot;|&lt;html&gt; &amp;middot; First condition expires&lt;/html&gt;|LIST|SELECT=&quot;+as0expire+&quot; VALUE=STRING&quot;,
	&quot;alwState0Ongoing|&quot;+as0ogd+&quot;|&lt;html&gt; &amp;middot; Ongoing Damage / Resist or Vulnerable / Regeneration amount (if applicable)&lt;/html&gt;&quot;,
	&quot;appStateAlways1|&quot;+stateList+&quot;|&lt;html&gt;&lt;b&gt;Second condition&lt;/b&gt;&lt;/html&gt;|LIST|SELECT=&quot;+alwaysStateSelect1+&quot; VALUE=STRING&quot;,
                     &quot;alwState1Expires|&quot;+expireList+&quot;|&lt;html&gt; &amp;middot; Second condition expires&lt;/html&gt;|LIST|SELECT=&quot;+as1expire+&quot; VALUE=STRING&quot;,
	&quot;alwState1Ongoing|&quot;+as1ogd+&quot;|&lt;html&gt; &amp;middot; Ongoing Damage / Resist or Vulnerable / Regeneration amount (if applicable)&lt;/html&gt;&quot;
)]

[h:abort(status1)]

&lt;!--If one or more damage types is selected, append them to a list--&gt;
[h:damtype=&quot;&quot;]
[h,if(damtype1 != &quot;&quot;): damtype = listAppend(damtype, damtype1)]
[h,if(damtype2 != &quot;&quot;): damtype = listAppend(damtype, damtype2)]
[h,if(damtype3 != &quot;&quot;): damtype = listAppend(damtype, damtype3)]

&lt;!--If one or more states is selected (for hit, miss, or effect), construct the JSON object that will contain the name of the state, the expiration time, and, if ongoing damage, the amount of damage to apply every round--&gt;
[h:appStateHit = &quot;{}&quot;]
[h,if(appStateHit0 != &quot;None&quot;),CODE:
{
   [h:ash0obj = json.set(&quot;{}&quot;, &quot;expires&quot;, hitState0Expires, &quot;ogDamAmt&quot;, hitState0Ongoing)]
   [h: appStateHit = json.set(appStateHit, appStateHit0, ash0obj)]
};{}]
[h,if(appStateHit1 != &quot;None&quot;),CODE:
{
   [h:ash1obj = json.set(&quot;{}&quot;, &quot;expires&quot;,hitState1Expires, &quot;ogDamAmt&quot;, hitState1Ongoing)]
   [h: appStateHit = json.set(appStateHit, appStateHit1, ash1obj)]
};{};]
[h,if(appStateHit2 != &quot;None&quot;),CODE:
{
    [h:ash2obj = json.set(&quot;{}&quot;, &quot;expires&quot;,hitState2Expires, &quot;ogDamAmt&quot;, hitState2Ongoing)]
   [h: appStateHit = json.set(appStateHit, appStateHit2, ash2obj)]
};{};]
[h,if(appStateHit3 != &quot;None&quot;),CODE:
{
 [ h:ash3obj = json.set(&quot;{}&quot;, &quot;expires&quot;,hitState3Expires, &quot;ogDamAmt&quot;, hitState3Ongoing)]
   [h: appStateHit = json.set(appStateHit, appStateHit3, ash3obj)]
};{};]

[h:appStateMiss = &quot;{}&quot;]
[h,if(appStateMiss1 != &quot;None&quot;),CODE:
{
    [h:asm1obj = json.set(&quot;{}&quot;, &quot;expires&quot;,missState1Expires, &quot;ogDamAmt&quot;, missState1Ongoing)]
    [h: appStateMiss = json.set(appStateMiss, appStateMiss1, asm1obj)]
};{};]
[h,if(appStateMiss0 != &quot;None&quot;),CODE:
{
    [h:asm0obj = json.set(&quot;{}&quot;, &quot;expires&quot;, missState0Expires, &quot;ogDamAmt&quot;, missState0Ongoing)]
    [h: appStateMiss = json.set(appStateMiss, appStateMiss0, asm0obj)]
};{};]

[h:appStateAlways = &quot;&quot;]
[h,if(appStateAlways1 != &quot;None&quot;),CODE:
{
    [h:alw1obj = json.set(&quot;{}&quot;, &quot;expires&quot;, alwState1Expires, &quot;ogDamAmt&quot;, alwState1Ongoing)]
    [h:appStateAlways = json.set(appStateAlways, appStateAlways1, alw1obj)]
};{};]
[h,if(appStateAlways0 != &quot;None&quot;),CODE:
{
    [h:alw0obj = json.set(&quot;{}&quot;, &quot;expires&quot;, alwState0Expires, &quot;ogDamAmt&quot;, alwState0Ongoing)]
    [h:appStateAlways = json.set(appStateAlways, appStateAlways0, alw0obj)]
};{};]

&lt;!--If a new name is selected for the power, assign it to the variable &quot;modifiedName&quot;--&gt;

[h,if(newName != &quot;N/A&quot;): modifiedName =  newName; modifiedName = json.get(selectedPower, &quot;powername&quot;)]

&lt;!--Remove the power from the JSON - this prevents duplication, and is irrelevant for new powers--&gt;
[h:Powers = json.remove(Powers, json.get(selectedPower, &quot;powername&quot;))]

&lt;!--Build a large, temporary JSON object to hold the power details--&gt;
[h:modifiedPower = json.set(&quot;{}&quot;, &quot;powername&quot;, modifiedName, &quot;level&quot;, pwrLvl, &quot;pCategory&quot;, pwrCategory, &quot;keywords&quot;, keywords, &quot;action&quot;, acttype, &quot;usage&quot;, usetype, &quot;attackType&quot;, atktype, &quot;rangeText&quot;, rangeText, &quot;nominalRange&quot;, nomRange, &quot;maximumRange&quot;,maxRange, &quot;reliable&quot;, reliable, &quot;spellbook&quot;, spellbook, &quot;rechargeOn&quot;, rechargeOn, &quot;attack&quot;, attbonus, &quot;against&quot;, againstdef, &quot;targets&quot;, targs, &quot;damage&quot;, damstring, &quot;critLower&quot;, critLower, &quot;critdamage&quot;, critdamage, &quot;damageType&quot;, damtype, &quot;halfDmgOnMiss&quot;, halfDmgOnMiss, &quot;requirements&quot;, reqs, &quot;hitEffect&quot;, hit, &quot;missEffect&quot;, miss, &quot;alwaysEffect&quot;, eff, &quot;appStateHit&quot;, appStateHit, &quot;appStateMiss&quot;, appStateMiss, &quot;appStateAlways&quot;, appStateAlways, &quot;expended&quot;, expend)]

&lt;!--Update the Powers property by setting the temporary JSON object, above, as the nested object corresponding to the new power name--&gt;
[h:Powers=json.set(Powers, json.get(modifiedPower, &quot;powername&quot;), modifiedPower)]

&lt;!--If we are adding a new power, or updating an existing power to a new name, build and/or replace the existing macro buttons--&gt;
[h,if(whichPower == &quot;Add New&quot;),CODE:
{
     [h:powname=newName]
     [h,if(spellbook == 1),CODE:
     {
        [switch(usetype):
        case &quot;at-will&quot;: btnColor = &quot;green&quot;;
        case &quot;encounter&quot;: btnColor = &quot;red&quot;;
        case &quot;daily&quot;: btnColor = &quot;black&quot;;
        case &quot;recharge&quot;: btnColor = &quot;blue&quot;;]
        [if(usetype == &quot;at-will&quot;): fntColor = &quot;black&quot;; fntColor=&quot;white&quot;]
        [propstring=&quot;color=&quot;+btnColor+&quot;; fontColor=&quot;+fntColor+&quot;; group=5. Spellbook; autoExec=true;&quot;]
        [h:macCommand = &apos; [macro(&quot;AttackMain@Lib:4e&quot;):&quot;&apos;+powname+&apos;&quot;] &apos; ]
        [h:createMacro(powname, macCommand, propstring)]
        [h:setMacroProps(powname, &quot;tooltip=&quot;+tempToolTip)]
      }; 
     {
     [h,switch(usetype):
      case &quot;at-will&quot;: propstring=&quot;color=green; fontColor=black; group=1. At-Will; autoExec=true; sortBy=&quot;+pwrLvl; 
      case &quot;encounter&quot;:propstring=&quot;color=red; fontColor=white; group=2. Encounter; autoExec=true; sortBy=&quot;+pwrLvl; 
      case &quot;daily&quot;: propstring=&quot;color=black; fontColor=white; group=3. Daily; autoExec=true; sortBy=&quot;+pwrLvl; 
      case &quot;recharge&quot;: propstring=&quot;color=blue; fontColor=white; group=4. Recharging; autoExec=true; sortBy=&quot;+pwrLvl;
      default: propstring=&quot;color=green; fontColor=black; group=1. At-Will; autoExec=true; sortBy=&quot;+pwrLvl;]

       [h:macCommand = &apos; [macro(&quot;AttackMain@Lib:4e&quot;):&quot;&apos;+powname+&apos;&quot;] &apos; ]
        [h:createMacro(powname, macCommand, propstring)]
        [h:setMacroProps(powname, &quot;tooltip=&quot;+tempToolTip)]
     };]
     
};
{
  [h,if(newName != &quot;N/A&quot;): powname= newName; powName = whichPower]
  [h:macIndex = getMacroIndexes(whichPower)]
  [h,if(macIndex != &quot;&quot;):removeMacro(macIndex)]
  [h:bookList = &quot;daily,Utility&quot;]
  [h,if(spellbook == 1),CODE:
     {
        [switch(usetype):
        case &quot;at-will&quot;: btnColor = &quot;green&quot;;
        case &quot;encounter&quot;: btnColor = &quot;red&quot;;
        case &quot;daily&quot;: btnColor = &quot;black&quot;;
        case &quot;recharge&quot;: btnColor = &quot;blue&quot;;]
        [if(usetype == &quot;at-will&quot;): fntColor = &quot;black&quot;; fntColor=&quot;white&quot;]
        [propstring=&quot;color=&quot;+btnColor+&quot;; fontColor=&quot;+fntColor+&quot;; group=5. Spellbook; autoExec=true;&quot;]

        [h:macCommand = &apos; [macro(&quot;AttackMain@Lib:4e&quot;):&quot;&apos;+powname+&apos;&quot;] &apos; ]
        [h:createMacro(powname, macCommand, propstring)]
        [h:setMacroProps(powname, &quot;tooltip=&quot;+tempToolTip)]
      }; 
     {
     [h,switch(usetype):
      case &quot;at-will&quot;: propstring=&quot;color=green; fontColor=black; group=1. At-Will; autoExec=true; sortBy=&quot;+pwrLvl; 
      case &quot;encounter&quot;:propstring=&quot;color=red; fontColor=white; group=2. Encounter; autoExec=true; sortBy=&quot;+pwrLvl; 
      case &quot;daily&quot;: propstring=&quot;color=black; fontColor=white; group=3. Daily; autoExec=true; sortBy=&quot;+pwrLvl; 
      case &quot;recharge&quot;: propstring=&quot;color=blue; fontColor=white; group=4. Recharging; autoExec=true; sortBy=&quot;+pwrLvl;
      default: propstring=&quot;color=green; fontColor=black; group=1. At-Will; autoExec=true; sortBy=&quot;+pwrLvl;]

      [h:macCommand = &apos; [macro(&quot;AttackMain@Lib:4e&quot;):&quot;&apos;+powname+&apos;&quot;] &apos; ]
        [h:createMacro(powname, macCommand, propstring)]
        [h:setMacroProps(powname, &quot;tooltip=&quot;+tempToolTip)]
     };]
};]

&lt;!--Confirm the operation is complete--&gt;
[h:input(&quot;.|&quot;+if(newName != &quot;N/A&quot;, newName, whichPower)+&quot; added/updated||LABEL|SPAN=TRUE&quot;)]

</command>
        <label>Edit Powers D</label>
        <group>Power Management</group>
        <sortby></sortby>
        <autoExecute>true</autoExecute>
        <includeLabel>false</includeLabel>
        <applyToTokens>false</applyToTokens>
        <fontColorKey>black</fontColorKey>
        <fontSize>1.00em</fontSize>
        <minWidth></minWidth>
        <maxWidth></maxWidth>
        <allowPlayerEdits>true</allowPlayerEdits>
        <toolTip></toolTip>
        <commonMacro>false</commonMacro>
        <compareGroup>true</compareGroup>
        <compareSortPrefix>true</compareSortPrefix>
        <compareCommand>true</compareCommand>
        <compareIncludeLabel>true</compareIncludeLabel>
        <compareAutoExecute>true</compareAutoExecute>
        <compareApplyToSelectedTokens>true</compareApplyToSelectedTokens>
      </net.rptools.maptool.model.MacroButtonProperties>
    </entry>
    <entry>
      <int>91</int>
      <net.rptools.maptool.model.MacroButtonProperties>
        <saveLocation>Token</saveLocation>
        <index>91</index>
        <colorKey>default</colorKey>
        <hotKey>None</hotKey>
        <command>[if(ActionPoints &lt;= 0),CODE:
{
     [h:input(&quot;junk|&lt;html&gt;&lt;b&gt;You have no Actions Points remaining!&lt;/b&gt;&lt;/html&gt;|-|LABEL|SPAN=TRUE&quot;)]
     [h:abort(0)]
};
{
     [if(APspent == 0), CODE:
     {
        [r:token.name] spends an Action Point, gaining an additional action.
        [h:ActionPoints = ActionPoints - 1]
        [h:APSpent = APSpent + 1]
     };
    {
        [h:input(&quot;junk|&lt;html&gt;&lt;b&gt;You have already used an Action Point during this encounter&lt;/b&gt;&lt;/html&gt;|-|LABEL|SPAN=TRUE&quot;)]
        [h:abort(0)]
     };]
};]</command>
        <label>Action Point</label>
        <group>Resting</group>
        <sortby></sortby>
        <autoExecute>true</autoExecute>
        <includeLabel>false</includeLabel>
        <applyToTokens>false</applyToTokens>
        <fontColorKey>black</fontColorKey>
        <fontSize>1.00em</fontSize>
        <minWidth></minWidth>
        <maxWidth></maxWidth>
        <allowPlayerEdits>false</allowPlayerEdits>
        <toolTip></toolTip>
        <commonMacro>false</commonMacro>
        <compareGroup>true</compareGroup>
        <compareSortPrefix>true</compareSortPrefix>
        <compareCommand>true</compareCommand>
        <compareIncludeLabel>true</compareIncludeLabel>
        <compareAutoExecute>true</compareAutoExecute>
        <compareApplyToSelectedTokens>true</compareApplyToSelectedTokens>
      </net.rptools.maptool.model.MacroButtonProperties>
    </entry>
    <entry>
      <int>102</int>
      <net.rptools.maptool.model.MacroButtonProperties>
        <saveLocation>Token</saveLocation>
        <index>102</index>
        <colorKey>default</colorKey>
        <hotKey>None</hotKey>
        <command>[h:debugmode = getLibProperty(&quot;DEBUGMODE&quot;)]
[h:assert(json.isEmpty(Powers)==0, &quot;There are no powers to display&quot;, 0)]
[h:powerList=json.fields(Powers)]
[h:powerList=listSort(powerList,&quot;A+&quot;)]
[h:status=input(
       &quot;selPower|&quot;+powerList+&quot;|Select Power to View|LIST|SELECT=0 VALUE=STRING&quot;
)]
[h:abort(status)]
[h:powerDetail=json.get(Powers,selPower)]
[h:varsFromJSON(powerDetail)]

&lt;!--Determine a few things about the power - effects, requirements, etc.--&gt;
[h,if(usage == &quot;recharge&quot;): rechargeInfo = rechargeOn; rechargeInfo = &quot;&quot;]
[h,if(critLower &lt; 20): critInfo = &quot;&lt;b&gt;Crit Range&lt;/b&gt;: &quot;+critLower+&quot;-20&quot;; critInfo = &quot;&quot;]
[h,if(requirements != &quot;&quot; &amp;&amp; requirements != &quot;--none--&quot;): hasReqs = 1; hasReqs = 0]
[h,if(hitEffect != &quot;&quot; &amp;&amp; hitEffect != &quot;--none--&quot;): hasHitEff = 1; hasHitEff=0]
[h,if(missEffect != &quot;&quot; &amp;&amp; missEffect != &quot;--none--&quot;): hasMissEff = 1; hasMissEff = 0]
[h,if(alwaysEffect != &quot;&quot; &amp;&amp; alwaysEffect != &quot;--none--&quot;): hasAlwaysEff=1; hasAlwaysEff=0]
[h,if(length(keywords)&gt;4): itemSubString=substring(keywords,0,4); itemSubString = &quot;&quot;]
[h,if(itemSubString==&quot;item&quot;),CODE:
{
    [bgcolor=&quot;#ff6600&quot;]
};
{
[h,switch(usage):
case &quot;at-will&quot;: bgcolor=&quot;#006600&quot;;
case &quot;encounter&quot;: bgcolor=&quot;#990000&quot;;
case &quot;daily&quot;: bgcolor=&quot;#000000&quot;;
case &quot;recharge&quot;:bgcolor=&quot;blue&quot;;]
}]


&lt;!--Create Table Template--&gt;
[h:powerCardTemplate = &quot;&lt;html&gt;&lt;body bgcolor=&apos;white&apos;&gt;&lt;table bgcolor=&apos;white&apos; width=&apos;100%&apos;&gt;&lt;tr bgcolor=%{bgcolor}&gt;&lt;td color=&apos;white&apos;&gt;&lt;b&gt;%{powername}&lt;/b&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;b&gt;Usage&lt;/b&gt;: %{usage} %{rechargeInfo} &amp;#10022; &lt;b&gt;Keywords&lt;/b&gt;: %{keywords}&lt;/td&gt;&lt;/tr&gt;&lt;tr bgcolor=&apos;#cccccc&apos;&gt;&lt;td&gt; &lt;b&gt;Action&lt;/b&gt;: %{action} &amp;#10022; &lt;b&gt;Range&lt;/b&gt;: %{rangeText}&lt;/td&gt;&lt;/tr&gt;&quot;]

&lt;!--If there are requirements, show them, otherwise, show nothing--&gt;
[h,if(hasReqs):powerCardTemplate = concat(powerCardTemplate,&quot;&lt;tr&gt;&lt;td&gt;&lt;b&gt;Requirements&lt;/b&gt;: %{requirements}&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&quot;)]

[h:powerCardTemplate = concat(powerCardTemplate, &quot;&lt;td bgcolor=&apos;#cccccc&apos;&gt;&lt;b&gt;Target&lt;/b&gt;: %{targets}&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;b&gt;Attack&lt;/b&gt;: +%{attack} vs. %{against}&lt;/td&gt;&lt;/tr&gt;&lt;tr bgcolor=&apos;#cccccc&apos;&gt;&lt;td&gt;&lt;b&gt;Damage&lt;/b&gt;: %{damage} (%{critdamage} critical) %{critInfo}&lt;/td&gt;&lt;/tr&gt;&quot;)]

&lt;!--If there are effects, show them, otherwise, show nothing--&gt;
[h,if(hasHitEff): powerCardTemplate = concat(powerCardTemplate, &quot;&lt;tr&gt;&lt;td &gt;&lt;b&gt;Hit&lt;/b&gt;: %{hitEffect}&lt;/td&gt;&lt;/tr&gt;&quot;)]
[h,if(hasMissEff): powerCardTemplate = concat(powerCardTemplate, &quot;&lt;tr bgcolor=&apos;#cccccc&apos;&gt;&lt;td&gt;&lt;b&gt;Miss&lt;/b&gt;: %{missEffect}&lt;/td&gt;&lt;/tr&gt;&quot;)]
[h,if(hasAlwaysEff): powerCardTemplate = concat(powerCardTemplate, &quot;&lt;tr&gt;&lt;td&gt;&lt;b&gt;Effect&lt;/b&gt;: %{alwaysEffect}&lt;/td&gt;&lt;/tr&gt;&quot;)]

&lt;!--Close all tags--&gt;
[h:powerCardTemplate = concat(powerCardTemplate, &quot;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt;&quot;)]

[h:powerCard = strformat(powerCardTemplate)]
[h:inputParameters = &quot;.|&quot;+powerCard+&quot;||LABEL|SPAN=TRUE&quot;]

[h:status=input(inputParameters)]
[h:abort(status)]</command>
        <label>Show Power Card</label>
        <group>Character Sheet &amp; Power Cards</group>
        <sortby></sortby>
        <autoExecute>true</autoExecute>
        <includeLabel>false</includeLabel>
        <applyToTokens>false</applyToTokens>
        <fontColorKey>black</fontColorKey>
        <fontSize>1.00em</fontSize>
        <minWidth></minWidth>
        <maxWidth></maxWidth>
        <allowPlayerEdits>false</allowPlayerEdits>
        <toolTip></toolTip>
        <commonMacro>false</commonMacro>
        <compareGroup>true</compareGroup>
        <compareSortPrefix>true</compareSortPrefix>
        <compareCommand>true</compareCommand>
        <compareIncludeLabel>true</compareIncludeLabel>
        <compareAutoExecute>true</compareAutoExecute>
        <compareApplyToSelectedTokens>true</compareApplyToSelectedTokens>
      </net.rptools.maptool.model.MacroButtonProperties>
    </entry>
    <entry>
      <int>103</int>
      <net.rptools.maptool.model.MacroButtonProperties>
        <saveLocation>Token</saveLocation>
        <index>103</index>
        <colorKey>default</colorKey>
        <hotKey>None</hotKey>
        <command>[h:attPrompt = input(&quot;.|&lt;html&gt;&lt;b&gt;Enter the attack bonus or penalty information below:&lt;/b&gt;&lt;/html&gt;||LABEL|SPAN=TRUE&quot;,
		       &quot;.|&lt;html&gt;This bonus/penalty will apply to &lt;i&gt;all&lt;/i&gt; attacks made by the target.&lt;/html&gt;||LABEL|SPAN=TRUE&quot;,
	 	        &quot;bpAmount|0|Bonus or penalty amount (use negative numbers for penalties)&quot;)]
[h:abort(attPrompt)]
[h:lastAttAdjust = json.set(&quot;{}&quot;, &quot;adjustment&quot;, bpAmount)]
[h:setProperty(&quot;LastAttackAdjustment&quot;, lastAttAdjust)]</command>
        <label>procAttBonus</label>
        <group>User-Defined Functions</group>
        <sortby></sortby>
        <autoExecute>true</autoExecute>
        <includeLabel>false</includeLabel>
        <applyToTokens>false</applyToTokens>
        <fontColorKey>black</fontColorKey>
        <fontSize>1.00em</fontSize>
        <minWidth></minWidth>
        <maxWidth></maxWidth>
        <allowPlayerEdits>false</allowPlayerEdits>
        <toolTip></toolTip>
        <commonMacro>false</commonMacro>
        <compareGroup>true</compareGroup>
        <compareSortPrefix>true</compareSortPrefix>
        <compareCommand>true</compareCommand>
        <compareIncludeLabel>true</compareIncludeLabel>
        <compareAutoExecute>true</compareAutoExecute>
        <compareApplyToSelectedTokens>true</compareApplyToSelectedTokens>
      </net.rptools.maptool.model.MacroButtonProperties>
    </entry>
    <entry>
      <int>100</int>
      <net.rptools.maptool.model.MacroButtonProperties>
        <saveLocation>Token</saveLocation>
        <index>100</index>
        <colorKey>default</colorKey>
        <hotKey>F3</hotKey>
        <command>[h:currentMode = getLibProperty(&quot;DEBUGMODE&quot;, &quot;Lib:4e&quot;)]
[h:setLibProperty(&quot;DEBUGMODE&quot;, 1-currentMode)]

DEBUGMODE [r:if(getLibProperty(&quot;DEBUGMODE&quot;, &quot;Lib:4e&quot;), &quot;on.&quot;, &quot;off.&quot;)]</command>
        <label>DEBUGMODE Toggle</label>
        <group>User-Defined Functions</group>
        <sortby></sortby>
        <autoExecute>true</autoExecute>
        <includeLabel>false</includeLabel>
        <applyToTokens>false</applyToTokens>
        <fontColorKey>black</fontColorKey>
        <fontSize>1.00em</fontSize>
        <minWidth></minWidth>
        <maxWidth></maxWidth>
        <allowPlayerEdits>false</allowPlayerEdits>
        <toolTip></toolTip>
        <commonMacro>false</commonMacro>
        <compareGroup>true</compareGroup>
        <compareSortPrefix>true</compareSortPrefix>
        <compareCommand>true</compareCommand>
        <compareIncludeLabel>true</compareIncludeLabel>
        <compareAutoExecute>true</compareAutoExecute>
        <compareApplyToSelectedTokens>true</compareApplyToSelectedTokens>
      </net.rptools.maptool.model.MacroButtonProperties>
    </entry>
    <entry>
      <int>101</int>
      <net.rptools.maptool.model.MacroButtonProperties>
        <saveLocation>Token</saveLocation>
        <index>101</index>
        <colorKey>default</colorKey>
        <hotKey>None</hotKey>
        <command>&lt;!--extracts dice expressions from a string, evaluates them, and returns a JSON containing--&gt;
&lt;!--both the total of the expression, and the breakdown--&gt;
[h:debugmode = getProperty(&quot;DEBUGMODE&quot;)]
[h:debugMacro = getMacroName()]
[h:assert(argCount() == 1, &quot;extractDice() requires exactly one argument&quot;, 0)]
[h:diceString = arg(0)]

[h:dmgBreakdown = &quot;&quot;]
[h:dmg = &quot;&quot;]

[h:diceID = strfind(diceString, &quot;([0-9]?[0-9]d[0-9]?[0-9]r?[0-9]?)&quot;)]
[h:fbID = strfind(diceString, &quot;(?&lt;!d|r|1|2)[0-9]+(?!d|r)&quot;)]

[h:numDice = if(getFindCount(diceID), getFindCount(diceID), 0)]
[h:numFixed = if(getFindCount(fbID), getFindCount(fbID), 0)]

[h,if(numDice &gt; 0),CODE:
{
      [count(numDice), CODE:
      {
           [die = getGroup(diceID, roll.count+1, 0)]
           [dieRoll = eval(die)]
            [dmgBreakdown = json.append(dmgBreakdown, dieRoll+&quot; (&quot;+die+&quot;) &quot;)]
           [dmg = json.append(dmg, dieRoll)]
       }]
}]

[h,if(numFixed &gt; 0),CODE:
{
     [count(numFixed),CODE:
     {
          [fixB = getGroup(fbID, roll.count+1, 0)]
          [dmgBreakdown = json.append(dmgBreakdown, fixB)]
          [dmg = json.append(dmg, fixB)]
     }]
}]

[h:dmgBreakdown = json.toList(dmgBreakdown, &quot;+&quot;)]
[h:dmg = json.toList(dmg, &quot;+&quot;)]
[h:totalDam = eval(string(dmg))]
[h:return =totalDam]
[r:return]
[h:macro.return=dmgBreakdown]</command>
        <label>extractDice</label>
        <group>User-Defined Functions</group>
        <sortby></sortby>
        <autoExecute>true</autoExecute>
        <includeLabel>false</includeLabel>
        <applyToTokens>false</applyToTokens>
        <fontColorKey>black</fontColorKey>
        <fontSize>1.00em</fontSize>
        <minWidth></minWidth>
        <maxWidth></maxWidth>
        <allowPlayerEdits>false</allowPlayerEdits>
        <toolTip></toolTip>
        <commonMacro>false</commonMacro>
        <compareGroup>true</compareGroup>
        <compareSortPrefix>true</compareSortPrefix>
        <compareCommand>true</compareCommand>
        <compareIncludeLabel>true</compareIncludeLabel>
        <compareAutoExecute>true</compareAutoExecute>
        <compareApplyToSelectedTokens>true</compareApplyToSelectedTokens>
      </net.rptools.maptool.model.MacroButtonProperties>
    </entry>
    <entry>
      <int>99</int>
      <net.rptools.maptool.model.MacroButtonProperties>
        <saveLocation>Token</saveLocation>
        <index>99</index>
        <colorKey>default</colorKey>
        <hotKey>None</hotKey>
        <command>[h:lostMacro = getMacroName()]
[h:shown = getLibProperty(&quot;showOnce&quot;)]
[h,switch(lostMacro),CODE:
case&quot;Edit Existing Power&quot;:
{
   [h:shown = getLibProperty(&quot;edPowerShowOnce&quot;)]
   [newMacName = &quot;Edit Powers&quot;]
   [h,if(shown != 1): input(&quot;.|&lt;html&gt;Please note: the macro &lt;i&gt;&quot;+lostMacro+&quot;&lt;/i&gt; has been changed to &lt;i&gt;&quot;+newMacName+&quot;&lt;/i&gt;.&lt;/html&gt;||LABEL|SPAN=TRUE&quot;)]
   [h:setLibProperty(&quot;edPowerShowOnce&quot;, 1)]
   [macro(newMacName+&quot;@this&quot;):&quot;&quot;]
};
case &quot;Edit Character Basics&quot;:
{
   [h:shown = getLibProperty(&quot;edCharBShowOnce&quot;)]
   [newMacName = &quot;Edit Character&quot;]
    [h,if(shown != 1): input(&quot;.|&lt;html&gt;Please note: the macro &lt;i&gt;&quot;+lostMacro+&quot;&lt;/i&gt; has been changed to &lt;i&gt;&quot;+newMacName+&quot;&lt;/i&gt;.&lt;/html&gt;||LABEL|SPAN=TRUE&quot;)]
   [h:setLibProperty(&quot;edCharBShowOnce&quot;, 1)]
   [macro(newMacName+&quot;@this&quot;):&quot;&quot;]
};
case &quot;Edit Character Skills&quot;:
{
   [h:shown = getLibProperty(&quot;edCharSkShowOnce&quot;)]
   [newMacName = &quot;Edit Character&quot;]
   [h,if(shown != 1): input(&quot;.|&lt;html&gt;Please note: the macro &lt;i&gt;&quot;+lostMacro+&quot;&lt;/i&gt; has been changed to &lt;i&gt;&quot;+newMacName+&quot;&lt;/i&gt;.&lt;/html&gt;||LABEL|SPAN=TRUE&quot;)]
   [h:setLibProperty(&quot;edCharSkShowOnce&quot;, 1)]
   [macro(newMacName+&quot;@this&quot;):&quot;&quot;]
};
case &quot;Edit Resistance / Vulnerability&quot;:
{
    [h:shown = getLibProperty(&quot;edCharRVShowOnce&quot;)]
   [newMacName = &quot;Edit Character&quot;]
    [h,if(shown != 1): input(&quot;.|&lt;html&gt;Please note: the macro &lt;i&gt;&quot;+lostMacro+&quot;&lt;/i&gt; has been changed to &lt;i&gt;&quot;+newMacName+&quot;&lt;/i&gt;.&lt;/html&gt;||LABEL|SPAN=TRUE&quot;)]
   [h:setLibProperty(&quot;edCharRVShowOnce&quot;, 1)]
   [macro(newMacName+&quot;@this&quot;):&quot;&quot;]
};
case &quot;Edit Damage Multipliers&quot;:
{
    [h:shown = getLibProperty(&quot;edCharDMShowOnce&quot;)]
   [h,if(shown != 1): input(&quot;.|&lt;html&gt;Please note: the macro &lt;i&gt;&quot;+lostMacro+&quot;&lt;/i&gt; has been changed to &lt;i&gt;&quot;+newMacName+&quot;&lt;/i&gt;.&lt;/html&gt;||LABEL|SPAN=TRUE&quot;)]
   [h:setLibProperty(&quot;edCharDMShowOnce&quot;, 1)]
   [macro(newMacName+&quot;@this&quot;):&quot;&quot;]
};
case &quot;Start Turn&quot;:
{
    [macro(&quot;StartTurn@this&quot;):&quot;&quot;]
};]</command>
        <label>!!unknown-macro!!</label>
        <group>User-Defined Functions</group>
        <sortby></sortby>
        <autoExecute>true</autoExecute>
        <includeLabel>false</includeLabel>
        <applyToTokens>false</applyToTokens>
        <fontColorKey>black</fontColorKey>
        <fontSize>1.00em</fontSize>
        <minWidth></minWidth>
        <maxWidth></maxWidth>
        <allowPlayerEdits>false</allowPlayerEdits>
        <toolTip></toolTip>
        <commonMacro>false</commonMacro>
        <compareGroup>true</compareGroup>
        <compareSortPrefix>true</compareSortPrefix>
        <compareCommand>true</compareCommand>
        <compareIncludeLabel>true</compareIncludeLabel>
        <compareAutoExecute>true</compareAutoExecute>
        <compareApplyToSelectedTokens>true</compareApplyToSelectedTokens>
      </net.rptools.maptool.model.MacroButtonProperties>
    </entry>
    <entry>
      <int>96</int>
      <net.rptools.maptool.model.MacroButtonProperties>
        <saveLocation>Token</saveLocation>
        <index>96</index>
        <colorKey>default</colorKey>
        <hotKey>None</hotKey>
        <command>[h:debugmode = getLibProperty(&quot;DEBUGMODE&quot;)]
[h:debugmacro = getMacroName()]
[h:assert(argCount() == 2, &quot;procMarks() requires exactly 2 arguments&quot;, 0)]
[h:markList = listSort(getTokenStates(&quot;,&quot;, &quot;Marks&quot;), &quot;A+&quot;)]
[h:marker = arg(0)]
[h:mark = arg(1)]
[h:start = getInitiativeRound()]
[h:expireList = &quot;,Beginning of Your Next Turn,End of Your Next Turn,Beginning of Target&apos;s Next Turn,End of Target&apos;s Next Turn,End of Encounter,Save Ends,No Save,Special&quot;]
[h:setProperty(&quot;procStateData&quot;, &quot;{}&quot;)]

[h:markRules = getLibProperty(&quot;ClassFeatures&quot;)]
[h:markSpecifics = json.get(markRules, mark)]
[h:markRangeInfo = json.get(markSpecifics, &quot;range&quot;)]
[h:markDuration = json.get(markSpecifics, &quot;duration&quot;)]
[h:friendlyName = json.get(markSpecifics, &quot;friendlyName&quot;)]
[h:markVerb = json.get(markSpecifics, &quot;verb&quot;)]

[h,switch(markRangeInfo),CODE:
case &quot;LOS&quot;:
{
[markRange = &quot;{}&quot;]
};
case &quot;nearest&quot;:
{
	[h:proximity=&quot;&quot;]
	[h,if(isPC(marker)):targetList=json.toList(getTokenNames(&quot;json&quot;, &apos;{npc:true, unsetStates:[&quot;Dead&quot;],  visible:true}&apos;)); targetList=json.toList(getTokenNames(&quot;json&quot;,  &apos;{pc:true, unsetStates:[&quot;Dead&quot;],  visible:true}&apos;))]
	[h,foreach(token,targetList): proximity = json.append(proximity, getDistance(token,0))]
	[h:proximity = json.sort(proximity, &quot;asc&quot;)]
	[h:rangeToNearest=json.get(proximity, 0)]
	[h:markRange = json.set(&quot;{}&quot;, &quot;from&quot;, 1, &quot;upto&quot;, rangeToNearest, &quot;distancePerCell&quot;, &quot;false&quot;, &quot;metric&quot;, &quot;ONE_ONE_ONE&quot;)]
};
default:
{
	[h:markRange = json.set(&quot;{}&quot;, &quot;from&quot;, 1, &quot;upto&quot;, markRangeInfo, &quot;distancePerCell&quot;, &quot;false&quot;, &quot;metric&quot;, &quot;ONE_ONE_ONE&quot;)]
};]

[h,if(isPC(marker)): getType = &quot;npc&quot;; getType = &quot;pc&quot;]

[h:targetFilter = json.set(&quot;{}&quot;, getType, 1, &quot;unsetStates&quot;, json.append(&quot;[]&quot;, &quot;Dead&quot;), &quot;visible&quot;, 1, &quot;range&quot;, markRange)]
[h:exp = getTokenNames(&quot;json&quot;, targetFilter)]
[h:expList = json.toList(exp)]

[H: imgList = expList]
[H: Num = listCount(imgList)]
	
[h,COUNT(Num),CODE:
{
	[h:targetName=listGet(imgList,roll.count)]
	[h,token(targetName): image=getTokenImage()]
	[h:imgList=listReplace(imgList,roll.count,targetName+&quot; &quot;+image)]
}]

[h:status=input(
   if(mark==&quot;Natures_Wrath&quot;, &quot;junkVar|&quot;+expList+&quot;|Targets who will be marked|LABEL&quot;, &quot;targetNum|&quot;+imgList+&quot;|Select Target(s) of &quot;+friendlyName+&quot;|LIST|SELECT=0 ICON=TRUE ICONSIZE=30&quot;), 
   if(mark==&quot;BasicMark&quot;, &quot;duration|&quot;+expireList+&quot;|Duration of Basic Mark|LIST|SELECT=0 VALUE=STRING&quot;, &quot;&quot;), &quot;clear|0|Clear &quot;+friendlyName+&quot; instead of designating it|CHECK&quot;)]
[h:abort(status)]

[h:targetList=listGet(expList,targetNum)]

[if(clear == 0),CODE:
{	
	[foreach(target,targetList),CODE:
	{
		[h:stateList = json.set(&quot;{}&quot;, mark, json.set(&quot;{}&quot;, &quot;expires&quot;, markDuration, &quot;ogDamAmt&quot;, 0))]
		[h:stateStep2 = json.set(&quot;{}&quot;, &quot;StateList&quot;, stateList, &quot;tokenName&quot;, getName(), &quot;hit&quot;, 1)]
		[h:procStateData = json.set(procStateData, target, stateStep2)]
		[h,token(target):setState(mark, 1)]
		[h:procStates(target)]
		[r:targetList] [r:if(listCount(targetList)&gt;1, &quot;are&quot;, &quot;is&quot;)] is now [r:markVerb] [r:marker].
	}]

};
{
   [foreach(target, targetList),CODE:
   {
	   [h,token(target):setState(mark,0)]
	   [h,token(target):MarkedBy = &quot;&quot;]
	   [h,token(target):ExternalTiming = json.remove(ExternalTiming, mark)]
	   [r:targetList] [r:if(listCount(targetList)&gt;1, &quot;are&quot;, &quot;is&quot;)] no longer [r:markVerb] [r:marker].
   }]
};]</command>
        <label>Marks and Quarries</label>
        <group>Combat - Marking</group>
        <sortby></sortby>
        <autoExecute>true</autoExecute>
        <includeLabel>false</includeLabel>
        <applyToTokens>false</applyToTokens>
        <fontColorKey>black</fontColorKey>
        <fontSize>1.00em</fontSize>
        <minWidth></minWidth>
        <maxWidth></maxWidth>
        <allowPlayerEdits>false</allowPlayerEdits>
        <toolTip></toolTip>
        <commonMacro>false</commonMacro>
        <compareGroup>true</compareGroup>
        <compareSortPrefix>true</compareSortPrefix>
        <compareCommand>true</compareCommand>
        <compareIncludeLabel>true</compareIncludeLabel>
        <compareAutoExecute>true</compareAutoExecute>
        <compareApplyToSelectedTokens>true</compareApplyToSelectedTokens>
      </net.rptools.maptool.model.MacroButtonProperties>
    </entry>
    <entry>
      <int>110</int>
      <net.rptools.maptool.model.MacroButtonProperties>
        <saveLocation>Token</saveLocation>
        <index>110</index>
        <colorKey>default</colorKey>
        <hotKey>None</hotKey>
        <command>[h,if(json.isEmpty(attStats)),CODE:
{
    [status=input(&quot;.|No game stats collected yet.||LABEL|SPAN=TRUE&quot;)]
    [h:abort(0)]
};
{
[h:statsList = listSort(json.fields(attStats), &quot;A+&quot;)]
[h:inputParams = json.append(&quot;&quot;, &quot;.|&lt;html&gt;&lt;b&gt;&lt;u&gt;Attack and Damage Statistics for &quot;+token.name+&quot;&lt;/u&gt;&lt;/b&gt;&lt;/html&gt;||LABEL|SPAN=TRUE&quot;)]
[h:allPowerHits = 0]
[h:allPowerRolls = 0]
[h:allPowerCrits = 0]
[h:allPowerDmg = 0]

[h,foreach(power, statsList),CODE:
{
       [attDetails = json.get(attStats, power)]
       [dmgDetails = json.get(dmgStats, power)]
       [powRolls = json.get(attDetails, &quot;rolls&quot;)]
       [powHits = json.get(attDetails, &quot;hits&quot;)]
       [powCrits = json.get(attDetails, &quot;crits&quot;)]
       [powDmgRolls = json.get(dmgDetails, &quot;rolls&quot;)]
       [powDmgTotal = json.get(dmgDetails, &quot;total&quot;)]
       [hitPercent = (powHits / powRolls) * 100]
       [if(powCrits &gt; 0): critPercent = (powCrits / powRolls) * 100; critPercent = 0]
       [dmgAvg = powDmgTotal / powRolls]
       [h:allPowerRolls = allPowerRolls + powRolls]
       [h:allPowerHits = allPowerHits + powHits]
       [h:allPowerCrits = allPowerCrits + powCrits]
       [h:allPowerDmg = allPowerDmg + powDmgTotal]
       [inputParams = json.append(inputParams, &quot;.|&lt;html&gt;&amp;nbsp;&amp;nbsp;&lt;b&gt;Hits&lt;/b&gt;: &quot;+powHits+&quot;/&quot;+powRolls+&quot; (&quot;+trimNumber(hitPercent, 1)+&quot;%); &quot;+&quot; &lt;b&gt;Criticals&lt;/b&gt;: &quot;+powCrits+&quot; (&quot;+trimNumber(critPercent, 2)+&quot;%); &quot;+&quot; &lt;b&gt;Average Damage&lt;/b&gt;: &quot;+trimNumber(dmgAvg,1)+&quot;|&lt;html&gt;&lt;b&gt;&quot;+power+&quot;&lt;/b&gt;&lt;/html&gt;|LABEL&quot;)]
}]

[h,if(allPowerHits &gt; 0),code:
{
   [apCritPercent = (allPowerCrits/allPowerHits)*100]
   [apDmgAvg = (allPowerDmg/allPowerHits)]
};
{
   [apCritPercent = 0]
   [apDmgAvg = 0]
};]

[h:inputParams = json.append(inputParams, &quot;.|&lt;html&gt;&lt;b&gt;&lt;u&gt;Total Hit, Critical, and Damage Statistics&lt;/u&gt;&lt;/b&gt;&lt;/html&gt;||LABEL|SPAN=TRUE&quot;)]
[h:inputParams = json.append(inputParams, &quot;.|&lt;html&gt;&lt;b&gt;Hits&lt;/b&gt;: &quot;+allPowerHits+&quot;/&quot;+allPowerRolls+&quot; (&quot;+trimNumber((allPowerHits/allPowerRolls)*100, 2)+&quot;%); &quot;+&quot; &lt;b&gt;Critical&lt;/b&gt;: &quot;+trimNumber(apCritPercent, 2)+&quot;%; &quot;+&quot; &lt;b&gt;Total Damage&lt;/b&gt;: &quot;+allPowerDmg+&quot; (&quot;+trimNumber(apDmgAvg, 2)+&quot; avg. per hit)&lt;/html&gt;||LABEL|SPAN=TRUE&quot;)]


[h:inputParams = json.toList(inputParams, &quot;##&quot;)]
[h:status = input(inputParams)]
[h:abort(status)]
};]</command>
        <label>Show Play Stats</label>
        <group>Character Management</group>
        <sortby></sortby>
        <autoExecute>true</autoExecute>
        <includeLabel>false</includeLabel>
        <applyToTokens>false</applyToTokens>
        <fontColorKey>black</fontColorKey>
        <fontSize>1.00em</fontSize>
        <minWidth></minWidth>
        <maxWidth></maxWidth>
        <allowPlayerEdits>true</allowPlayerEdits>
        <toolTip></toolTip>
        <commonMacro>false</commonMacro>
        <compareGroup>true</compareGroup>
        <compareSortPrefix>true</compareSortPrefix>
        <compareCommand>true</compareCommand>
        <compareIncludeLabel>true</compareIncludeLabel>
        <compareAutoExecute>true</compareAutoExecute>
        <compareApplyToSelectedTokens>true</compareApplyToSelectedTokens>
      </net.rptools.maptool.model.MacroButtonProperties>
    </entry>
    <entry>
      <int>111</int>
      <net.rptools.maptool.model.MacroButtonProperties>
        <saveLocation>Token</saveLocation>
        <index>111</index>
        <colorKey>default</colorKey>
        <hotKey>None</hotKey>
        <command>[assert(argCount() != 0, &quot;trimNumber() requires at least one parameter.&quot;)]
[assert(argCount() &lt;= 3, &quot;trimNumber() accepts a maximum of three parameters.&quot;)]
[NumberToTrim = arg(0)]
&lt;!-- Set truncation depth --&gt;
[if(argCount() &gt;= 2), code:
{
    [TruncationDepth = power(10, arg(1))]
};{
    [TruncationDepth = power(10, 10)]
}]
&lt;!-- Set rounding method --&gt;
[if(argCount() == 3), code:
{
    [RoundingMethod = substring(arg(2), 0 , 1)]
};{
    [RoundingMethod = 0]
}]
&lt;!-- Perform trim --&gt;
[switch(RoundingMethod):
    case &quot;u&quot;: NumberToTrim = ceiling(NumberToTrim*TruncationDepth)/TruncationDepth;
    case &quot;d&quot;: NumberToTrim = floor(NumberToTrim*TruncationDepth)/TruncationDepth;
    default: NumberToTrim = round(NumberToTrim*TruncationDepth)/TruncationDepth
]
[macro.return = NumberToTrim]</command>
        <label>trimNumber</label>
        <group>User-Defined Functions</group>
        <sortby></sortby>
        <autoExecute>true</autoExecute>
        <includeLabel>false</includeLabel>
        <applyToTokens>false</applyToTokens>
        <fontColorKey>black</fontColorKey>
        <fontSize>1.00em</fontSize>
        <minWidth></minWidth>
        <maxWidth></maxWidth>
        <allowPlayerEdits>true</allowPlayerEdits>
        <toolTip></toolTip>
        <commonMacro>false</commonMacro>
        <compareGroup>true</compareGroup>
        <compareSortPrefix>true</compareSortPrefix>
        <compareCommand>true</compareCommand>
        <compareIncludeLabel>true</compareIncludeLabel>
        <compareAutoExecute>true</compareAutoExecute>
        <compareApplyToSelectedTokens>true</compareApplyToSelectedTokens>
      </net.rptools.maptool.model.MacroButtonProperties>
    </entry>
    <entry>
      <int>108</int>
      <net.rptools.maptool.model.MacroButtonProperties>
        <saveLocation>Token</saveLocation>
        <index>108</index>
        <colorKey>default</colorKey>
        <hotKey>None</hotKey>
        <command>[h:debugmode = getLibProperty(&quot;DEBUGMODE&quot;)]
[h:debugMacro = getMacroName()]
[h:imposingChar = arg(0)]
[h:character = arg(1)]
[h:currentRound = arg(2)]
[h:turnStart = arg(3)]
[h:initToken = getInitiativeToken()]
[h,if(turnStart): expireList = &quot;Beginning of Your Next Turn,Beginning of Target&apos;s Next Turn,Beginning of Next Turn&quot;; expireList = &quot;End of Your Next Turn,End of Target&apos;s Next Turn,End of Next Turn&quot;]
[h:realMarks = getLibProperty(&quot;TrueMarks&quot;)]
[h:defAdjust = listAppend(getLibProperty(&quot;DefAdjustments&quot;), &quot;SecondWindBonus&quot;)]
[h:attAdjust = getLibProperty(&quot;AttAdjustments&quot;)]
[h:rvAdjust =getLibProperty(&quot;RVAdjusts&quot;)]

[h:switchToken(character)]
[h:condObj = getProperty(&quot;ExternalTiming&quot;)]
[h:tokenConditionList = json.fields(condObj)]
[h:odObj = getProperty(&quot;OngoingDamage&quot;)]
[h:tokenODList = json.fields(odObj)]

   
[foreach(condition, tokenConditionList,&quot;&quot;),CODE:
{
   [h:condInfo = json.get(condObj, condition)]
   [h:imposedBy = json.get(condInfo, &quot;imposedBy&quot;)]
 
     [if(debugmode): debug(&quot;debugMacro&quot;, &quot;condInfo&quot;, &quot;imposedBy&quot;)]


   &lt;!--Handle regeneration as a special condition--&gt;
   [if(condition == &quot;Regeneration&quot; &amp;&amp; turnStart &amp;&amp; currentToken() == initToken),CODE:
   {
      [h:regenAmt = json.get(condInfo, &quot;ogDamAmt&quot;)]
      [h,if(hasProperty(&quot;rfw.suspendRegen&quot;)==0): hasSRprop = 0; hasSRProp = 1]
      [h,if(hasSRprop): suspend = getProperty(&quot;rfw.suspendRegen&quot;); suspend=0)]
      [r,if(suspend == 0):procHealing(regenAmt, &quot;regenerates&quot;, &quot;General&quot;, 0)]

      [h:condObj = ExternalTiming]
   };{};]
   &lt;!--End regeneration handler--&gt;

   [h:expires = json.get(condInfo, &quot;expires&quot;)]
   [h,if(listFind(expireList, expires) != -1): expiresNow=1; expiresNow =0]
   [h:startRound = json.get(condInfo, &quot;start&quot;)]
    &lt;!--If the condition is imposed by the character whose turn just ended, check to see if it should expire, and if so, make it so--&gt;
   [h,if(imposedBy == imposingChar &amp;&amp; expiresNow &amp;&amp; currentRound == startRound+1),CODE:
   {
	   [if(listFind(defAdjust, condition)!=-1): restoreDefenses(condition)]
	   [if(listFind(rvAdjust,condition)!=-1): restoreRV(condition)]
	   [if(listFind(attAdjust, condition)!=-1): restoreAttacks()]
	   [if(listFind(realMarks,condition) != -1): MarkedBy = &quot;&quot;]
       [setState(condition, 0)]
       [condObj = json.remove(condObj, condition)]
   };{};]
   [h:ExternalTiming = condObj]
}]

&lt;!--Handle Ongoing Damage--&gt;
[foreach(ongoing, tokenODList,&quot;&quot;),CODE:
{
   [h:ongoingInfo = json.get(odObj, ongoing)]
   &lt;!--Handle damage at start of turns--&gt;
   [h,if(turnStart &amp;&amp; currentToken() == initToken ),code:
   {
      [h:dmgAmount = json.get(ongoingInfo, &quot;ogDamAmt&quot;)]
      [h:dmgType = lower(substring(ongoing,7))]
      [h:target = imposingChar]
      [h:newCurrDmg = json.set(&quot;{}&quot;, &quot;target&quot;, target, &quot;damage&quot;, dmgAmount, &quot;damtype&quot;,dmgType+&quot;, untyped, untyped&quot;, &quot;atktype&quot;, &quot;melee&quot;, &quot;doesHalfDmg&quot;,0, &quot;hit&quot;, &quot;hit&quot;)]
      [h:CurrentDamageInfo = json.set(currentDamageInfo, target, newCurrDmg)]
      [h,if(debugmode): debug(&quot;debugmacro&quot;,&quot;newCurrDmg&quot;)]
      [r:procDamage()]
    };{};]
  &lt;!--End Ongoing Damage Handler--&gt;

   [h:imposedBy = json.get(ongoingInfo, &quot;imposedBy&quot;)]
   [h:expires = json.get(ongoingInfo, &quot;expires&quot;)]
   [h,if(listFind(expireList, expires) != -1): expiresNow=1; expiresNow =0]
   [h:startRound = json.get(ongoingInfo, &quot;start&quot;)]
     &lt;!--If the condition is imposed by the character whose turn just ended, check to see if it should expire, and if so, make it so--&gt;
   [h,if(imposedBy == imposingChar &amp;&amp; expiresNow &amp;&amp; currentRound == startRound+1),CODE:
   {
       [setState(ongoing, 0)]
       [odObj = json.remove(odObj, ongoing)]
   }]
}]
[h:OngoingDamage = odObj]    

</command>
        <label>cycleTurn</label>
        <group>User-Defined Functions</group>
        <sortby></sortby>
        <autoExecute>true</autoExecute>
        <includeLabel>false</includeLabel>
        <applyToTokens>false</applyToTokens>
        <fontColorKey>black</fontColorKey>
        <fontSize>1.00em</fontSize>
        <minWidth></minWidth>
        <maxWidth></maxWidth>
        <allowPlayerEdits>true</allowPlayerEdits>
        <toolTip></toolTip>
        <commonMacro>false</commonMacro>
        <compareGroup>true</compareGroup>
        <compareSortPrefix>true</compareSortPrefix>
        <compareCommand>true</compareCommand>
        <compareIncludeLabel>true</compareIncludeLabel>
        <compareAutoExecute>true</compareAutoExecute>
        <compareApplyToSelectedTokens>true</compareApplyToSelectedTokens>
      </net.rptools.maptool.model.MacroButtonProperties>
    </entry>
    <entry>
      <int>109</int>
      <net.rptools.maptool.model.MacroButtonProperties>
        <saveLocation>Token</saveLocation>
        <index>109</index>
        <colorKey>default</colorKey>
        <hotKey>None</hotKey>
        <command>[h:me = getName()]
[h:charList = getTokens()]
[h:ogDmg = getProperty(&quot;OngoingDamage&quot;)]
[h:ogDmgList = json.fields(ogDmg)]
[h:allMyConditions = getProperty(&quot;ExternalTiming&quot;)]
[h:allMyConditionList = json.fields(allMyConditions)]
[h:currentRound = getInitiativeRound()]
[h:realMarks = getLibProperty(&quot;TrueMarks&quot;)]
[h:defAdjust = getLibProperty(&quot;DefAdjustments&quot;)]
[h:attAdjust = getLibProperty(&quot;AttAdjustments&quot;)]
[h:expireList = &quot;Beginning of Your Next Turn,Beginning of Target&apos;s Next Turn,Beginning of Next Turn&quot;]

[h:state.Immed_Reaction_Used = 0]
[h:state.Curse_Damage_Used = 0]
[h:state.Sneak_Attack_Used = 0]
[h:state.Quarry_Damage_Used = 0]

&lt;b&gt;Turn started&lt;/b&gt;

[h,foreach(character,charList,&quot;&quot;),CODE:
{
   [r:cycleTurn(me,character,currentRound,1)]
}]</command>
        <label>StartTurn</label>
        <group>Turns</group>
        <sortby></sortby>
        <autoExecute>true</autoExecute>
        <includeLabel>false</includeLabel>
        <applyToTokens>false</applyToTokens>
        <fontColorKey>black</fontColorKey>
        <fontSize>1.00em</fontSize>
        <minWidth></minWidth>
        <maxWidth></maxWidth>
        <allowPlayerEdits>false</allowPlayerEdits>
        <toolTip></toolTip>
        <commonMacro>false</commonMacro>
        <compareGroup>true</compareGroup>
        <compareSortPrefix>true</compareSortPrefix>
        <compareCommand>true</compareCommand>
        <compareIncludeLabel>true</compareIncludeLabel>
        <compareAutoExecute>true</compareAutoExecute>
        <compareApplyToSelectedTokens>true</compareApplyToSelectedTokens>
      </net.rptools.maptool.model.MacroButtonProperties>
    </entry>
    <entry>
      <int>106</int>
      <net.rptools.maptool.model.MacroButtonProperties>
        <saveLocation>Token</saveLocation>
        <index>106</index>
        <colorKey>default</colorKey>
        <hotKey>None</hotKey>
        <command>&lt;!--Undo the most recent adjustment to attack values--&gt;
[h:lastAdjustment = getProperty(&quot;LastAttackAdjustment&quot;)]
[h:adjAmount = json.get(lastAdjustment, &quot;adjustment&quot;)]
[h:setProperty(&quot;LastAttackAdjustment&quot;, lastAdjustment + (0 - adjAmount))]</command>
        <label>restoreAttacks</label>
        <group>User-Defined Functions</group>
        <sortby></sortby>
        <autoExecute>true</autoExecute>
        <includeLabel>false</includeLabel>
        <applyToTokens>false</applyToTokens>
        <fontColorKey>black</fontColorKey>
        <fontSize>1.00em</fontSize>
        <minWidth></minWidth>
        <maxWidth></maxWidth>
        <allowPlayerEdits>false</allowPlayerEdits>
        <toolTip></toolTip>
        <commonMacro>false</commonMacro>
        <compareGroup>true</compareGroup>
        <compareSortPrefix>true</compareSortPrefix>
        <compareCommand>true</compareCommand>
        <compareIncludeLabel>true</compareIncludeLabel>
        <compareAutoExecute>true</compareAutoExecute>
        <compareApplyToSelectedTokens>true</compareApplyToSelectedTokens>
      </net.rptools.maptool.model.MacroButtonProperties>
    </entry>
    <entry>
      <int>107</int>
      <net.rptools.maptool.model.MacroButtonProperties>
        <saveLocation>Token</saveLocation>
        <index>107</index>
        <colorKey>default</colorKey>
        <hotKey>None</hotKey>
        <command>[h:debugmode = getLibProperty(&quot;DEBUGMODE&quot;)]
[h:me = getName()]
[h:charListFilter = json.set(&quot;{}&quot;, &quot;unsetStates&quot;, &quot;[&apos;Reticle&apos;]&quot;)]
[h:charList = getTokenNames(&quot;,&quot;, charListFilter)]
[h:currentRound = getInitiativeRound()]
[h:savingThrow(1)]

[h,foreach(character,charList, &quot;&quot;): cycleTurn(me,character,currentRound,0)]

[h:currentStates = &quot;&quot;]
[h,foreach(state, getTokenStates()),CODE:
{
   [h,if(getState(state)): currentStates = listAppend(currentStates,state)]
   }]
   
[h:setProperty(&quot;CurrentStates&quot;,currentStates)]

[h:nextInitiative()]
[h:whoHasInit = getInitiativeToken()]
[h:switchToken(whoHasInit)]
[h,if(getInitiativeHold() == 0),CODE:
{
   [h:execMacro(&quot;[macro(&apos;StartTurn@Lib:4e&apos;): &apos;&apos;]&quot;)]
}]

</command>
        <label>EndTurn</label>
        <group>Turns</group>
        <sortby>1</sortby>
        <autoExecute>true</autoExecute>
        <includeLabel>false</includeLabel>
        <applyToTokens>false</applyToTokens>
        <fontColorKey>black</fontColorKey>
        <fontSize>1.00em</fontSize>
        <minWidth></minWidth>
        <maxWidth></maxWidth>
        <allowPlayerEdits>false</allowPlayerEdits>
        <toolTip></toolTip>
        <commonMacro>false</commonMacro>
        <compareGroup>true</compareGroup>
        <compareSortPrefix>true</compareSortPrefix>
        <compareCommand>true</compareCommand>
        <compareIncludeLabel>true</compareIncludeLabel>
        <compareAutoExecute>true</compareAutoExecute>
        <compareApplyToSelectedTokens>true</compareApplyToSelectedTokens>
      </net.rptools.maptool.model.MacroButtonProperties>
    </entry>
    <entry>
      <int>104</int>
      <net.rptools.maptool.model.MacroButtonProperties>
        <saveLocation>Token</saveLocation>
        <index>104</index>
        <colorKey>default</colorKey>
        <hotKey>None</hotKey>
        <command>[macro(&quot;AttackMain@Lib:4e&quot;):arg(0)]</command>
        <label>launchPower</label>
        <group>User-Defined Functions</group>
        <sortby></sortby>
        <autoExecute>true</autoExecute>
        <includeLabel>false</includeLabel>
        <applyToTokens>false</applyToTokens>
        <fontColorKey>black</fontColorKey>
        <fontSize>1.00em</fontSize>
        <minWidth></minWidth>
        <maxWidth></maxWidth>
        <allowPlayerEdits>false</allowPlayerEdits>
        <toolTip></toolTip>
        <commonMacro>false</commonMacro>
        <compareGroup>true</compareGroup>
        <compareSortPrefix>true</compareSortPrefix>
        <compareCommand>true</compareCommand>
        <compareIncludeLabel>true</compareIncludeLabel>
        <compareAutoExecute>true</compareAutoExecute>
        <compareApplyToSelectedTokens>true</compareApplyToSelectedTokens>
      </net.rptools.maptool.model.MacroButtonProperties>
    </entry>
    <entry>
      <int>105</int>
      <net.rptools.maptool.model.MacroButtonProperties>
        <saveLocation>Token</saveLocation>
        <index>105</index>
        <colorKey>default</colorKey>
        <hotKey>None</hotKey>
        <command>[h:state = arg(0)]
[h:amount = arg(1)]
[h:damType = lower(substring(state, 7))]

[h:Vulnerable = json.set(Vulnerable, damType, json.get(Vulnerable, damType)+amount)]
[h:TempVulnerable = json.set(TempVulnerable, damType, amount)]

</command>
        <label>procTempVulnerable</label>
        <group>User-Defined Functions</group>
        <sortby></sortby>
        <autoExecute>true</autoExecute>
        <includeLabel>false</includeLabel>
        <applyToTokens>false</applyToTokens>
        <fontColorKey>black</fontColorKey>
        <fontSize>1.00em</fontSize>
        <minWidth></minWidth>
        <maxWidth></maxWidth>
        <allowPlayerEdits>false</allowPlayerEdits>
        <toolTip></toolTip>
        <commonMacro>false</commonMacro>
        <compareGroup>true</compareGroup>
        <compareSortPrefix>true</compareSortPrefix>
        <compareCommand>true</compareCommand>
        <compareIncludeLabel>true</compareIncludeLabel>
        <compareAutoExecute>true</compareAutoExecute>
        <compareApplyToSelectedTokens>true</compareApplyToSelectedTokens>
      </net.rptools.maptool.model.MacroButtonProperties>
    </entry>
    <entry>
      <int>118</int>
      <net.rptools.maptool.model.MacroButtonProperties>
        <saveLocation>Token</saveLocation>
        <index>118</index>
        <colorKey>default</colorKey>
        <hotKey>None</hotKey>
        <command>[h:debugmode=getLibProperty(&quot;DEBUGMODE&quot;)]
[h:debugmacro=getMacroName()]
[h:currentPowerInfo = json.get(Powers,macro.args)]
[h:currentHitInfo = &quot;{}&quot;]
[h:currentDamageInfo = &quot;{}&quot;]
[h:setProperty(&quot;procStateData&quot;, &quot;{}&quot;)] 
[macro(&quot;Targeting@this&quot;):&quot;&quot;]

&lt;!--Display Power Name--&gt;
&lt;b&gt;[r:json.get(currentPowerInfo,&quot;powername&quot;)]&lt;/b&gt; ([r:json.get(currentPowerInfo,&quot;action&quot;)] action):&lt;br&gt;
&lt;!--Is this an AOE power?--&gt;
[h,if(json.get(currentPowerInfo, &quot;attackType&quot;)==&quot;area&quot; || json.get(currentPowerInfo,&quot;attackType&quot;)==&quot;close&quot;): aoe = 1; aoe = 0]
[h:targetList = json.get(currentAttackOptions,&quot;targets&quot;)]
[h:aoeDmgInfo = calcAOE(json.get(currentPowerInfo, &quot;damage&quot;), json.get(currentPowerInfo, &quot;critdamage&quot;))]

[foreach(SelectedEnemy,targetList,&quot;&lt;br&gt;&quot;),CODE:
{
    [h,if(aoe),CODE:
    {
          [fd = json.get(aoeDmgInfo,&quot;aoeDmg&quot;)]
          [fdb = json.get(aoeDmgInfo,&quot;aoeDmgBreakdown&quot;)]
          [fcd = json.get(aoeDmgInfo,&quot;aoeCritDmg&quot;)]
          [fcdb = json.get(aoeDmgInfo,&quot;aoeCritDmgBreakdown&quot;)]
    };
   {
          [fd = extractDice(json.get(currentPowerInfo,&quot;damage&quot;))]
          [fdb = macro.return]
          [fcd = extractDice(json.get(currentPowerInfo,&quot;critdamage&quot;))]
          [fcdb = macro.return]
    };]
[r:processAttack(SelectedEnemy,fd,fdb,fcd,fcdb, aoe)]
}]


[h,if(debugmode):debug(&quot;debugmacro&quot;, &quot;fd&quot;, &quot;fdb&quot;, &quot;fcd&quot;, &quot;fcdb&quot;)]


[h:stateTargetList = json.fields(procStateData)]

[h,foreach(SelectedEnemy,stateTargetList): procStates(SelectedEnemy)]

[h:hitEff=json.get(currentPowerInfo, &quot;hitEffect&quot;)]
[h:missEff=json.get(currentPowerInfo, &quot;missEffect&quot;)]
[h:alwaysEff=json.get(currentPowerInfo, &quot;alwaysEffect&quot;)]

[r:if(hitEff !=&quot;--none--&quot; &amp;&amp; hitEff != 0, &quot;&lt;br&gt;&lt;b&gt;Hit&lt;/b&gt;: &quot;+hitEff+&quot;&lt;br&gt;&quot;, &quot;&quot;)]  
[r:if(missEff !=&quot;--none--&quot; &amp;&amp; missEff != 0, &quot;&lt;b&gt;Miss&lt;/b&gt;: &quot;+missEff+&quot;&lt;br&gt;&quot;, &quot;&quot;)] 
[r:if(alwaysEff != &quot;--none--&quot; &amp;&amp; alwaysEff != 0, &quot;&lt;b&gt;Effect&lt;/b&gt;: &quot;+alwaysEff+&quot;&lt;br&gt;&quot;, &quot;&quot;)]

[macro(&quot;Tracker@this&quot;):&quot;&quot;]</command>
        <label>AttackMain</label>
        <group>Combat</group>
        <sortby></sortby>
        <autoExecute>true</autoExecute>
        <includeLabel>false</includeLabel>
        <applyToTokens>false</applyToTokens>
        <fontColorKey>black</fontColorKey>
        <fontSize>1.00em</fontSize>
        <minWidth></minWidth>
        <maxWidth></maxWidth>
        <allowPlayerEdits>true</allowPlayerEdits>
        <toolTip></toolTip>
        <commonMacro>false</commonMacro>
        <compareGroup>true</compareGroup>
        <compareSortPrefix>true</compareSortPrefix>
        <compareCommand>true</compareCommand>
        <compareIncludeLabel>true</compareIncludeLabel>
        <compareAutoExecute>true</compareAutoExecute>
        <compareApplyToSelectedTokens>true</compareApplyToSelectedTokens>
      </net.rptools.maptool.model.MacroButtonProperties>
    </entry>
    <entry>
      <int>117</int>
      <net.rptools.maptool.model.MacroButtonProperties>
        <saveLocation>Token</saveLocation>
        <index>117</index>
        <colorKey>default</colorKey>
        <hotKey>None</hotKey>
        <command>[h:debugmode=getLibProperty(&quot;DEBUGMODE&quot;)]
[h:pwrList = json.fields(Powers)]
[h:wrongCats = &quot;Item,Racial,Feature&quot;]
[h:appropPowers=&quot;[]&quot;]
[h:inBook = &quot;[]&quot;]
[h:memorized = &quot;[]&quot;]
[h,if(hasProperty(&quot;rfw.SBUpdated&quot;)==0): setProperty(&quot;rfw.SBUpdated&quot;, 0)]

&lt;!-- Run-once update to the Power List to be compatible with Spellbook Manager --&gt;
[h,if(getProperty(&quot;rfw.SBupdated&quot;) == 0),CODE:
{
   [h,foreach(power,pwrList),CODE:
   {
     [powerDetail = json.get(Powers, power)]
     [if(json.contains(powerDetail, &quot;spellbook&quot;)==0): sbPowerUpdate = json.set(powerDetail, &quot;spellbook&quot;, 0); sbPowerUpdate = powerDetail]
     [Powers = json.set(Powers, power, sbPowerUpdate)]
   }]
   [setProperty(&quot;rfw.SBUpdated&quot;, 1)]
};{};]


[h:inputParams = json.append(&quot;&quot;, &quot;.|&lt;html&gt;&lt;b&gt;Spellbook Management&lt;/b&gt;&lt;/html&gt;||LABEL|SPAN=TRUE&quot;,&quot;.|&lt;html&gt;&lt;u&gt;Currently in Spellbook (check spell to memorize)&lt;/u&gt;&lt;/html&gt;||LABEL|SPAN=TRUE&quot;)]

[h,foreach(power,pwrList),CODE:
{
	[powerDetail = json.get(Powers,power)]
	[cat = json.get(powerDetail,&quot;pCategory&quot;)]
	[use = json.get(powerDetail, &quot;usage&quot;)]
	[if(use == &quot;daily&quot; &amp;&amp; listFind(wrongCats,cat) == -1): appropPowers =json.append(appropPowers, power)]
	[if(cat == &quot;Utility&quot;): appropPowers = json.append(appropPowers, power)]
}]

[h,foreach(power,appropPowers),CODE:
{
	[powerDetail = json.get(Powers,power)]
	[if(json.get(powerDetail, &quot;spellbook&quot;)==1): inBook =json.append(inBook, power); inBook = inBook]
                     [if(json.get(powerDetail, &quot;spellbook&quot;)==0):memorized =json.append(memorized,power); memorized=memorized]
}]
[if(debugmode):debug(&quot;inBook&quot;, &quot;memorized&quot;)]

[h:inBook = json.toList(json.unique(inBook))]
[h:memorized = json.toList(json.unique(memorized))]

[h,if(inBook != &quot;&quot; || memorized != &quot;&quot;),CODE:
{
	[foreach(spell,inBook): inputParams = json.append(inputParams, &quot;sbSpell&quot;+roll.count+&quot;|0|&quot;+spell+&quot;|CHECK&quot;)]
	[inputParams = json.append(inputParams, &quot;.|&lt;html&gt;&lt;u&gt;Currently Memorized (check spell to move to spellbook)&lt;/u&gt;&lt;/html&gt;||LABEL|SPAN=TRUE&quot;)]
	[foreach(spell,memorized): inputParams = json.append(inputParams, &quot;memSpell&quot;+roll.count+&quot;|0|&quot;+spell+&quot;|CHECK&quot;)]
};
{};]


[h:inputParams = json.toList(inputParams, &quot;##&quot;)]
[h:status = input(inputParams)]
[h:abort(status)]


[h,foreach(spell,inBook),CODE:
{
	[spellDetail = json.get(Powers, spell)]
	[use = json.get(spellDetail, &quot;usage&quot;)]
	[switch(use):
	 case &quot;at-will&quot;: useGroup=&quot;1. At-Will&quot;;
	 case &quot;encounter&quot;: useGroup=&quot;2. Encounter&quot;;
	 case &quot;daily&quot;: useGroup=&quot;3. Daily&quot;;
	 case &quot;recharge&quot;: useGroup = &quot;4. Recharge&quot;;]
	 
	[memorizeIt = eval(&quot;sbSpell&quot;+roll.count)]
	[if(memorizeIt),CODE:
	{
		[propString = &quot;group=&quot;+useGroup+&quot;;&quot;]
		[setMacroProps(spell, propString)]
		[newPowDetail = json.set(json.get(Powers,spell), &quot;spellbook&quot;, 0)]
		[Powers = json.set(Powers, spell, newPowDetail)]
	};{}]
}]


[h,foreach(spell,memorized),CODE:
{
	[putInBook = eval(&quot;memSpell&quot;+roll.count)]
	[if(putInBook),CODE:
	{
		[propString = &quot;group=5. Spellbook;&quot;]
		[setMacroProps(spell, propString)]
		[newPowDetail = json.set(json.get(Powers,spell), &quot;spellbook&quot;, 1)]
		[Powers = json.set(Powers, spell, newPowDetail)]
	};{}]
}]

	
</command>
        <label>Spellbook Manager</label>
        <group>Power Management</group>
        <sortby></sortby>
        <autoExecute>true</autoExecute>
        <includeLabel>false</includeLabel>
        <applyToTokens>false</applyToTokens>
        <fontColorKey>black</fontColorKey>
        <fontSize>1.00em</fontSize>
        <minWidth></minWidth>
        <maxWidth></maxWidth>
        <allowPlayerEdits>false</allowPlayerEdits>
        <toolTip></toolTip>
        <commonMacro>false</commonMacro>
        <compareGroup>true</compareGroup>
        <compareSortPrefix>true</compareSortPrefix>
        <compareCommand>true</compareCommand>
        <compareIncludeLabel>true</compareIncludeLabel>
        <compareAutoExecute>true</compareAutoExecute>
        <compareApplyToSelectedTokens>true</compareApplyToSelectedTokens>
      </net.rptools.maptool.model.MacroButtonProperties>
    </entry>
    <entry>
      <int>115</int>
      <net.rptools.maptool.model.MacroButtonProperties>
        <saveLocation>Token</saveLocation>
        <index>115</index>
        <colorKey>default</colorKey>
        <hotKey>None</hotKey>
        <command>[h:nextInitiative()]</command>
        <label>advanceInit</label>
        <group>User-Defined Functions</group>
        <sortby></sortby>
        <autoExecute>true</autoExecute>
        <includeLabel>false</includeLabel>
        <applyToTokens>false</applyToTokens>
        <fontColorKey>black</fontColorKey>
        <fontSize>1.00em</fontSize>
        <minWidth></minWidth>
        <maxWidth></maxWidth>
        <allowPlayerEdits>true</allowPlayerEdits>
        <toolTip></toolTip>
        <commonMacro>false</commonMacro>
        <compareGroup>true</compareGroup>
        <compareSortPrefix>true</compareSortPrefix>
        <compareCommand>true</compareCommand>
        <compareIncludeLabel>true</compareIncludeLabel>
        <compareAutoExecute>true</compareAutoExecute>
        <compareApplyToSelectedTokens>true</compareApplyToSelectedTokens>
      </net.rptools.maptool.model.MacroButtonProperties>
    </entry>
    <entry>
      <int>114</int>
      <net.rptools.maptool.model.MacroButtonProperties>
        <saveLocation>Token</saveLocation>
        <index>114</index>
        <colorKey>default</colorKey>
        <hotKey>None</hotKey>
        <command>&lt;!--Determine if altering resistances or vulnerabilities and what damage type to restore--&gt;
[h:source = arg(0)]
[h:whichCat = substring(source,0,6)]
[h:type = lower(substring(source,7))]

[h,if(whichCat == &quot;Resist&quot;),CODE:
{
  [tmpResVal = json.get(TempResist, type)]
  [currentResVal = json.get(Resist, type)]
  [newVal = currentResVal - tmpResVal]
  [Resist = json.set(Resist, type, newVal)]
  [TempResist = json.remove(TempResist, type)]
};
{
  [tmpVulnerableVal = json.get(TempVulnerable, type)]
  [currentVulnVal = json.get(Vulnerable, type)]
  [newVal = currentVulnVal - tmpVulnerableVal]
  [Vulnerable = json.set(Vulnerable, type, newVal)]
  [TempVulnerable = json.remove(TempVulnerable, type)]
};]</command>
        <label>restoreRV</label>
        <group>User-Defined Functions</group>
        <sortby></sortby>
        <autoExecute>true</autoExecute>
        <includeLabel>false</includeLabel>
        <applyToTokens>false</applyToTokens>
        <fontColorKey>black</fontColorKey>
        <fontSize>1.00em</fontSize>
        <minWidth></minWidth>
        <maxWidth></maxWidth>
        <allowPlayerEdits>false</allowPlayerEdits>
        <toolTip></toolTip>
        <commonMacro>false</commonMacro>
        <compareGroup>true</compareGroup>
        <compareSortPrefix>true</compareSortPrefix>
        <compareCommand>true</compareCommand>
        <compareIncludeLabel>true</compareIncludeLabel>
        <compareAutoExecute>true</compareAutoExecute>
        <compareApplyToSelectedTokens>true</compareApplyToSelectedTokens>
      </net.rptools.maptool.model.MacroButtonProperties>
    </entry>
    <entry>
      <int>113</int>
      <net.rptools.maptool.model.MacroButtonProperties>
        <saveLocation>Token</saveLocation>
        <index>113</index>
        <colorKey>default</colorKey>
        <hotKey>None</hotKey>
        <command>[h:state = arg(0)]
[h:amount = arg(1)]
[h:damType = lower(substring(state, 7))]
[h:Resist = json.set(Resist, damType, json.get(Resist, damType)+amount)]
[h:TempResist = json.set(TempResist, damType, amount)]

</command>
        <label>procTempResist</label>
        <group>User-Defined Functions</group>
        <sortby></sortby>
        <autoExecute>true</autoExecute>
        <includeLabel>false</includeLabel>
        <applyToTokens>false</applyToTokens>
        <fontColorKey>black</fontColorKey>
        <fontSize>1.00em</fontSize>
        <minWidth></minWidth>
        <maxWidth></maxWidth>
        <allowPlayerEdits>false</allowPlayerEdits>
        <toolTip></toolTip>
        <commonMacro>false</commonMacro>
        <compareGroup>true</compareGroup>
        <compareSortPrefix>true</compareSortPrefix>
        <compareCommand>true</compareCommand>
        <compareIncludeLabel>true</compareIncludeLabel>
        <compareAutoExecute>true</compareAutoExecute>
        <compareApplyToSelectedTokens>true</compareApplyToSelectedTokens>
      </net.rptools.maptool.model.MacroButtonProperties>
    </entry>
    <entry>
      <int>112</int>
      <net.rptools.maptool.model.MacroButtonProperties>
        <saveLocation>Token</saveLocation>
        <index>112</index>
        <colorKey>default</colorKey>
        <hotKey>None</hotKey>
        <command>[h:defPrompt = input(&quot;.|&lt;html&gt;&lt;b&gt;Enter the defense bonus or penalty information below:&lt;/b&gt;&lt;/html&gt;||LABEL|SPAN=TRUE&quot;,
	 	        &quot;bpAmount|0|Bonus or penalty amount (use negative numbers for penalties)&quot;,
		        &quot;whichDef|AC,Fortitude,Reflex,Will,All Defenses|Applies to which defense(s)?|RADIO|SELECT=0 VALUE=STRING&quot;)]
[h:abort(defPrompt)]
[h,if(whichDef == &quot;AC&quot; || whichDef == &quot;All Defenses&quot;): AC = AC+bpAmount]
[h,if(whichDef == &quot;Reflex&quot; || whichDef == &quot;All Defenses&quot;): Reflex = Reflex + bpAmount]
[h,if(whichDef == &quot;Fortitude&quot; || whichDef == &quot;All Defenses&quot;): Fortitude = Fortitude + bpAmount]
[h,if(whichDef == &quot;Will&quot; || whichDef == &quot;All Defenses&quot;): Will = Will + bpAmount]
[h:lastDefAdjust = json.set(&quot;{}&quot;, &quot;defense&quot;, whichDef, &quot;adjustment&quot;, bpAmount)]
[h:setProperty(&quot;LastDefenseAdjustment&quot;,lastDefAdjust)]</command>
        <label>procDefBonus</label>
        <group>User-Defined Functions</group>
        <sortby></sortby>
        <autoExecute>true</autoExecute>
        <includeLabel>false</includeLabel>
        <applyToTokens>false</applyToTokens>
        <fontColorKey>black</fontColorKey>
        <fontSize>1.00em</fontSize>
        <minWidth></minWidth>
        <maxWidth></maxWidth>
        <allowPlayerEdits>false</allowPlayerEdits>
        <toolTip></toolTip>
        <commonMacro>false</commonMacro>
        <compareGroup>true</compareGroup>
        <compareSortPrefix>true</compareSortPrefix>
        <compareCommand>true</compareCommand>
        <compareIncludeLabel>true</compareIncludeLabel>
        <compareAutoExecute>true</compareAutoExecute>
        <compareApplyToSelectedTokens>true</compareApplyToSelectedTokens>
      </net.rptools.maptool.model.MacroButtonProperties>
    </entry>
    <entry>
      <int>125</int>
      <net.rptools.maptool.model.MacroButtonProperties>
        <saveLocation>Token</saveLocation>
        <index>125</index>
        <colorKey>default</colorKey>
        <hotKey>None</hotKey>
        <command>&lt;!--Best of Two Roll Handler function--&gt;
[h:assert(argCount() == 3, &quot;rollTwice() requires exactly 3 arguments&quot;, 0)]
[h:oath = arg(0)]
[h:attackType = arg(1)]
[h:selPowName = arg(2)]
[h,if(oath == 1 &amp;&amp; attackType == &quot;melee&quot;): underOath = 1; underOath = 0]
[h,IF(selPowName ==&quot;Split the Tree&quot; || underOath==1):return=max(1d20,1d20); return=0]

[r:return]</command>
        <label>rollTwice</label>
        <group>User-Defined Functions</group>
        <sortby></sortby>
        <autoExecute>true</autoExecute>
        <includeLabel>false</includeLabel>
        <applyToTokens>false</applyToTokens>
        <fontColorKey>black</fontColorKey>
        <fontSize>1.00em</fontSize>
        <minWidth></minWidth>
        <maxWidth></maxWidth>
        <allowPlayerEdits>false</allowPlayerEdits>
        <toolTip></toolTip>
        <commonMacro>false</commonMacro>
        <compareGroup>true</compareGroup>
        <compareSortPrefix>true</compareSortPrefix>
        <compareCommand>true</compareCommand>
        <compareIncludeLabel>true</compareIncludeLabel>
        <compareAutoExecute>true</compareAutoExecute>
        <compareApplyToSelectedTokens>true</compareApplyToSelectedTokens>
      </net.rptools.maptool.model.MacroButtonProperties>
    </entry>
    <entry>
      <int>124</int>
      <net.rptools.maptool.model.MacroButtonProperties>
        <saveLocation>Token</saveLocation>
        <index>124</index>
        <colorKey>default</colorKey>
        <hotKey>None</hotKey>
        <command>&lt;!--Determine single damage amount for AOE powers--&gt;
[h:assert(argCount() == 2, &quot;calcAOE() requires exactly 2 arguments&quot;, 0)]
[h:powDmg = arg(0)]
[h:powCritDmg = arg(1)]
[h:aoeDmg = extractDice(powDmg)]
[h:aoeDmgBreakdown = macro.return)]
[h:aoeCritDmg = extractDice(powCritDmg)]
[h:aoeCritDmgBreakdown = macro.return]
[h:return = json.set(&quot;{}&quot;, &quot;aoeDmg&quot;, aoeDmg, &quot;aoeDmgBreakdown&quot;, aoeDmgBreakdown, &quot;aoeCritDmg&quot;, aoeCritDmg, &quot;aoeCritDmgBreakdown&quot;, aoeCritDmgBreakdown)]
[r:return]</command>
        <label>calcAOE</label>
        <group>User-Defined Functions</group>
        <sortby></sortby>
        <autoExecute>true</autoExecute>
        <includeLabel>false</includeLabel>
        <applyToTokens>false</applyToTokens>
        <fontColorKey>black</fontColorKey>
        <fontSize>1.00em</fontSize>
        <minWidth></minWidth>
        <maxWidth></maxWidth>
        <allowPlayerEdits>false</allowPlayerEdits>
        <toolTip></toolTip>
        <commonMacro>false</commonMacro>
        <compareGroup>true</compareGroup>
        <compareSortPrefix>true</compareSortPrefix>
        <compareCommand>true</compareCommand>
        <compareIncludeLabel>true</compareIncludeLabel>
        <compareAutoExecute>true</compareAutoExecute>
        <compareApplyToSelectedTokens>true</compareApplyToSelectedTokens>
      </net.rptools.maptool.model.MacroButtonProperties>
    </entry>
    <entry>
      <int>123</int>
      <net.rptools.maptool.model.MacroButtonProperties>
        <saveLocation>Token</saveLocation>
        <index>123</index>
        <colorKey>default</colorKey>
        <hotKey>None</hotKey>
        <command>&lt;!-- Stats Processing - how many hits, crits, and damage --&gt;

[h:attRollIncrement = json.get(statsLine, 0)]
[h:hitIncrement = json.get(statsLine, 1)]
[h:critcount = json.get(statsLine, 2)]
[h:damRollIncrement = json.get(statsLine,3)]
[h:totalDam = json.get(statsLine, 4)]
[h:powername = json.get(statsLine, 5)]

[h,if(json.contains(attStats, powerName)==0), CODE:
	{
	   [h:tmpD20Stats = &quot;{}&quot;]
	   [h:tmpStatsRolls = 0]
	   [h:tmpStatsHits = 0]
	   [h:tmpStatsCrits = 0]
	};
	{
	   [h:tmpD20Stats = json.get(attStats, powerName)]
	   [h:tmpStatsRolls = json.get(tmpD20Stats, &quot;rolls&quot;)]
	   [h:tmpStatsHits = json.get(tmpD20Stats, &quot;hits&quot;)]
	   [h:tmpStatsCrits = json.get(tmpD20Stats,&quot;crits&quot;)]
	};]
	[h:tmpD20Stats = json.set(tmpD20Stats, &quot;rolls&quot;, tmpStatsRolls+attRollIncrement, &quot;hits&quot;, tmpStatsHits+hitIncrement, &quot;crits&quot;, tmpStatsCrits+critcount)]
	[h:attStats = json.set(attStats, powerName, tmpD20Stats))]

	[h,if(json.contains(dmgStats, powername)==0),CODE:
	{
	   [tmpDmgStats = &quot;{}&quot;]
	   [tmpDmgRolls = 0]
	   [tmpDmgTotal = 0]
	};
	{
	[h:tmpDmgStats = json.get(dmgStats, powerName)]
	[h:tmpDmgRolls = json.get(tmpDmgStats, &quot;rolls&quot;)]
	[h:tmpDmgTotal = json.get(tmpDmgStats, &quot;total&quot;)]
	};]
	[h:tmpDmgStats = json.set(tmpDmgStats, &quot;rolls&quot;, tmpDmgRolls+damRollIncrement, &quot;total&quot;, tmpDmgTotal+totalDam)]
	[h:dmgStats = json.set(dmgStats, powerName, tmpDmgStats))]


</command>
        <label>updateStats</label>
        <group>User-Defined Functions</group>
        <sortby></sortby>
        <autoExecute>true</autoExecute>
        <includeLabel>false</includeLabel>
        <applyToTokens>false</applyToTokens>
        <fontColorKey>black</fontColorKey>
        <fontSize>1.00em</fontSize>
        <minWidth></minWidth>
        <maxWidth></maxWidth>
        <allowPlayerEdits>false</allowPlayerEdits>
        <toolTip></toolTip>
        <commonMacro>false</commonMacro>
        <compareGroup>true</compareGroup>
        <compareSortPrefix>true</compareSortPrefix>
        <compareCommand>true</compareCommand>
        <compareIncludeLabel>true</compareIncludeLabel>
        <compareAutoExecute>true</compareAutoExecute>
        <compareApplyToSelectedTokens>true</compareApplyToSelectedTokens>
      </net.rptools.maptool.model.MacroButtonProperties>
    </entry>
    <entry>
      <int>122</int>
      <net.rptools.maptool.model.MacroButtonProperties>
        <saveLocation>Token</saveLocation>
        <index>122</index>
        <colorKey>default</colorKey>
        <hotKey>None</hotKey>
        <command>[h:assert(argCount() == 5, &quot;getTargetSpecs() requires exactly 5 arguments&quot;, 0)]
[h:SelectedEnemy = arg(0)]
[h:nominalRange = arg(1)]
[h:against = arg(2)]
[h:aoe = arg(3)]
[h:rangePen = arg(4)]
[h,if(MarkedBy!=&quot;&quot; &amp;&amp; SelectedEnemy != MarkedBy): markPen=2; markPen=0]
[h:bCenter = token.name+&quot;BurstCenter&quot;]

    [h:targetRange=getDistance(SelectedEnemy,0,bCenter,&quot;ONE_ONE_ONE&quot;)]
    [h,if(targetRange &gt; nominalRange):rangePen=rangePen+2; rangePen = rangePen]
    [h,token(SelectedEnemy),CODE:
    {
        [targetDef=getProperty(string(against))]
        [concPen=if(aoe==0 &amp;&amp; state.Concealed==1, 2, 0)]
        [invisPen = if(aoe==0 &amp;&amp; state.Invisible==1, 5, 0)]
        [hiddenPen = if(aoe==0 &amp;&amp; state.TotalConcealment==1,5,0)]
    }]
[r:return = json.set(&quot;{}&quot;, &quot;markPen&quot;, markPen, &quot;rangePen&quot;, rangePen, &quot;targetDef&quot;, targetDef, &quot;concPen&quot;, concPen, &quot;invisPen&quot;, invisPen, &quot;hiddenPen&quot;, hiddenPen)]</command>
        <label>getTargetSpecs</label>
        <group>User-Defined Functions</group>
        <sortby></sortby>
        <autoExecute>true</autoExecute>
        <includeLabel>false</includeLabel>
        <applyToTokens>false</applyToTokens>
        <fontColorKey>black</fontColorKey>
        <fontSize>1.00em</fontSize>
        <minWidth></minWidth>
        <maxWidth></maxWidth>
        <allowPlayerEdits>false</allowPlayerEdits>
        <toolTip></toolTip>
        <commonMacro>false</commonMacro>
        <compareGroup>true</compareGroup>
        <compareSortPrefix>true</compareSortPrefix>
        <compareCommand>true</compareCommand>
        <compareIncludeLabel>true</compareIncludeLabel>
        <compareAutoExecute>true</compareAutoExecute>
        <compareApplyToSelectedTokens>true</compareApplyToSelectedTokens>
      </net.rptools.maptool.model.MacroButtonProperties>
    </entry>
    <entry>
      <int>121</int>
      <net.rptools.maptool.model.MacroButtonProperties>
        <saveLocation>Token</saveLocation>
        <index>121</index>
        <colorKey>default</colorKey>
        <hotKey>None</hotKey>
        <command>&lt;!--Get Basic Info and initialize variables--&gt;
[h:debugmode = getLibProperty(&quot;DEBUGMODE&quot;)]
[h:me=getName()]
[h:calledByPC=isPC(me)]
[h:maxRange=json.get(currentPowerInfo, &quot;maximumRange&quot;)]
[h:pName = json.get(currentPowerInfo, &quot;powername&quot;)]
[h:pTargets = json.get(currentPowerInfo, &quot;targets&quot;)]
[h:attType = json.get(currentPowerInfo, &quot;attackType&quot;)]
[h,if(json.get(currentPowerInfo,&quot;requirements&quot;)!=&quot;&quot; &amp;&amp; json.get(currentPowerInfo,&quot;requirements&quot;)!=&quot;--none--&quot;): pReqs = json.get(currentPowerInfo,&quot;requirements&quot;); pReqs=&quot;&quot;]
[h,if(json.get(currentPowerInfo,&quot;hitEffect&quot;)!=&quot;&quot; &amp;&amp; json.get(currentPowerInfo,&quot;hitEffect&quot;)!=&quot;--none--&quot;): phEff = json.get(currentPowerInfo,&quot;hitEffect&quot;); phEff=&quot;&quot;]
[h,if(json.get(currentPowerInfo,&quot;missEffect&quot;)!=&quot;&quot; &amp;&amp; json.get(currentPowerInfo,&quot;missEffect&quot;)!=&quot;--none--&quot;): pmEff = json.get(currentPowerInfo,&quot;missEffect&quot;); pmEff=&quot;&quot;]
[h,if(json.get(currentPowerInfo,&quot;alwaysEffect&quot;)!=&quot;&quot; &amp;&amp; json.get(currentPowerInfo,&quot;alwaysEffect&quot;)!=&quot;--none--&quot;): paEff = json.get(currentPowerInfo,&quot;alwaysEffect&quot;); paEff=&quot;&quot;]
[h:caInfo = json.set(&quot;{}&quot;, &quot;key&quot;, &quot;0&quot;)]
[h:coverInfo = json.set(&quot;{}&quot;, &quot;key&quot;, &quot;0&quot;)]
[h:targList = &quot;&quot;]
[h:oath = 0]
[h:rangeFilter = json.set(&quot;{}&quot;, &quot;from&quot;, if(attType==&quot;area&quot;, 0, 1), &quot;upto&quot;, maxRange, &quot;distancePerCell&quot;, &quot;false&quot;, &quot;metric&quot;, &quot;ONE_ONE_ONE&quot;)]
[h:reticle = me+&quot;BurstCenter&quot;]

&lt;!--Determine which targeting dialog is needed--&gt;
[h,switch(pTargets),CODE:
case &quot;one creature&quot;:
{  
    [targetDialog = 0]
    [targetFilter = json.set(&quot;{}&quot;, &quot;pc&quot;, if(calledByPC, 0, 1), &quot;npc&quot;, if(calledByPC, 1, 0), &quot;unsetStates&quot;, json.append(&quot;[]&quot;, &quot;Dead&quot;, &quot;Reticle&quot;), &quot;visible&quot;, 1, &quot;range&quot;, rangeFilter)]
};
case &quot;one or two creatures&quot;:
{
    [targetDialog = 1]
     [targetFilter = json.set(&quot;{}&quot;, &quot;pc&quot;, if(calledByPC, 0, 1), &quot;npc&quot;, if(calledByPC, 1, 0), &quot;unsetStates&quot;, json.append(&quot;[]&quot;, &quot;Dead&quot;, &quot;Reticle&quot;), &quot;visible&quot;, 1, &quot;range&quot;, rangeFilter)]
};
case &quot;two creatures&quot;:
{
    [targetDialog = 1]
     [targetFilter = json.set(&quot;{}&quot;, &quot;pc&quot;, if(calledByPC, 0, 1), &quot;npc&quot;, if(calledByPC, 1, 0), &quot;unsetStates&quot;, json.append(&quot;[]&quot;, &quot;Dead&quot;, &quot;Reticle&quot;), &quot;visible&quot;, 1, &quot;range&quot;, rangeFilter)]
};
case &quot;one creature two attacks&quot;:
{
    [targetDialog = 1]
     [targetFilter = json.set(&quot;{}&quot;, &quot;pc&quot;, if(calledByPC, 0, 1), &quot;npc&quot;, if(calledByPC, 1, 0), &quot;unsetStates&quot;, json.append(&quot;[]&quot;, &quot;Dead&quot;, &quot;Reticle&quot;), &quot;visible&quot;, 1, &quot;range&quot;, rangeFilter)]
};
case &quot;each enemy in burst&quot;:
{
    [targetDialog = 2]
    [if(attType == &quot;area&quot;): rangeFilter = json.set(rangeFilter, &quot;token&quot;, reticle); rangeFilter = rangeFilter]
     [targetFilter = json.set(&quot;{}&quot;, &quot;pc&quot;, if(calledByPC, 0, 1), &quot;npc&quot;, if(calledByPC, 1, 0), &quot;unsetStates&quot;, json.append(&quot;[]&quot;, &quot;Dead&quot;, &quot;Reticle&quot;), &quot;visible&quot;, 1, &quot;range&quot;, rangeFilter)]
};
case &quot;each creature in burst&quot;:
{
    [targetDialog = 2]
    [if(attType == &quot;area&quot;): rangeFilter = json.set(rangeFilter, &quot;token&quot;, reticle); rangeFilter = rangeFilter]
    [targetFilter = json.set(&quot;{}&quot;, &quot;unsetStates&quot;, json.append(&quot;[]&quot;, &quot;Dead&quot;), &quot;visible&quot;, 1, &quot;range&quot;, rangeFilter)]
};
case &quot;targets allies&quot;:
{
     [targetDialog = 3]
     [targetFilter = json.set(&quot;{}&quot;, &quot;pc&quot;, if(calledByPC,1,0), &quot;npc&quot;, if(calledByPC, 0,1), &quot;unsetStates&quot;, json.append(&quot;[]&quot;, &quot;Dead&quot;, &quot;Reticle&quot;), &quot;visible&quot;, 1, &quot;range&quot;, rangeFilter)]
};
case &quot;personal&quot;:
{
    [targetDialog = 4]
    [targetFilter = json.set(&quot;{}&quot;, &quot;pc&quot;, if(calledByPC, 0, 1), &quot;npc&quot;, if(calledByPC, 1, 0), &quot;unsetStates&quot;, json.append(&quot;[]&quot;, &quot;Dead&quot;, &quot;Reticle&quot;), &quot;visible&quot;, 1, &quot;range&quot;, rangeFilter)]
};]

[h:exp = getTokenNames(&quot;json&quot;, targetFilter)]
[h:expList = listSort(json.toList(exp),&quot;N+&quot;)]

&lt;!--Powers that target yourself--&gt;
[h,if(pTargets == &quot;personal&quot;):expList=me]

[h,if(expList == &quot;&quot;):assert(0, rangeError(), 0)]

&lt;!--Create Image List of Targets--&gt;
[H: imgList = expList]
[H: Num = listCount(imgList)]
[h,COUNT(Num),CODE:
   {
     [h:targetName=listGet(imgList,roll.count)]
     [h,token(targetName): image=getTokenImage()]
     [h:imgList=listReplace(imgList,roll.count,targetName+&quot; &quot;+image)]
   }]
   
&lt;!--Build the first line of the targeting dialog--&gt;

[h:inputParams = json.append(&quot;[]&quot;, &quot;basicStuff|Attack Basics||TAB|SELECT=1&quot;,&quot;junk|&lt;html&gt;&lt;b&gt;Use Power: &quot;+pName+&quot;&lt;/b&gt;&lt;/html&gt;||LABEL|SPAN=TRUE&quot;)]


&lt;!--Switch through the targeting options to build the proper dialog contents for different target lists--&gt;

[h,switch(targetDialog),CODE:
case 0: {[inputParams = json.append(inputParams, &quot;targetNum|&quot;+imgList+&quot;|Select Target|LIST|SELECT=0 ICON=TRUE ICONSIZE=30&quot;)]};
case 1: {[inputParams = json.append(inputParams, &quot;junk|&lt;html&gt;&lt;i&gt;Select same target twice to target both attacks on a single creature&lt;/i&gt;&lt;/html&gt;||LABEL|SPAN=TRUE&quot;,
	&quot;target1|&quot;+imgList+&quot;|Select Target 1|LIST|SELECT=0 ICON=TRUE ICONSIZE=30&quot;,
	&quot;target2|&quot;+imgList+&quot;|Select Target 2|LIST|SELECT=0 ICON=TRUE ICONSIZE=30&quot;)]};
case 2:
{
	[foreach(target, expList),CODE:
	{
	     [token(target): targImg = getTokenImage()]
	     [inputParams = json.append(inputParams, &quot;target&quot;+roll.count+&quot;|1|&lt;html&gt;&lt;img src=&apos;&quot;+targImg+&quot;&apos; height=&apos;30&apos; width=&apos;30&apos;&apos; align=&apos;middle&apos;&gt;&lt;/img&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp; &quot;+target+&quot;&lt;/html&gt;|CHECK&quot;)]
	}]
};
case 3:
{
	[foreach(target, expList),CODE:
	{
	     [token(target): targImg = getTokenImage()]
	     [inputParams = json.append(inputParams, &quot;target&quot;+roll.count+&quot;|1|&lt;html&gt;&lt;img src=&apos;&quot;+targImg+&quot;&apos; height=&apos;30&apos; width=&apos;30&apos;&apos; align=&apos;middle&apos;&gt;&lt;/img&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp; &quot;+target+&quot;&lt;/html&gt;|CHECK&quot;)]
	}]
};
case 4:
 {
    [inputParams = json.append(inputParams, &quot;.|Range: Personal||LABEL|SPAN=TRUE&quot;)]
    [diffCA = 0]
    [diffCover = 0]
    [cover = &quot;null&quot;]
    [MiscBonus = 0]
    [MiscPenalty = 0]
    [mdb = 0]
    [optMods = 0]
    [tmpExpandCrit = 0]
    [critRange = 0]
    [markOn = 0]
    [rollTwice = 0]
};]

[h,if(targetDialog != 4),CODE:
{
[inputParams = json.append(inputParams, 
	&quot;.|---------------------------------------------------------------------------------------------------||LABEL|SPAN=TRUE&quot;,
    &quot;diffCA|0| Combat Advantage (vs. some or all targets)|CHECK&quot;,
    if(targetDialog == 0, &quot;cover|None,Regular(-2),Superior(-5)|Target&apos;s cover|LIST|SELECT=0&quot;, &quot;diffCover|0|Some or all targets have cover|CHECK&quot;),
	&quot;MiscBonus|0|&lt;html&gt;Miscellaneous &lt;b&gt;bonus&lt;/b&gt; to attack&quot;,
	&quot;MiscPenalty|0|&lt;html&gt;Miscellaneous &lt;b&gt;penalty&lt;/b&gt; to attack&lt;/html&gt;&quot;,
	&quot;mdb|0|Miscellaneous modifier to damage&quot;)]
                     	[h,if(pReqs != &quot;&quot; || phEff != &quot;&quot; || pmEff != &quot;&quot; || (paEff != &quot;&quot; &amp;&amp; targetDialog !=4) ): inputParams = json.append(inputParams, &quot;.|---------------------------------------------------------------------------------------------------||LABEL|SPAN=TRUE&quot;,&quot;.|&lt;html&gt;&lt;b&gt;Power Notes&lt;/b&gt;||LABEL|SPAN=TRUE&quot;)]
[h,if(pReqs != &quot;&quot;): inputParams = json.append(inputParams, &quot;.|&lt;html&gt; &amp;nbsp;&amp;nbsp; &lt;b&gt;Requirement:&lt;/b&gt; &quot;+pReqs+&quot;&lt;/html&gt;||LABEL|SPAN=TRUE&quot;)]
[h,if(phEff != &quot;&quot;): inputParams = json.append(inputParams, &quot;.|&lt;html&gt; &amp;nbsp;&amp;nbsp; &lt;b&gt;Hit:&lt;/b&gt; &quot;+phEff+&quot;&lt;/html&gt;||LABEL|SPAN=TRUE&quot;)]
[h,if(pmEff != &quot;&quot;): inputParams = json.append(inputParams, &quot;.|&lt;html&gt; &amp;nbsp;&amp;nbsp; &lt;b&gt;Miss&lt;/b&gt; &quot;+pmEff+&quot;&lt;/html&gt;||LABEL|SPAN=TRUE&quot;)]
[h,if(paEff != &quot;&quot; &amp;&amp; targetDialog != 4): inputParams = json.append(inputParams, &quot;.|&lt;html&gt; &amp;nbsp;&amp;nbsp; &lt;b&gt;Effect:&lt;/b&gt; &quot;+paEff+&quot;&lt;/html&gt;||LABEL|SPAN=TRUE&quot;)]
	[inputParams = json.append(inputParams, &quot;optMods|Optional Modifiers||TAB&quot;,
	&quot;tmpExpandCrit|0|This power has an expanded critical hit range|CHECK&quot;,
	&quot;critRange|0|Enter lower end of expanded critical hit range here&quot;,
	&quot;rollTwice|N/A,Highest,Lowest|This power allows two rolls. Roll twice and take the|LIST|SELECT=0&quot;,
	&quot;.|&lt;html&gt;&lt;i&gt;Note: do not use this if you are using Oath of Enmity on the target&lt;/i&gt;&lt;/html&gt;||LABEL|SPAN=TRUE&quot;)]
};
{
   [inputParams = json.append(inputParams, &quot;.|&quot;+paEff+&quot;|&lt;html&gt;&lt;b&gt;Effect:&lt;/b&gt;&lt;/html&gt;|LABEL&quot;)]
 
};]


[h:newInputParams = json.toList(inputParams, &quot;##&quot;)]
[h:status=input(newInputParams)]
[h:abort(status)]

&lt;!--Target Post Processing--&gt;

[h,switch(targetDialog),CODE:
case 0: { 
	[h:TargetName=listGet(expList,targetNum)]
	[h:targList=listAppend(targList,TargetName)]
};
case 1: {
	[h:Target1Name=listGet(expList,target1)]
	[h:Target2Name=listGet(expList,target2)]
	[h:targList=listAppend(targList,Target1Name)]
	[h:targList=listAppend(targList,Target2Name)]
};
case 4: {
	[h:targList = expList]
};
default: {
	[h,foreach(target, expList),if(eval(&quot;target&quot;+roll.count)):targList = listAppend(targList,listGet(expList,roll.count))]
};]


&lt;!--Handle Differing Cover--&gt;
[h,if(targetDialog &gt; 0): cover = &quot;null&quot;]

[h,switch(cover),code:
case 0: {[coverVal = 0][diffCover=1]};
case 1: {[coverVal = 2][diffCover=1]};
case 2:{[coverVal=5][diffCover=1]};
case &quot;null&quot;: {};]

	[h,if(diffCover),code:
	{
      [if(targetDialog &gt; 0): coverInfo = varyCover(targList); coverInfo = json.set(&quot;{}&quot;, targList, coverVal)]
	};
	{
	  [h:coverInfo=json.set(&quot;{}&quot;, &quot;key&quot;, &quot;0&quot;)]
	};]

&lt;!--Handle Differing Combat Advantage--&gt;
	[h,if(diffCA),code:
	{
	  [if(targetDialog &gt; 0): caInfo = varyCA(targList); caInfo = json.set(&quot;{}&quot;, targList, 2)]
	};
	{
	  [h:caInfo=json.set(&quot;{}&quot;, &quot;key&quot;, &quot;0&quot;)]
	};]
	[h,if(tmpExpandCrit): critRangeLower = critRange; critRangeLower = 20]

[h,if(targetDialog == 0),token(targList): oath = if(state.Oath, 1, 0)]

[h,if(pTargets == &quot;two creatures&quot;),CODE:
{
   [checkTwoTargets(targList, targetFilter,pName)]
   [targList = macro.return]
}]
	
[h:currentAttackOptions = json.set(&quot;{}&quot;, &quot;targets&quot;, targList, &quot;miscBonus&quot;, MiscBonus,  &quot;miscPen&quot;, MiscPenalty,&quot;mdb&quot;, mdb, &quot;rollTwice&quot;, rollTwice, &quot;coverInfo&quot;, coverInfo, &quot;caInfo&quot;, caInfo, &quot;oath&quot;, oath, &quot;expandCrit&quot;, critRangeLower)]</command>
        <label>Targeting</label>
        <group>Combat - Targeting</group>
        <sortby></sortby>
        <autoExecute>true</autoExecute>
        <includeLabel>false</includeLabel>
        <applyToTokens>false</applyToTokens>
        <fontColorKey>black</fontColorKey>
        <fontSize>1.00em</fontSize>
        <minWidth></minWidth>
        <maxWidth></maxWidth>
        <allowPlayerEdits>true</allowPlayerEdits>
        <toolTip></toolTip>
        <commonMacro>false</commonMacro>
        <compareGroup>true</compareGroup>
        <compareSortPrefix>true</compareSortPrefix>
        <compareCommand>true</compareCommand>
        <compareIncludeLabel>true</compareIncludeLabel>
        <compareAutoExecute>true</compareAutoExecute>
        <compareApplyToSelectedTokens>true</compareApplyToSelectedTokens>
      </net.rptools.maptool.model.MacroButtonProperties>
    </entry>
  </macroPropertiesMap>
  <speechMap/>
</net.rptools.maptool.model.Token>

